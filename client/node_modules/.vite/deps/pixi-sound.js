import {
  require_earcut,
  require_eventemitter3,
  require_url
} from "./chunk-P2EMTRT2.js";
import {
  __commonJS,
  __toESM
} from "./chunk-G3PMV62Z.js";

// node_modules/parse-uri/src/index.js
var require_src = __commonJS({
  "node_modules/parse-uri/src/index.js"(exports, module) {
    "use strict";
    module.exports = (str, opts = {}) => {
      if (!str) return void 0;
      const queryParser = /(?:^|&)([^&=]*)=?([^&]*)/g;
      const patterns = {
        // Captures: protocol, authority, path, query, fragment
        // Updated to handle schemes without '//' like mailto:, tel:, etc.
        strict: /^(?:([^:/?#]+):)?(?:\/\/([^/?#]*)|([^?#]*?))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?/,
        // Loose pattern updated to handle mailto and similar schemes
        loose: /^(?:([^:/?#.]+):)?(?:\/\/([^/?#]*)|([^?#]*?))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?/
      };
      const pattern = opts.strictMode ? patterns.strict : patterns.loose;
      const matches = pattern.exec(str);
      if (!matches) return void 0;
      const [
        ,
        protocol = "",
        authority = "",
        schemePart = "",
        relative = "",
        query = "",
        anchor = ""
      ] = matches;
      const actualAuthority = authority || "";
      const actualRelative = authority ? relative : schemePart + relative;
      const uri = {
        source: str,
        protocol,
        authority: actualAuthority,
        relative: actualRelative,
        query,
        anchor,
        userInfo: "",
        user: "",
        password: "",
        host: "",
        port: "",
        path: actualRelative,
        directory: "",
        file: "",
        queryKey: {}
      };
      if (actualAuthority) {
        const authorityPattern = /^(?:(([^:@]*)(?::([^:@]*))?)?@)?([^:/?#]*)(?::(\d*))?/;
        const authorityMatches = authorityPattern.exec(actualAuthority);
        if (authorityMatches) {
          const [, userInfo = "", user = "", password = "", host = "", port = ""] = authorityMatches;
          Object.assign(uri, { userInfo, user, password, host, port });
        }
      }
      if (actualRelative) {
        const lastSlashIndex = actualRelative.lastIndexOf("/");
        if (lastSlashIndex > -1) {
          uri.directory = actualRelative.substring(0, lastSlashIndex + 1);
          uri.file = actualRelative.substring(lastSlashIndex + 1);
        } else {
          uri.file = actualRelative;
        }
      }
      if (query) {
        for (const [, key, value] of query.matchAll(queryParser)) {
          if (key) uri.queryKey[key] = value;
        }
      }
      return uri;
    };
  }
});

// node_modules/resource-loader/dist/resource-loader.esm.js
var import_parse_uri = __toESM(require_src());

// node_modules/mini-signals/src/mini-signals.js
var MiniSignalBinding = class {
  /**
  * MiniSignalBinding constructor.
  * @constructs MiniSignalBinding
  * @param {Function} fn Event handler to be called.
  * @param {Boolean} [once=false] Should this listener be removed after dispatch
  * @param {Mixed} [thisArg] The context of the callback function.
  * @api private
  */
  constructor(fn, once = false, thisArg) {
    this._fn = fn;
    this._once = once;
    this._thisArg = thisArg;
    this._next = this._prev = this._owner = null;
  }
  detach() {
    if (this._owner === null) return false;
    this._owner.detach(this);
    return true;
  }
};
function _addMiniSignalBinding(self, node) {
  if (!self._head) {
    self._head = node;
    self._tail = node;
  } else {
    self._tail._next = node;
    node._prev = self._tail;
    self._tail = node;
  }
  node._owner = self;
  return node;
}
var MiniSignal = class {
  /**
  * MiniSignal constructor.
  * @constructs MiniSignal
  * @api public
  *
  * @example
  * let mySignal = new MiniSignal();
  * let binding = mySignal.add(onSignal);
  * mySignal.dispatch('foo', 'bar');
  * mySignal.detach(binding);
  */
  constructor() {
    this._head = this._tail = void 0;
  }
  /**
  * Return an array of attached MiniSignalBinding.
  *
  * @param {Boolean} [exists=false] We only need to know if there are handlers.
  * @returns {MiniSignalBinding[]|Boolean} Array of attached MiniSignalBinding or Boolean if called with exists = true
  * @api public
  */
  handlers(exists = false) {
    let node = this._head;
    if (exists) return !!node;
    const ee = [];
    while (node) {
      ee.push(node);
      node = node._next;
    }
    return ee;
  }
  /**
  * Return true if node is a MiniSignalBinding attached to this MiniSignal
  *
  * @param {MiniSignalBinding} node Node to check.
  * @returns {Boolean} True if node is attache to mini-signal
  * @api public
  */
  has(node) {
    if (!(node instanceof MiniSignalBinding)) {
      throw new Error("MiniSignal#has(): First arg must be a MiniSignalBinding object.");
    }
    return node._owner === this;
  }
  /**
  * Dispaches a signal to all registered listeners.
  *
  * @returns {Boolean} Indication if we've emitted an event.
  * @api public
  */
  dispatch() {
    let node = this._head;
    if (!node) return false;
    while (node) {
      if (node._once) this.detach(node);
      node._fn.apply(node._thisArg, arguments);
      node = node._next;
    }
    return true;
  }
  /**
  * Register a new listener.
  *
  * @param {Function} fn Callback function.
  * @param {Mixed} [thisArg] The context of the callback function.
  * @returns {MiniSignalBinding} The MiniSignalBinding node that was added.
  * @api public
  */
  add(fn, thisArg = null) {
    if (typeof fn !== "function") {
      throw new Error("MiniSignal#add(): First arg must be a Function.");
    }
    return _addMiniSignalBinding(this, new MiniSignalBinding(fn, false, thisArg));
  }
  /**
  * Register a new listener that will be executed only once.
  *
  * @param {Function} fn Callback function.
  * @param {Mixed} [thisArg] The context of the callback function.
  * @returns {MiniSignalBinding} The MiniSignalBinding node that was added.
  * @api public
  */
  once(fn, thisArg = null) {
    if (typeof fn !== "function") {
      throw new Error("MiniSignal#once(): First arg must be a Function.");
    }
    return _addMiniSignalBinding(this, new MiniSignalBinding(fn, true, thisArg));
  }
  /**
  * Remove binding object.
  *
  * @param {MiniSignalBinding} node The binding node that will be removed.
  * @returns {MiniSignal} The instance on which this method was called.
  * @api public */
  detach(node) {
    if (!(node instanceof MiniSignalBinding)) {
      throw new Error("MiniSignal#detach(): First arg must be a MiniSignalBinding object.");
    }
    if (node._owner !== this) return this;
    if (node._prev) node._prev._next = node._next;
    if (node._next) node._next._prev = node._prev;
    if (node === this._head) {
      this._head = node._next;
      if (node._next === null) {
        this._tail = null;
      }
    } else if (node === this._tail) {
      this._tail = node._prev;
      this._tail._next = null;
    }
    node._owner = null;
    return this;
  }
  /**
  * Detach all listeners.
  *
  * @returns {MiniSignal} The instance on which this method was called.
  * @api public
  */
  detachAll() {
    let node = this._head;
    if (!node) return this;
    this._head = this._tail = null;
    while (node) {
      node._owner = null;
      node = node._next;
    }
    return this;
  }
};
var mini_signals_default = MiniSignal;

// node_modules/resource-loader/dist/resource-loader.esm.js
function _noop() {
}
function eachSeries(array, iterator, callback, deferNext) {
  var i = 0;
  var len = array.length;
  (function next(err) {
    if (err || i === len) {
      if (callback) {
        callback(err);
      }
      return;
    }
    if (deferNext) {
      setTimeout(function() {
        iterator(array[i++], next);
      }, 1);
    } else {
      iterator(array[i++], next);
    }
  })();
}
function onlyOnce(fn) {
  return function onceWrapper() {
    if (fn === null) {
      throw new Error("Callback was already called.");
    }
    var callFn = fn;
    fn = null;
    callFn.apply(this, arguments);
  };
}
function queue(worker, concurrency) {
  if (concurrency == null) {
    concurrency = 1;
  } else if (concurrency === 0) {
    throw new Error("Concurrency must not be zero");
  }
  var workers = 0;
  var q = {
    _tasks: [],
    concurrency,
    saturated: _noop,
    unsaturated: _noop,
    buffer: concurrency / 4,
    empty: _noop,
    drain: _noop,
    error: _noop,
    started: false,
    paused: false,
    push: function push(data, callback) {
      _insert(data, false, callback);
    },
    kill: function kill() {
      workers = 0;
      q.drain = _noop;
      q.started = false;
      q._tasks = [];
    },
    unshift: function unshift(data, callback) {
      _insert(data, true, callback);
    },
    process: function process() {
      while (!q.paused && workers < q.concurrency && q._tasks.length) {
        var task = q._tasks.shift();
        if (q._tasks.length === 0) {
          q.empty();
        }
        workers += 1;
        if (workers === q.concurrency) {
          q.saturated();
        }
        worker(task.data, onlyOnce(_next(task)));
      }
    },
    length: function length() {
      return q._tasks.length;
    },
    running: function running() {
      return workers;
    },
    idle: function idle() {
      return q._tasks.length + workers === 0;
    },
    pause: function pause() {
      if (q.paused === true) {
        return;
      }
      q.paused = true;
    },
    resume: function resume() {
      if (q.paused === false) {
        return;
      }
      q.paused = false;
      for (var w2 = 1; w2 <= q.concurrency; w2++) {
        q.process();
      }
    }
  };
  function _insert(data, insertAtFront, callback) {
    if (callback != null && typeof callback !== "function") {
      throw new Error("task callback must be a function");
    }
    q.started = true;
    if (data == null && q.idle()) {
      setTimeout(function() {
        return q.drain();
      }, 1);
      return;
    }
    var item = {
      data,
      callback: typeof callback === "function" ? callback : _noop
    };
    if (insertAtFront) {
      q._tasks.unshift(item);
    } else {
      q._tasks.push(item);
    }
    setTimeout(function() {
      return q.process();
    }, 1);
  }
  function _next(task) {
    return function next() {
      workers -= 1;
      task.callback.apply(task, arguments);
      if (arguments[0] != null) {
        q.error(arguments[0], task.data);
      }
      if (workers <= q.concurrency - q.buffer) {
        q.unsaturated();
      }
      if (q.idle()) {
        q.drain();
      }
      q.process();
    };
  }
  return q;
}
var cache = {};
function caching(resource, next) {
  var _this = this;
  if (cache[resource.url]) {
    resource.data = cache[resource.url];
    resource.complete();
  } else {
    resource.onComplete.once(function() {
      return cache[_this.url] = _this.data;
    });
  }
  next();
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}
var useXdr = !!(window.XDomainRequest && !("withCredentials" in new XMLHttpRequest()));
var tempAnchor = null;
var STATUS_NONE = 0;
var STATUS_OK = 200;
var STATUS_EMPTY = 204;
var STATUS_IE_BUG_EMPTY = 1223;
var STATUS_TYPE_OK = 2;
function _noop$1() {
}
var Resource = function() {
  Resource4.setExtensionLoadType = function setExtensionLoadType(extname, loadType) {
    setExtMap(Resource4._loadTypeMap, extname, loadType);
  };
  Resource4.setExtensionXhrType = function setExtensionXhrType(extname, xhrType) {
    setExtMap(Resource4._xhrTypeMap, extname, xhrType);
  };
  function Resource4(name, url, options) {
    if (typeof name !== "string" || typeof url !== "string") {
      throw new Error("Both name and url are required for constructing a resource.");
    }
    options = options || {};
    this._flags = 0;
    this._setFlag(Resource4.STATUS_FLAGS.DATA_URL, url.indexOf("data:") === 0);
    this.name = name;
    this.url = url;
    this.extension = this._getExtension();
    this.data = null;
    this.crossOrigin = options.crossOrigin === true ? "anonymous" : options.crossOrigin;
    this.timeout = options.timeout || 0;
    this.loadType = options.loadType || this._determineLoadType();
    this.xhrType = options.xhrType;
    this.metadata = options.metadata || {};
    this.error = null;
    this.xhr = null;
    this.children = [];
    this.type = Resource4.TYPE.UNKNOWN;
    this.progressChunk = 0;
    this._dequeue = _noop$1;
    this._onLoadBinding = null;
    this._elementTimer = 0;
    this._boundComplete = this.complete.bind(this);
    this._boundOnError = this._onError.bind(this);
    this._boundOnProgress = this._onProgress.bind(this);
    this._boundOnTimeout = this._onTimeout.bind(this);
    this._boundXhrOnError = this._xhrOnError.bind(this);
    this._boundXhrOnTimeout = this._xhrOnTimeout.bind(this);
    this._boundXhrOnAbort = this._xhrOnAbort.bind(this);
    this._boundXhrOnLoad = this._xhrOnLoad.bind(this);
    this.onStart = new mini_signals_default();
    this.onProgress = new mini_signals_default();
    this.onComplete = new mini_signals_default();
    this.onAfterMiddleware = new mini_signals_default();
  }
  var _proto = Resource4.prototype;
  _proto.complete = function complete() {
    this._clearEvents();
    this._finish();
  };
  _proto.abort = function abort(message) {
    if (this.error) {
      return;
    }
    this.error = new Error(message);
    this._clearEvents();
    if (this.xhr) {
      this.xhr.abort();
    } else if (this.xdr) {
      this.xdr.abort();
    } else if (this.data) {
      if (this.data.src) {
        this.data.src = Resource4.EMPTY_GIF;
      } else {
        while (this.data.firstChild) {
          this.data.removeChild(this.data.firstChild);
        }
      }
    }
    this._finish();
  };
  _proto.load = function load(cb) {
    var _this = this;
    if (this.isLoading) {
      return;
    }
    if (this.isComplete) {
      if (cb) {
        setTimeout(function() {
          return cb(_this);
        }, 1);
      }
      return;
    } else if (cb) {
      this.onComplete.once(cb);
    }
    this._setFlag(Resource4.STATUS_FLAGS.LOADING, true);
    this.onStart.dispatch(this);
    if (this.crossOrigin === false || typeof this.crossOrigin !== "string") {
      this.crossOrigin = this._determineCrossOrigin(this.url);
    }
    switch (this.loadType) {
      case Resource4.LOAD_TYPE.IMAGE:
        this.type = Resource4.TYPE.IMAGE;
        this._loadElement("image");
        break;
      case Resource4.LOAD_TYPE.AUDIO:
        this.type = Resource4.TYPE.AUDIO;
        this._loadSourceElement("audio");
        break;
      case Resource4.LOAD_TYPE.VIDEO:
        this.type = Resource4.TYPE.VIDEO;
        this._loadSourceElement("video");
        break;
      case Resource4.LOAD_TYPE.XHR:
      /* falls through */
      default:
        if (useXdr && this.crossOrigin) {
          this._loadXdr();
        } else {
          this._loadXhr();
        }
        break;
    }
  };
  _proto._hasFlag = function _hasFlag(flag) {
    return (this._flags & flag) !== 0;
  };
  _proto._setFlag = function _setFlag(flag, value) {
    this._flags = value ? this._flags | flag : this._flags & ~flag;
  };
  _proto._clearEvents = function _clearEvents() {
    clearTimeout(this._elementTimer);
    if (this.data && this.data.removeEventListener) {
      this.data.removeEventListener("error", this._boundOnError, false);
      this.data.removeEventListener("load", this._boundComplete, false);
      this.data.removeEventListener("progress", this._boundOnProgress, false);
      this.data.removeEventListener("canplaythrough", this._boundComplete, false);
    }
    if (this.xhr) {
      if (this.xhr.removeEventListener) {
        this.xhr.removeEventListener("error", this._boundXhrOnError, false);
        this.xhr.removeEventListener("timeout", this._boundXhrOnTimeout, false);
        this.xhr.removeEventListener("abort", this._boundXhrOnAbort, false);
        this.xhr.removeEventListener("progress", this._boundOnProgress, false);
        this.xhr.removeEventListener("load", this._boundXhrOnLoad, false);
      } else {
        this.xhr.onerror = null;
        this.xhr.ontimeout = null;
        this.xhr.onprogress = null;
        this.xhr.onload = null;
      }
    }
  };
  _proto._finish = function _finish() {
    if (this.isComplete) {
      throw new Error("Complete called again for an already completed resource.");
    }
    this._setFlag(Resource4.STATUS_FLAGS.COMPLETE, true);
    this._setFlag(Resource4.STATUS_FLAGS.LOADING, false);
    this.onComplete.dispatch(this);
  };
  _proto._loadElement = function _loadElement(type) {
    if (this.metadata.loadElement) {
      this.data = this.metadata.loadElement;
    } else if (type === "image" && typeof window.Image !== "undefined") {
      this.data = new Image();
    } else {
      this.data = document.createElement(type);
    }
    if (this.crossOrigin) {
      this.data.crossOrigin = this.crossOrigin;
    }
    if (!this.metadata.skipSource) {
      this.data.src = this.url;
    }
    this.data.addEventListener("error", this._boundOnError, false);
    this.data.addEventListener("load", this._boundComplete, false);
    this.data.addEventListener("progress", this._boundOnProgress, false);
    if (this.timeout) {
      this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout);
    }
  };
  _proto._loadSourceElement = function _loadSourceElement(type) {
    if (this.metadata.loadElement) {
      this.data = this.metadata.loadElement;
    } else if (type === "audio" && typeof window.Audio !== "undefined") {
      this.data = new Audio();
    } else {
      this.data = document.createElement(type);
    }
    if (this.data === null) {
      this.abort("Unsupported element: " + type);
      return;
    }
    if (this.crossOrigin) {
      this.data.crossOrigin = this.crossOrigin;
    }
    if (!this.metadata.skipSource) {
      if (navigator.isCocoonJS) {
        this.data.src = Array.isArray(this.url) ? this.url[0] : this.url;
      } else if (Array.isArray(this.url)) {
        var mimeTypes = this.metadata.mimeType;
        for (var i = 0; i < this.url.length; ++i) {
          this.data.appendChild(this._createSource(type, this.url[i], Array.isArray(mimeTypes) ? mimeTypes[i] : mimeTypes));
        }
      } else {
        var _mimeTypes = this.metadata.mimeType;
        this.data.appendChild(this._createSource(type, this.url, Array.isArray(_mimeTypes) ? _mimeTypes[0] : _mimeTypes));
      }
    }
    this.data.addEventListener("error", this._boundOnError, false);
    this.data.addEventListener("load", this._boundComplete, false);
    this.data.addEventListener("progress", this._boundOnProgress, false);
    this.data.addEventListener("canplaythrough", this._boundComplete, false);
    this.data.load();
    if (this.timeout) {
      this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout);
    }
  };
  _proto._loadXhr = function _loadXhr() {
    if (typeof this.xhrType !== "string") {
      this.xhrType = this._determineXhrType();
    }
    var xhr = this.xhr = new XMLHttpRequest();
    xhr.open("GET", this.url, true);
    xhr.timeout = this.timeout;
    if (this.xhrType === Resource4.XHR_RESPONSE_TYPE.JSON || this.xhrType === Resource4.XHR_RESPONSE_TYPE.DOCUMENT) {
      xhr.responseType = Resource4.XHR_RESPONSE_TYPE.TEXT;
    } else {
      xhr.responseType = this.xhrType;
    }
    xhr.addEventListener("error", this._boundXhrOnError, false);
    xhr.addEventListener("timeout", this._boundXhrOnTimeout, false);
    xhr.addEventListener("abort", this._boundXhrOnAbort, false);
    xhr.addEventListener("progress", this._boundOnProgress, false);
    xhr.addEventListener("load", this._boundXhrOnLoad, false);
    xhr.send();
  };
  _proto._loadXdr = function _loadXdr() {
    if (typeof this.xhrType !== "string") {
      this.xhrType = this._determineXhrType();
    }
    var xdr = this.xhr = new XDomainRequest();
    xdr.timeout = this.timeout || 5e3;
    xdr.onerror = this._boundXhrOnError;
    xdr.ontimeout = this._boundXhrOnTimeout;
    xdr.onprogress = this._boundOnProgress;
    xdr.onload = this._boundXhrOnLoad;
    xdr.open("GET", this.url, true);
    setTimeout(function() {
      return xdr.send();
    }, 1);
  };
  _proto._createSource = function _createSource(type, url, mime) {
    if (!mime) {
      mime = type + "/" + this._getExtension(url);
    }
    var source = document.createElement("source");
    source.src = url;
    source.type = mime;
    return source;
  };
  _proto._onError = function _onError(event) {
    this.abort("Failed to load element using: " + event.target.nodeName);
  };
  _proto._onProgress = function _onProgress(event) {
    if (event && event.lengthComputable) {
      this.onProgress.dispatch(this, event.loaded / event.total);
    }
  };
  _proto._onTimeout = function _onTimeout() {
    this.abort("Load timed out.");
  };
  _proto._xhrOnError = function _xhrOnError() {
    var xhr = this.xhr;
    this.abort(reqType(xhr) + " Request failed. Status: " + xhr.status + ', text: "' + xhr.statusText + '"');
  };
  _proto._xhrOnTimeout = function _xhrOnTimeout() {
    var xhr = this.xhr;
    this.abort(reqType(xhr) + " Request timed out.");
  };
  _proto._xhrOnAbort = function _xhrOnAbort() {
    var xhr = this.xhr;
    this.abort(reqType(xhr) + " Request was aborted by the user.");
  };
  _proto._xhrOnLoad = function _xhrOnLoad() {
    var xhr = this.xhr;
    var text = "";
    var status = typeof xhr.status === "undefined" ? STATUS_OK : xhr.status;
    if (xhr.responseType === "" || xhr.responseType === "text" || typeof xhr.responseType === "undefined") {
      text = xhr.responseText;
    }
    if (status === STATUS_NONE && (text.length > 0 || xhr.responseType === Resource4.XHR_RESPONSE_TYPE.BUFFER)) {
      status = STATUS_OK;
    } else if (status === STATUS_IE_BUG_EMPTY) {
      status = STATUS_EMPTY;
    }
    var statusType = status / 100 | 0;
    if (statusType === STATUS_TYPE_OK) {
      if (this.xhrType === Resource4.XHR_RESPONSE_TYPE.TEXT) {
        this.data = text;
        this.type = Resource4.TYPE.TEXT;
      } else if (this.xhrType === Resource4.XHR_RESPONSE_TYPE.JSON) {
        try {
          this.data = JSON.parse(text);
          this.type = Resource4.TYPE.JSON;
        } catch (e) {
          this.abort("Error trying to parse loaded json: " + e);
          return;
        }
      } else if (this.xhrType === Resource4.XHR_RESPONSE_TYPE.DOCUMENT) {
        try {
          if (window.DOMParser) {
            var domparser = new DOMParser();
            this.data = domparser.parseFromString(text, "text/xml");
          } else {
            var div = document.createElement("div");
            div.innerHTML = text;
            this.data = div;
          }
          this.type = Resource4.TYPE.XML;
        } catch (e) {
          this.abort("Error trying to parse loaded xml: " + e);
          return;
        }
      } else {
        this.data = xhr.response || text;
      }
    } else {
      this.abort("[" + xhr.status + "] " + xhr.statusText + ": " + xhr.responseURL);
      return;
    }
    this.complete();
  };
  _proto._determineCrossOrigin = function _determineCrossOrigin(url, loc) {
    if (url.indexOf("data:") === 0) {
      return "";
    }
    if (window.origin !== window.location.origin) {
      return "anonymous";
    }
    loc = loc || window.location;
    if (!tempAnchor) {
      tempAnchor = document.createElement("a");
    }
    tempAnchor.href = url;
    url = (0, import_parse_uri.default)(tempAnchor.href, {
      strictMode: true
    });
    var samePort = !url.port && loc.port === "" || url.port === loc.port;
    var protocol = url.protocol ? url.protocol + ":" : "";
    if (url.host !== loc.hostname || !samePort || protocol !== loc.protocol) {
      return "anonymous";
    }
    return "";
  };
  _proto._determineXhrType = function _determineXhrType() {
    return Resource4._xhrTypeMap[this.extension] || Resource4.XHR_RESPONSE_TYPE.TEXT;
  };
  _proto._determineLoadType = function _determineLoadType() {
    return Resource4._loadTypeMap[this.extension] || Resource4.LOAD_TYPE.XHR;
  };
  _proto._getExtension = function _getExtension() {
    var url = this.url;
    var ext = "";
    if (this.isDataUrl) {
      var slashIndex = url.indexOf("/");
      ext = url.substring(slashIndex + 1, url.indexOf(";", slashIndex));
    } else {
      var queryStart = url.indexOf("?");
      var hashStart = url.indexOf("#");
      var index2 = Math.min(queryStart > -1 ? queryStart : url.length, hashStart > -1 ? hashStart : url.length);
      url = url.substring(0, index2);
      ext = url.substring(url.lastIndexOf(".") + 1);
    }
    return ext.toLowerCase();
  };
  _proto._getMimeFromXhrType = function _getMimeFromXhrType(type) {
    switch (type) {
      case Resource4.XHR_RESPONSE_TYPE.BUFFER:
        return "application/octet-binary";
      case Resource4.XHR_RESPONSE_TYPE.BLOB:
        return "application/blob";
      case Resource4.XHR_RESPONSE_TYPE.DOCUMENT:
        return "application/xml";
      case Resource4.XHR_RESPONSE_TYPE.JSON:
        return "application/json";
      case Resource4.XHR_RESPONSE_TYPE.DEFAULT:
      case Resource4.XHR_RESPONSE_TYPE.TEXT:
      /* falls through */
      default:
        return "text/plain";
    }
  };
  _createClass(Resource4, [{
    key: "isDataUrl",
    get: function get() {
      return this._hasFlag(Resource4.STATUS_FLAGS.DATA_URL);
    }
    /**
     * Describes if this resource has finished loading. Is true when the resource has completely
     * loaded.
     *
     * @readonly
     * @member {boolean}
     */
  }, {
    key: "isComplete",
    get: function get() {
      return this._hasFlag(Resource4.STATUS_FLAGS.COMPLETE);
    }
    /**
     * Describes if this resource is currently loading. Is true when the resource starts loading,
     * and is false again when complete.
     *
     * @readonly
     * @member {boolean}
     */
  }, {
    key: "isLoading",
    get: function get() {
      return this._hasFlag(Resource4.STATUS_FLAGS.LOADING);
    }
  }]);
  return Resource4;
}();
Resource.STATUS_FLAGS = {
  NONE: 0,
  DATA_URL: 1 << 0,
  COMPLETE: 1 << 1,
  LOADING: 1 << 2
};
Resource.TYPE = {
  UNKNOWN: 0,
  JSON: 1,
  XML: 2,
  IMAGE: 3,
  AUDIO: 4,
  VIDEO: 5,
  TEXT: 6
};
Resource.LOAD_TYPE = {
  /** Uses XMLHttpRequest to load the resource. */
  XHR: 1,
  /** Uses an `Image` object to load the resource. */
  IMAGE: 2,
  /** Uses an `Audio` object to load the resource. */
  AUDIO: 3,
  /** Uses a `Video` object to load the resource. */
  VIDEO: 4
};
Resource.XHR_RESPONSE_TYPE = {
  /** string */
  DEFAULT: "text",
  /** ArrayBuffer */
  BUFFER: "arraybuffer",
  /** Blob */
  BLOB: "blob",
  /** Document */
  DOCUMENT: "document",
  /** Object */
  JSON: "json",
  /** String */
  TEXT: "text"
};
Resource._loadTypeMap = {
  // images
  gif: Resource.LOAD_TYPE.IMAGE,
  png: Resource.LOAD_TYPE.IMAGE,
  bmp: Resource.LOAD_TYPE.IMAGE,
  jpg: Resource.LOAD_TYPE.IMAGE,
  jpeg: Resource.LOAD_TYPE.IMAGE,
  tif: Resource.LOAD_TYPE.IMAGE,
  tiff: Resource.LOAD_TYPE.IMAGE,
  webp: Resource.LOAD_TYPE.IMAGE,
  tga: Resource.LOAD_TYPE.IMAGE,
  svg: Resource.LOAD_TYPE.IMAGE,
  "svg+xml": Resource.LOAD_TYPE.IMAGE,
  // for SVG data urls
  // audio
  mp3: Resource.LOAD_TYPE.AUDIO,
  ogg: Resource.LOAD_TYPE.AUDIO,
  wav: Resource.LOAD_TYPE.AUDIO,
  // videos
  mp4: Resource.LOAD_TYPE.VIDEO,
  webm: Resource.LOAD_TYPE.VIDEO
};
Resource._xhrTypeMap = {
  // xml
  xhtml: Resource.XHR_RESPONSE_TYPE.DOCUMENT,
  html: Resource.XHR_RESPONSE_TYPE.DOCUMENT,
  htm: Resource.XHR_RESPONSE_TYPE.DOCUMENT,
  xml: Resource.XHR_RESPONSE_TYPE.DOCUMENT,
  tmx: Resource.XHR_RESPONSE_TYPE.DOCUMENT,
  svg: Resource.XHR_RESPONSE_TYPE.DOCUMENT,
  // This was added to handle Tiled Tileset XML, but .tsx is also a TypeScript React Component.
  // Since it is way less likely for people to be loading TypeScript files instead of Tiled files,
  // this should probably be fine.
  tsx: Resource.XHR_RESPONSE_TYPE.DOCUMENT,
  // images
  gif: Resource.XHR_RESPONSE_TYPE.BLOB,
  png: Resource.XHR_RESPONSE_TYPE.BLOB,
  bmp: Resource.XHR_RESPONSE_TYPE.BLOB,
  jpg: Resource.XHR_RESPONSE_TYPE.BLOB,
  jpeg: Resource.XHR_RESPONSE_TYPE.BLOB,
  tif: Resource.XHR_RESPONSE_TYPE.BLOB,
  tiff: Resource.XHR_RESPONSE_TYPE.BLOB,
  webp: Resource.XHR_RESPONSE_TYPE.BLOB,
  tga: Resource.XHR_RESPONSE_TYPE.BLOB,
  // json
  json: Resource.XHR_RESPONSE_TYPE.JSON,
  // text
  text: Resource.XHR_RESPONSE_TYPE.TEXT,
  txt: Resource.XHR_RESPONSE_TYPE.TEXT,
  // fonts
  ttf: Resource.XHR_RESPONSE_TYPE.BUFFER,
  otf: Resource.XHR_RESPONSE_TYPE.BUFFER
};
Resource.EMPTY_GIF = "data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==";
function setExtMap(map3, extname, val) {
  if (extname && extname.indexOf(".") === 0) {
    extname = extname.substring(1);
  }
  if (!extname) {
    return;
  }
  map3[extname] = val;
}
function reqType(xhr) {
  return xhr.toString().replace("object ", "");
}
var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
function encodeBinary(input) {
  var output = "";
  var inx = 0;
  while (inx < input.length) {
    var bytebuffer = [0, 0, 0];
    var encodedCharIndexes = [0, 0, 0, 0];
    for (var jnx = 0; jnx < bytebuffer.length; ++jnx) {
      if (inx < input.length) {
        bytebuffer[jnx] = input.charCodeAt(inx++) & 255;
      } else {
        bytebuffer[jnx] = 0;
      }
    }
    encodedCharIndexes[0] = bytebuffer[0] >> 2;
    encodedCharIndexes[1] = (bytebuffer[0] & 3) << 4 | bytebuffer[1] >> 4;
    encodedCharIndexes[2] = (bytebuffer[1] & 15) << 2 | bytebuffer[2] >> 6;
    encodedCharIndexes[3] = bytebuffer[2] & 63;
    var paddingBytes = inx - (input.length - 1);
    switch (paddingBytes) {
      case 2:
        encodedCharIndexes[3] = 64;
        encodedCharIndexes[2] = 64;
        break;
      case 1:
        encodedCharIndexes[3] = 64;
        break;
      default:
        break;
    }
    for (var _jnx = 0; _jnx < encodedCharIndexes.length; ++_jnx) {
      output += _keyStr.charAt(encodedCharIndexes[_jnx]);
    }
  }
  return output;
}
var Url = window.URL || window.webkitURL;
function parsing(resource, next) {
  if (!resource.data) {
    next();
    return;
  }
  if (resource.xhr && resource.xhrType === Resource.XHR_RESPONSE_TYPE.BLOB) {
    if (!window.Blob || typeof resource.data === "string") {
      var type = resource.xhr.getResponseHeader("content-type");
      if (type && type.indexOf("image") === 0) {
        resource.data = new Image();
        resource.data.src = "data:" + type + ";base64," + encodeBinary(resource.xhr.responseText);
        resource.type = Resource.TYPE.IMAGE;
        resource.data.onload = function() {
          resource.data.onload = null;
          next();
        };
        return;
      }
    } else if (resource.data.type.indexOf("image") === 0) {
      var src = Url.createObjectURL(resource.data);
      resource.blob = resource.data;
      resource.data = new Image();
      resource.data.src = src;
      resource.type = Resource.TYPE.IMAGE;
      resource.data.onload = function() {
        Url.revokeObjectURL(src);
        resource.data.onload = null;
        next();
      };
      return;
    }
  }
  next();
}
var index = {
  caching,
  parsing
};
var MAX_PROGRESS = 100;
var rgxExtractUrlHash = /(#[\w-]+)?$/;
var Loader = function() {
  function Loader3(baseUrl, concurrency) {
    var _this = this;
    if (baseUrl === void 0) {
      baseUrl = "";
    }
    if (concurrency === void 0) {
      concurrency = 10;
    }
    this.baseUrl = baseUrl;
    this.progress = 0;
    this.loading = false;
    this.defaultQueryString = "";
    this._beforeMiddleware = [];
    this._afterMiddleware = [];
    this._resourcesParsing = [];
    this._boundLoadResource = function(r2, d2) {
      return _this._loadResource(r2, d2);
    };
    this._queue = queue(this._boundLoadResource, concurrency);
    this._queue.pause();
    this.resources = {};
    this.onProgress = new mini_signals_default();
    this.onError = new mini_signals_default();
    this.onLoad = new mini_signals_default();
    this.onStart = new mini_signals_default();
    this.onComplete = new mini_signals_default();
    for (var i = 0; i < Loader3._defaultBeforeMiddleware.length; ++i) {
      this.pre(Loader3._defaultBeforeMiddleware[i]);
    }
    for (var _i = 0; _i < Loader3._defaultAfterMiddleware.length; ++_i) {
      this.use(Loader3._defaultAfterMiddleware[_i]);
    }
  }
  var _proto = Loader3.prototype;
  _proto.add = function add(name, url, options, cb) {
    if (Array.isArray(name)) {
      for (var i = 0; i < name.length; ++i) {
        this.add(name[i]);
      }
      return this;
    }
    if (typeof name === "object") {
      cb = url || name.callback || name.onComplete;
      options = name;
      url = name.url;
      name = name.name || name.key || name.url;
    }
    if (typeof url !== "string") {
      cb = options;
      options = url;
      url = name;
    }
    if (typeof url !== "string") {
      throw new Error("No url passed to add resource to loader.");
    }
    if (typeof options === "function") {
      cb = options;
      options = null;
    }
    if (this.loading && (!options || !options.parentResource)) {
      throw new Error("Cannot add resources while the loader is running.");
    }
    if (this.resources[name]) {
      throw new Error('Resource named "' + name + '" already exists.');
    }
    url = this._prepareUrl(url);
    this.resources[name] = new Resource(name, url, options);
    if (typeof cb === "function") {
      this.resources[name].onAfterMiddleware.once(cb);
    }
    if (this.loading) {
      var parent = options.parentResource;
      var incompleteChildren = [];
      for (var _i2 = 0; _i2 < parent.children.length; ++_i2) {
        if (!parent.children[_i2].isComplete) {
          incompleteChildren.push(parent.children[_i2]);
        }
      }
      var fullChunk = parent.progressChunk * (incompleteChildren.length + 1);
      var eachChunk = fullChunk / (incompleteChildren.length + 2);
      parent.children.push(this.resources[name]);
      parent.progressChunk = eachChunk;
      for (var _i3 = 0; _i3 < incompleteChildren.length; ++_i3) {
        incompleteChildren[_i3].progressChunk = eachChunk;
      }
      this.resources[name].progressChunk = eachChunk;
    }
    this._queue.push(this.resources[name]);
    return this;
  };
  _proto.pre = function pre(fn) {
    this._beforeMiddleware.push(fn);
    return this;
  };
  _proto.use = function use(fn) {
    this._afterMiddleware.push(fn);
    return this;
  };
  _proto.reset = function reset() {
    this.progress = 0;
    this.loading = false;
    this._queue.kill();
    this._queue.pause();
    for (var k2 in this.resources) {
      var res = this.resources[k2];
      if (res._onLoadBinding) {
        res._onLoadBinding.detach();
      }
      if (res.isLoading) {
        res.abort();
      }
    }
    this.resources = {};
    return this;
  };
  _proto.load = function load(cb) {
    if (typeof cb === "function") {
      this.onComplete.once(cb);
    }
    if (this.loading) {
      return this;
    }
    if (this._queue.idle()) {
      this._onStart();
      this._onComplete();
    } else {
      var numTasks = this._queue._tasks.length;
      var chunk = MAX_PROGRESS / numTasks;
      for (var i = 0; i < this._queue._tasks.length; ++i) {
        this._queue._tasks[i].data.progressChunk = chunk;
      }
      this._onStart();
      this._queue.resume();
    }
    return this;
  };
  _proto._prepareUrl = function _prepareUrl(url) {
    var parsedUrl = (0, import_parse_uri.default)(url, {
      strictMode: true
    });
    var result;
    if (parsedUrl.protocol || !parsedUrl.path || url.indexOf("//") === 0) {
      result = url;
    } else if (this.baseUrl.length && this.baseUrl.lastIndexOf("/") !== this.baseUrl.length - 1 && url.charAt(0) !== "/") {
      result = this.baseUrl + "/" + url;
    } else {
      result = this.baseUrl + url;
    }
    if (this.defaultQueryString) {
      var hash = rgxExtractUrlHash.exec(result)[0];
      result = result.substr(0, result.length - hash.length);
      if (result.indexOf("?") !== -1) {
        result += "&" + this.defaultQueryString;
      } else {
        result += "?" + this.defaultQueryString;
      }
      result += hash;
    }
    return result;
  };
  _proto._loadResource = function _loadResource(resource, dequeue) {
    var _this2 = this;
    resource._dequeue = dequeue;
    eachSeries(this._beforeMiddleware, function(fn, next) {
      fn.call(_this2, resource, function() {
        next(resource.isComplete ? {} : null);
      });
    }, function() {
      if (resource.isComplete) {
        _this2._onLoad(resource);
      } else {
        resource._onLoadBinding = resource.onComplete.once(_this2._onLoad, _this2);
        resource.load();
      }
    }, true);
  };
  _proto._onStart = function _onStart() {
    this.progress = 0;
    this.loading = true;
    this.onStart.dispatch(this);
  };
  _proto._onComplete = function _onComplete() {
    this.progress = MAX_PROGRESS;
    this.loading = false;
    this.onComplete.dispatch(this, this.resources);
  };
  _proto._onLoad = function _onLoad(resource) {
    var _this3 = this;
    resource._onLoadBinding = null;
    this._resourcesParsing.push(resource);
    resource._dequeue();
    eachSeries(this._afterMiddleware, function(fn, next) {
      fn.call(_this3, resource, next);
    }, function() {
      resource.onAfterMiddleware.dispatch(resource);
      _this3.progress = Math.min(MAX_PROGRESS, _this3.progress + resource.progressChunk);
      _this3.onProgress.dispatch(_this3, resource);
      if (resource.error) {
        _this3.onError.dispatch(resource.error, _this3, resource);
      } else {
        _this3.onLoad.dispatch(_this3, resource);
      }
      _this3._resourcesParsing.splice(_this3._resourcesParsing.indexOf(resource), 1);
      if (_this3._queue.idle() && _this3._resourcesParsing.length === 0) {
        _this3._onComplete();
      }
    }, true);
  };
  _createClass(Loader3, [{
    key: "concurrency",
    get: function get() {
      return this._queue.concurrency;
    },
    set: function set(concurrency) {
      this._queue.concurrency = concurrency;
    }
  }]);
  return Loader3;
}();
Loader._defaultBeforeMiddleware = [];
Loader._defaultAfterMiddleware = [];
Loader.pre = function LoaderPreStatic(fn) {
  Loader._defaultBeforeMiddleware.push(fn);
  return Loader;
};
Loader.use = function LoaderUseStatic(fn) {
  Loader._defaultAfterMiddleware.push(fn);
  return Loader;
};

// node_modules/ismobilejs/esm/isMobile.js
var appleIphone = /iPhone/i;
var appleIpod = /iPod/i;
var appleTablet = /iPad/i;
var appleUniversal = /\biOS-universal(?:.+)Mac\b/i;
var androidPhone = /\bAndroid(?:.+)Mobile\b/i;
var androidTablet = /Android/i;
var amazonPhone = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i;
var amazonTablet = /Silk/i;
var windowsPhone = /Windows Phone/i;
var windowsTablet = /\bWindows(?:.+)ARM\b/i;
var otherBlackBerry = /BlackBerry/i;
var otherBlackBerry10 = /BB10/i;
var otherOpera = /Opera Mini/i;
var otherChrome = /\b(CriOS|Chrome)(?:.+)Mobile/i;
var otherFirefox = /Mobile(?:.+)Firefox\b/i;
var isAppleTabletOnIos13 = function(navigator2) {
  return typeof navigator2 !== "undefined" && navigator2.platform === "MacIntel" && typeof navigator2.maxTouchPoints === "number" && navigator2.maxTouchPoints > 1 && typeof MSStream === "undefined";
};
function createMatch(userAgent) {
  return function(regex) {
    return regex.test(userAgent);
  };
}
function isMobile(param) {
  var nav = {
    userAgent: "",
    platform: "",
    maxTouchPoints: 0
  };
  if (!param && typeof navigator !== "undefined") {
    nav = {
      userAgent: navigator.userAgent,
      platform: navigator.platform,
      maxTouchPoints: navigator.maxTouchPoints || 0
    };
  } else if (typeof param === "string") {
    nav.userAgent = param;
  } else if (param && param.userAgent) {
    nav = {
      userAgent: param.userAgent,
      platform: param.platform,
      maxTouchPoints: param.maxTouchPoints || 0
    };
  }
  var userAgent = nav.userAgent;
  var tmp = userAgent.split("[FBAN");
  if (typeof tmp[1] !== "undefined") {
    userAgent = tmp[0];
  }
  tmp = userAgent.split("Twitter");
  if (typeof tmp[1] !== "undefined") {
    userAgent = tmp[0];
  }
  var match = createMatch(userAgent);
  var result = {
    apple: {
      phone: match(appleIphone) && !match(windowsPhone),
      ipod: match(appleIpod),
      tablet: !match(appleIphone) && (match(appleTablet) || isAppleTabletOnIos13(nav)) && !match(windowsPhone),
      universal: match(appleUniversal),
      device: (match(appleIphone) || match(appleIpod) || match(appleTablet) || match(appleUniversal) || isAppleTabletOnIos13(nav)) && !match(windowsPhone)
    },
    amazon: {
      phone: match(amazonPhone),
      tablet: !match(amazonPhone) && match(amazonTablet),
      device: match(amazonPhone) || match(amazonTablet)
    },
    android: {
      phone: !match(windowsPhone) && match(amazonPhone) || !match(windowsPhone) && match(androidPhone),
      tablet: !match(windowsPhone) && !match(amazonPhone) && !match(androidPhone) && (match(amazonTablet) || match(androidTablet)),
      device: !match(windowsPhone) && (match(amazonPhone) || match(amazonTablet) || match(androidPhone) || match(androidTablet)) || match(/\bokhttp\b/i)
    },
    windows: {
      phone: match(windowsPhone),
      tablet: match(windowsTablet),
      device: match(windowsPhone) || match(windowsTablet)
    },
    other: {
      blackberry: match(otherBlackBerry),
      blackberry10: match(otherBlackBerry10),
      opera: match(otherOpera),
      firefox: match(otherFirefox),
      chrome: match(otherChrome),
      device: match(otherBlackBerry) || match(otherBlackBerry10) || match(otherOpera) || match(otherFirefox) || match(otherChrome)
    },
    any: false,
    phone: false,
    tablet: false
  };
  result.any = result.apple.device || result.android.device || result.windows.device || result.other.device;
  result.phone = result.apple.phone || result.android.phone || result.windows.phone;
  result.tablet = result.apple.tablet || result.android.tablet || result.windows.tablet;
  return result;
}

// node_modules/@pixi/loaders/node_modules/@pixi/settings/lib/settings.es.js
var isMobile2 = isMobile(window.navigator);
function maxRecommendedTextures(max) {
  var allowMax = true;
  if (isMobile2.tablet || isMobile2.phone) {
    if (isMobile2.apple.device) {
      var match = navigator.userAgent.match(/OS (\d+)_(\d+)?/);
      if (match) {
        var majorVersion = parseInt(match[1], 10);
        if (majorVersion < 11) {
          allowMax = false;
        }
      }
    }
    if (isMobile2.android.device) {
      var match = navigator.userAgent.match(/Android\s([0-9.]*)/);
      if (match) {
        var majorVersion = parseInt(match[1], 10);
        if (majorVersion < 7) {
          allowMax = false;
        }
      }
    }
  }
  return allowMax ? max : 4;
}
function canUploadSameBuffer() {
  return !isMobile2.apple.device;
}
var settings = {
  /**
   * If set to true WebGL will attempt make textures mimpaped by default.
   * Mipmapping will only succeed if the base texture uploaded has power of two dimensions.
   *
   * @static
   * @name MIPMAP_TEXTURES
   * @memberof PIXI.settings
   * @type {PIXI.MIPMAP_MODES}
   * @default PIXI.MIPMAP_MODES.POW2
   */
  MIPMAP_TEXTURES: 1,
  /**
   * Default anisotropic filtering level of textures.
   * Usually from 0 to 16
   *
   * @static
   * @name ANISOTROPIC_LEVEL
   * @memberof PIXI.settings
   * @type {number}
   * @default 0
   */
  ANISOTROPIC_LEVEL: 0,
  /**
   * Default resolution / device pixel ratio of the renderer.
   *
   * @static
   * @name RESOLUTION
   * @memberof PIXI.settings
   * @type {number}
   * @default 1
   */
  RESOLUTION: 1,
  /**
   * Default filter resolution.
   *
   * @static
   * @name FILTER_RESOLUTION
   * @memberof PIXI.settings
   * @type {number}
   * @default 1
   */
  FILTER_RESOLUTION: 1,
  /**
   * The maximum textures that this device supports.
   *
   * @static
   * @name SPRITE_MAX_TEXTURES
   * @memberof PIXI.settings
   * @type {number}
   * @default 32
   */
  SPRITE_MAX_TEXTURES: maxRecommendedTextures(32),
  // TODO: maybe change to SPRITE.BATCH_SIZE: 2000
  // TODO: maybe add PARTICLE.BATCH_SIZE: 15000
  /**
   * The default sprite batch size.
   *
   * The default aims to balance desktop and mobile devices.
   *
   * @static
   * @name SPRITE_BATCH_SIZE
   * @memberof PIXI.settings
   * @type {number}
   * @default 4096
   */
  SPRITE_BATCH_SIZE: 4096,
  /**
   * The default render options if none are supplied to {@link PIXI.Renderer}
   * or {@link PIXI.CanvasRenderer}.
   *
   * @static
   * @name RENDER_OPTIONS
   * @memberof PIXI.settings
   * @type {object}
   * @property {HTMLCanvasElement} view=null
   * @property {number} resolution=1
   * @property {boolean} antialias=false
   * @property {boolean} autoDensity=false
   * @property {boolean} transparent=false
   * @property {number} backgroundColor=0x000000
   * @property {boolean} clearBeforeRender=true
   * @property {boolean} preserveDrawingBuffer=false
   * @property {number} width=800
   * @property {number} height=600
   * @property {boolean} legacy=false
   */
  RENDER_OPTIONS: {
    view: null,
    antialias: false,
    autoDensity: false,
    transparent: false,
    backgroundColor: 0,
    clearBeforeRender: true,
    preserveDrawingBuffer: false,
    width: 800,
    height: 600,
    legacy: false
  },
  /**
   * Default Garbage Collection mode.
   *
   * @static
   * @name GC_MODE
   * @memberof PIXI.settings
   * @type {PIXI.GC_MODES}
   * @default PIXI.GC_MODES.AUTO
   */
  GC_MODE: 0,
  /**
   * Default Garbage Collection max idle.
   *
   * @static
   * @name GC_MAX_IDLE
   * @memberof PIXI.settings
   * @type {number}
   * @default 3600
   */
  GC_MAX_IDLE: 60 * 60,
  /**
   * Default Garbage Collection maximum check count.
   *
   * @static
   * @name GC_MAX_CHECK_COUNT
   * @memberof PIXI.settings
   * @type {number}
   * @default 600
   */
  GC_MAX_CHECK_COUNT: 60 * 10,
  /**
   * Default wrap modes that are supported by pixi.
   *
   * @static
   * @name WRAP_MODE
   * @memberof PIXI.settings
   * @type {PIXI.WRAP_MODES}
   * @default PIXI.WRAP_MODES.CLAMP
   */
  WRAP_MODE: 33071,
  /**
   * Default scale mode for textures.
   *
   * @static
   * @name SCALE_MODE
   * @memberof PIXI.settings
   * @type {PIXI.SCALE_MODES}
   * @default PIXI.SCALE_MODES.LINEAR
   */
  SCALE_MODE: 1,
  /**
   * Default specify float precision in vertex shader.
   *
   * @static
   * @name PRECISION_VERTEX
   * @memberof PIXI.settings
   * @type {PIXI.PRECISION}
   * @default PIXI.PRECISION.HIGH
   */
  PRECISION_VERTEX: "highp",
  /**
   * Default specify float precision in fragment shader.
   * iOS is best set at highp due to https://github.com/pixijs/pixi.js/issues/3742
   *
   * @static
   * @name PRECISION_FRAGMENT
   * @memberof PIXI.settings
   * @type {PIXI.PRECISION}
   * @default PIXI.PRECISION.MEDIUM
   */
  PRECISION_FRAGMENT: isMobile2.apple.device ? "highp" : "mediump",
  /**
   * Can we upload the same buffer in a single frame?
   *
   * @static
   * @name CAN_UPLOAD_SAME_BUFFER
   * @memberof PIXI.settings
   * @type {boolean}
   */
  CAN_UPLOAD_SAME_BUFFER: canUploadSameBuffer(),
  /**
   * Enables bitmap creation before image load. This feature is experimental.
   *
   * @static
   * @name CREATE_IMAGE_BITMAP
   * @memberof PIXI.settings
   * @type {boolean}
   * @default false
   */
  CREATE_IMAGE_BITMAP: false,
  /**
   * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.
   * Advantages can include sharper image quality (like text) and faster rendering on canvas.
   * The main disadvantage is movement of objects may appear less smooth.
   *
   * @static
   * @constant
   * @memberof PIXI.settings
   * @type {boolean}
   * @default false
   */
  ROUND_PIXELS: false
};

// node_modules/@pixi/loaders/node_modules/@pixi/constants/lib/constants.es.js
var ENV;
(function(ENV3) {
  ENV3[ENV3["WEBGL_LEGACY"] = 0] = "WEBGL_LEGACY";
  ENV3[ENV3["WEBGL"] = 1] = "WEBGL";
  ENV3[ENV3["WEBGL2"] = 2] = "WEBGL2";
})(ENV || (ENV = {}));
var RENDERER_TYPE;
(function(RENDERER_TYPE3) {
  RENDERER_TYPE3[RENDERER_TYPE3["UNKNOWN"] = 0] = "UNKNOWN";
  RENDERER_TYPE3[RENDERER_TYPE3["WEBGL"] = 1] = "WEBGL";
  RENDERER_TYPE3[RENDERER_TYPE3["CANVAS"] = 2] = "CANVAS";
})(RENDERER_TYPE || (RENDERER_TYPE = {}));
var BUFFER_BITS;
(function(BUFFER_BITS3) {
  BUFFER_BITS3[BUFFER_BITS3["COLOR"] = 16384] = "COLOR";
  BUFFER_BITS3[BUFFER_BITS3["DEPTH"] = 256] = "DEPTH";
  BUFFER_BITS3[BUFFER_BITS3["STENCIL"] = 1024] = "STENCIL";
})(BUFFER_BITS || (BUFFER_BITS = {}));
var BLEND_MODES;
(function(BLEND_MODES3) {
  BLEND_MODES3[BLEND_MODES3["NORMAL"] = 0] = "NORMAL";
  BLEND_MODES3[BLEND_MODES3["ADD"] = 1] = "ADD";
  BLEND_MODES3[BLEND_MODES3["MULTIPLY"] = 2] = "MULTIPLY";
  BLEND_MODES3[BLEND_MODES3["SCREEN"] = 3] = "SCREEN";
  BLEND_MODES3[BLEND_MODES3["OVERLAY"] = 4] = "OVERLAY";
  BLEND_MODES3[BLEND_MODES3["DARKEN"] = 5] = "DARKEN";
  BLEND_MODES3[BLEND_MODES3["LIGHTEN"] = 6] = "LIGHTEN";
  BLEND_MODES3[BLEND_MODES3["COLOR_DODGE"] = 7] = "COLOR_DODGE";
  BLEND_MODES3[BLEND_MODES3["COLOR_BURN"] = 8] = "COLOR_BURN";
  BLEND_MODES3[BLEND_MODES3["HARD_LIGHT"] = 9] = "HARD_LIGHT";
  BLEND_MODES3[BLEND_MODES3["SOFT_LIGHT"] = 10] = "SOFT_LIGHT";
  BLEND_MODES3[BLEND_MODES3["DIFFERENCE"] = 11] = "DIFFERENCE";
  BLEND_MODES3[BLEND_MODES3["EXCLUSION"] = 12] = "EXCLUSION";
  BLEND_MODES3[BLEND_MODES3["HUE"] = 13] = "HUE";
  BLEND_MODES3[BLEND_MODES3["SATURATION"] = 14] = "SATURATION";
  BLEND_MODES3[BLEND_MODES3["COLOR"] = 15] = "COLOR";
  BLEND_MODES3[BLEND_MODES3["LUMINOSITY"] = 16] = "LUMINOSITY";
  BLEND_MODES3[BLEND_MODES3["NORMAL_NPM"] = 17] = "NORMAL_NPM";
  BLEND_MODES3[BLEND_MODES3["ADD_NPM"] = 18] = "ADD_NPM";
  BLEND_MODES3[BLEND_MODES3["SCREEN_NPM"] = 19] = "SCREEN_NPM";
  BLEND_MODES3[BLEND_MODES3["NONE"] = 20] = "NONE";
  BLEND_MODES3[BLEND_MODES3["SRC_OVER"] = 0] = "SRC_OVER";
  BLEND_MODES3[BLEND_MODES3["SRC_IN"] = 21] = "SRC_IN";
  BLEND_MODES3[BLEND_MODES3["SRC_OUT"] = 22] = "SRC_OUT";
  BLEND_MODES3[BLEND_MODES3["SRC_ATOP"] = 23] = "SRC_ATOP";
  BLEND_MODES3[BLEND_MODES3["DST_OVER"] = 24] = "DST_OVER";
  BLEND_MODES3[BLEND_MODES3["DST_IN"] = 25] = "DST_IN";
  BLEND_MODES3[BLEND_MODES3["DST_OUT"] = 26] = "DST_OUT";
  BLEND_MODES3[BLEND_MODES3["DST_ATOP"] = 27] = "DST_ATOP";
  BLEND_MODES3[BLEND_MODES3["ERASE"] = 26] = "ERASE";
  BLEND_MODES3[BLEND_MODES3["SUBTRACT"] = 28] = "SUBTRACT";
  BLEND_MODES3[BLEND_MODES3["XOR"] = 29] = "XOR";
})(BLEND_MODES || (BLEND_MODES = {}));
var DRAW_MODES;
(function(DRAW_MODES3) {
  DRAW_MODES3[DRAW_MODES3["POINTS"] = 0] = "POINTS";
  DRAW_MODES3[DRAW_MODES3["LINES"] = 1] = "LINES";
  DRAW_MODES3[DRAW_MODES3["LINE_LOOP"] = 2] = "LINE_LOOP";
  DRAW_MODES3[DRAW_MODES3["LINE_STRIP"] = 3] = "LINE_STRIP";
  DRAW_MODES3[DRAW_MODES3["TRIANGLES"] = 4] = "TRIANGLES";
  DRAW_MODES3[DRAW_MODES3["TRIANGLE_STRIP"] = 5] = "TRIANGLE_STRIP";
  DRAW_MODES3[DRAW_MODES3["TRIANGLE_FAN"] = 6] = "TRIANGLE_FAN";
})(DRAW_MODES || (DRAW_MODES = {}));
var FORMATS;
(function(FORMATS3) {
  FORMATS3[FORMATS3["RGBA"] = 6408] = "RGBA";
  FORMATS3[FORMATS3["RGB"] = 6407] = "RGB";
  FORMATS3[FORMATS3["ALPHA"] = 6406] = "ALPHA";
  FORMATS3[FORMATS3["LUMINANCE"] = 6409] = "LUMINANCE";
  FORMATS3[FORMATS3["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
  FORMATS3[FORMATS3["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
  FORMATS3[FORMATS3["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
})(FORMATS || (FORMATS = {}));
var TARGETS;
(function(TARGETS3) {
  TARGETS3[TARGETS3["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
  TARGETS3[TARGETS3["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
  TARGETS3[TARGETS3["TEXTURE_2D_ARRAY"] = 35866] = "TEXTURE_2D_ARRAY";
  TARGETS3[TARGETS3["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
  TARGETS3[TARGETS3["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
  TARGETS3[TARGETS3["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
  TARGETS3[TARGETS3["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
  TARGETS3[TARGETS3["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
  TARGETS3[TARGETS3["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
})(TARGETS || (TARGETS = {}));
var TYPES;
(function(TYPES3) {
  TYPES3[TYPES3["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
  TYPES3[TYPES3["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
  TYPES3[TYPES3["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
  TYPES3[TYPES3["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
  TYPES3[TYPES3["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
  TYPES3[TYPES3["FLOAT"] = 5126] = "FLOAT";
  TYPES3[TYPES3["HALF_FLOAT"] = 36193] = "HALF_FLOAT";
})(TYPES || (TYPES = {}));
var SCALE_MODES;
(function(SCALE_MODES3) {
  SCALE_MODES3[SCALE_MODES3["NEAREST"] = 0] = "NEAREST";
  SCALE_MODES3[SCALE_MODES3["LINEAR"] = 1] = "LINEAR";
})(SCALE_MODES || (SCALE_MODES = {}));
var WRAP_MODES;
(function(WRAP_MODES3) {
  WRAP_MODES3[WRAP_MODES3["CLAMP"] = 33071] = "CLAMP";
  WRAP_MODES3[WRAP_MODES3["REPEAT"] = 10497] = "REPEAT";
  WRAP_MODES3[WRAP_MODES3["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
})(WRAP_MODES || (WRAP_MODES = {}));
var MIPMAP_MODES;
(function(MIPMAP_MODES3) {
  MIPMAP_MODES3[MIPMAP_MODES3["OFF"] = 0] = "OFF";
  MIPMAP_MODES3[MIPMAP_MODES3["POW2"] = 1] = "POW2";
  MIPMAP_MODES3[MIPMAP_MODES3["ON"] = 2] = "ON";
})(MIPMAP_MODES || (MIPMAP_MODES = {}));
var ALPHA_MODES;
(function(ALPHA_MODES3) {
  ALPHA_MODES3[ALPHA_MODES3["NPM"] = 0] = "NPM";
  ALPHA_MODES3[ALPHA_MODES3["UNPACK"] = 1] = "UNPACK";
  ALPHA_MODES3[ALPHA_MODES3["PMA"] = 2] = "PMA";
  ALPHA_MODES3[ALPHA_MODES3["NO_PREMULTIPLIED_ALPHA"] = 0] = "NO_PREMULTIPLIED_ALPHA";
  ALPHA_MODES3[ALPHA_MODES3["PREMULTIPLY_ON_UPLOAD"] = 1] = "PREMULTIPLY_ON_UPLOAD";
  ALPHA_MODES3[ALPHA_MODES3["PREMULTIPLY_ALPHA"] = 2] = "PREMULTIPLY_ALPHA";
})(ALPHA_MODES || (ALPHA_MODES = {}));
var CLEAR_MODES;
(function(CLEAR_MODES3) {
  CLEAR_MODES3[CLEAR_MODES3["NO"] = 0] = "NO";
  CLEAR_MODES3[CLEAR_MODES3["YES"] = 1] = "YES";
  CLEAR_MODES3[CLEAR_MODES3["AUTO"] = 2] = "AUTO";
  CLEAR_MODES3[CLEAR_MODES3["BLEND"] = 0] = "BLEND";
  CLEAR_MODES3[CLEAR_MODES3["CLEAR"] = 1] = "CLEAR";
  CLEAR_MODES3[CLEAR_MODES3["BLIT"] = 2] = "BLIT";
})(CLEAR_MODES || (CLEAR_MODES = {}));
var GC_MODES;
(function(GC_MODES3) {
  GC_MODES3[GC_MODES3["AUTO"] = 0] = "AUTO";
  GC_MODES3[GC_MODES3["MANUAL"] = 1] = "MANUAL";
})(GC_MODES || (GC_MODES = {}));
var PRECISION;
(function(PRECISION3) {
  PRECISION3["LOW"] = "lowp";
  PRECISION3["MEDIUM"] = "mediump";
  PRECISION3["HIGH"] = "highp";
})(PRECISION || (PRECISION = {}));
var MASK_TYPES;
(function(MASK_TYPES3) {
  MASK_TYPES3[MASK_TYPES3["NONE"] = 0] = "NONE";
  MASK_TYPES3[MASK_TYPES3["SCISSOR"] = 1] = "SCISSOR";
  MASK_TYPES3[MASK_TYPES3["STENCIL"] = 2] = "STENCIL";
  MASK_TYPES3[MASK_TYPES3["SPRITE"] = 3] = "SPRITE";
})(MASK_TYPES || (MASK_TYPES = {}));
var MSAA_QUALITY;
(function(MSAA_QUALITY3) {
  MSAA_QUALITY3[MSAA_QUALITY3["NONE"] = 0] = "NONE";
  MSAA_QUALITY3[MSAA_QUALITY3["LOW"] = 2] = "LOW";
  MSAA_QUALITY3[MSAA_QUALITY3["MEDIUM"] = 4] = "MEDIUM";
  MSAA_QUALITY3[MSAA_QUALITY3["HIGH"] = 8] = "HIGH";
})(MSAA_QUALITY || (MSAA_QUALITY = {}));

// node_modules/@pixi/loaders/node_modules/@pixi/utils/lib/utils.es.js
var import_eventemitter3 = __toESM(require_eventemitter3());
var import_earcut = __toESM(require_earcut());
var import_url = __toESM(require_url());
var import_url2 = __toESM(require_url());
settings.RETINA_PREFIX = /@([0-9\.]+)x/;
settings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = true;
var saidHello = false;
var VERSION = "5.3.12";
function sayHello(type) {
  var _a;
  if (saidHello) {
    return;
  }
  if (navigator.userAgent.toLowerCase().indexOf("chrome") > -1) {
    var args = [
      "\n %c %c %c PixiJS " + VERSION + " - ✰ " + type + " ✰  %c  %c  http://www.pixijs.com/  %c %c ♥%c♥%c♥ \n\n",
      "background: #ff66a5; padding:5px 0;",
      "background: #ff66a5; padding:5px 0;",
      "color: #ff66a5; background: #030307; padding:5px 0;",
      "background: #ff66a5; padding:5px 0;",
      "background: #ffc3dc; padding:5px 0;",
      "background: #ff66a5; padding:5px 0;",
      "color: #ff2424; background: #fff; padding:5px 0;",
      "color: #ff2424; background: #fff; padding:5px 0;",
      "color: #ff2424; background: #fff; padding:5px 0;"
    ];
    (_a = window.console).log.apply(_a, args);
  } else if (window.console) {
    window.console.log("PixiJS " + VERSION + " - " + type + " - http://www.pixijs.com/");
  }
  saidHello = true;
}
var supported;
function isWebGLSupported() {
  if (typeof supported === "undefined") {
    supported = function supported3() {
      var contextOptions = {
        stencil: true,
        failIfMajorPerformanceCaveat: settings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT
      };
      try {
        if (!window.WebGLRenderingContext) {
          return false;
        }
        var canvas = document.createElement("canvas");
        var gl = canvas.getContext("webgl", contextOptions) || canvas.getContext("experimental-webgl", contextOptions);
        var success = !!(gl && gl.getContextAttributes().stencil);
        if (gl) {
          var loseContext = gl.getExtension("WEBGL_lose_context");
          if (loseContext) {
            loseContext.loseContext();
          }
        }
        gl = null;
        return success;
      } catch (e) {
        return false;
      }
    }();
  }
  return supported;
}
function hex2rgb(hex, out) {
  if (out === void 0) {
    out = [];
  }
  out[0] = (hex >> 16 & 255) / 255;
  out[1] = (hex >> 8 & 255) / 255;
  out[2] = (hex & 255) / 255;
  return out;
}
function hex2string(hex) {
  var hexString = hex.toString(16);
  hexString = "000000".substr(0, 6 - hexString.length) + hexString;
  return "#" + hexString;
}
function mapPremultipliedBlendModes() {
  var pm = [];
  var npm = [];
  for (var i = 0; i < 32; i++) {
    pm[i] = i;
    npm[i] = i;
  }
  pm[BLEND_MODES.NORMAL_NPM] = BLEND_MODES.NORMAL;
  pm[BLEND_MODES.ADD_NPM] = BLEND_MODES.ADD;
  pm[BLEND_MODES.SCREEN_NPM] = BLEND_MODES.SCREEN;
  npm[BLEND_MODES.NORMAL] = BLEND_MODES.NORMAL_NPM;
  npm[BLEND_MODES.ADD] = BLEND_MODES.ADD_NPM;
  npm[BLEND_MODES.SCREEN] = BLEND_MODES.SCREEN_NPM;
  var array = [];
  array.push(npm);
  array.push(pm);
  return array;
}
var premultiplyBlendMode = mapPremultipliedBlendModes();
function premultiplyTint(tint, alpha) {
  if (alpha === 1) {
    return (alpha * 255 << 24) + tint;
  }
  if (alpha === 0) {
    return 0;
  }
  var R2 = tint >> 16 & 255;
  var G2 = tint >> 8 & 255;
  var B2 = tint & 255;
  R2 = R2 * alpha + 0.5 | 0;
  G2 = G2 * alpha + 0.5 | 0;
  B2 = B2 * alpha + 0.5 | 0;
  return (alpha * 255 << 24) + (R2 << 16) + (G2 << 8) + B2;
}
function nextPow2(v2) {
  v2 += v2 === 0 ? 1 : 0;
  --v2;
  v2 |= v2 >>> 1;
  v2 |= v2 >>> 2;
  v2 |= v2 >>> 4;
  v2 |= v2 >>> 8;
  v2 |= v2 >>> 16;
  return v2 + 1;
}
function isPow2(v2) {
  return !(v2 & v2 - 1) && !!v2;
}
function log2(v2) {
  var r2 = (v2 > 65535 ? 1 : 0) << 4;
  v2 >>>= r2;
  var shift = (v2 > 255 ? 1 : 0) << 3;
  v2 >>>= shift;
  r2 |= shift;
  shift = (v2 > 15 ? 1 : 0) << 2;
  v2 >>>= shift;
  r2 |= shift;
  shift = (v2 > 3 ? 1 : 0) << 1;
  v2 >>>= shift;
  r2 |= shift;
  return r2 | v2 >> 1;
}
function removeItems(arr, startIdx, removeCount) {
  var length = arr.length;
  var i;
  if (startIdx >= length || removeCount === 0) {
    return;
  }
  removeCount = startIdx + removeCount > length ? length - startIdx : removeCount;
  var len = length - removeCount;
  for (i = startIdx; i < len; ++i) {
    arr[i] = arr[i + removeCount];
  }
  arr.length = len;
}
var nextUid = 0;
function uid() {
  return ++nextUid;
}
var warnings = {};
function deprecation(version, message, ignoreDepth) {
  if (ignoreDepth === void 0) {
    ignoreDepth = 3;
  }
  if (warnings[message]) {
    return;
  }
  var stack = new Error().stack;
  if (typeof stack === "undefined") {
    console.warn("PixiJS Deprecation Warning: ", message + "\nDeprecated since v" + version);
  } else {
    stack = stack.split("\n").splice(ignoreDepth).join("\n");
    if (console.groupCollapsed) {
      console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s", "color:#614108;background:#fffbe6", "font-weight:normal;color:#614108;background:#fffbe6", message + "\nDeprecated since v" + version);
      console.warn(stack);
      console.groupEnd();
    } else {
      console.warn("PixiJS Deprecation Warning: ", message + "\nDeprecated since v" + version);
      console.warn(stack);
    }
  }
  warnings[message] = true;
}
var ProgramCache = {};
var TextureCache = /* @__PURE__ */ Object.create(null);
var BaseTextureCache = /* @__PURE__ */ Object.create(null);
var CanvasRenderTarget = (
  /** @class */
  function() {
    function CanvasRenderTarget3(width, height, resolution) {
      this.canvas = document.createElement("canvas");
      this.context = this.canvas.getContext("2d");
      this.resolution = resolution || settings.RESOLUTION;
      this.resize(width, height);
    }
    CanvasRenderTarget3.prototype.clear = function() {
      this.context.setTransform(1, 0, 0, 1, 0, 0);
      this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    };
    CanvasRenderTarget3.prototype.resize = function(width, height) {
      this.canvas.width = width * this.resolution;
      this.canvas.height = height * this.resolution;
    };
    CanvasRenderTarget3.prototype.destroy = function() {
      this.context = null;
      this.canvas = null;
    };
    Object.defineProperty(CanvasRenderTarget3.prototype, "width", {
      /**
       * The width of the canvas buffer in pixels.
       *
       * @member {number}
       */
      get: function() {
        return this.canvas.width;
      },
      set: function(val) {
        this.canvas.width = val;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(CanvasRenderTarget3.prototype, "height", {
      /**
       * The height of the canvas buffer in pixels.
       *
       * @member {number}
       */
      get: function() {
        return this.canvas.height;
      },
      set: function(val) {
        this.canvas.height = val;
      },
      enumerable: false,
      configurable: true
    });
    return CanvasRenderTarget3;
  }()
);
var tempAnchor2;
function determineCrossOrigin(url, loc) {
  if (loc === void 0) {
    loc = window.location;
  }
  if (url.indexOf("data:") === 0) {
    return "";
  }
  loc = loc || window.location;
  if (!tempAnchor2) {
    tempAnchor2 = document.createElement("a");
  }
  tempAnchor2.href = url;
  var parsedUrl = (0, import_url.parse)(tempAnchor2.href);
  var samePort = !parsedUrl.port && loc.port === "" || parsedUrl.port === loc.port;
  if (parsedUrl.hostname !== loc.hostname || !samePort || parsedUrl.protocol !== loc.protocol) {
    return "anonymous";
  }
  return "";
}
function getResolutionOfUrl(url, defaultValue3) {
  var resolution = settings.RETINA_PREFIX.exec(url);
  if (resolution) {
    return parseFloat(resolution[1]);
  }
  return defaultValue3 !== void 0 ? defaultValue3 : 1;
}

// node_modules/@pixi/loaders/node_modules/@pixi/runner/lib/runner.es.js
var Runner = (
  /** @class */
  function() {
    function Runner3(name) {
      this.items = [];
      this._name = name;
      this._aliasCount = 0;
    }
    Runner3.prototype.emit = function(a0, a1, a2, a3, a4, a5, a6, a7) {
      if (arguments.length > 8) {
        throw new Error("max arguments reached");
      }
      var _a = this, name = _a.name, items = _a.items;
      this._aliasCount++;
      for (var i = 0, len = items.length; i < len; i++) {
        items[i][name](a0, a1, a2, a3, a4, a5, a6, a7);
      }
      if (items === this.items) {
        this._aliasCount--;
      }
      return this;
    };
    Runner3.prototype.ensureNonAliasedItems = function() {
      if (this._aliasCount > 0 && this.items.length > 1) {
        this._aliasCount = 0;
        this.items = this.items.slice(0);
      }
    };
    Runner3.prototype.add = function(item) {
      if (item[this._name]) {
        this.ensureNonAliasedItems();
        this.remove(item);
        this.items.push(item);
      }
      return this;
    };
    Runner3.prototype.remove = function(item) {
      var index2 = this.items.indexOf(item);
      if (index2 !== -1) {
        this.ensureNonAliasedItems();
        this.items.splice(index2, 1);
      }
      return this;
    };
    Runner3.prototype.contains = function(item) {
      return this.items.indexOf(item) !== -1;
    };
    Runner3.prototype.removeAll = function() {
      this.ensureNonAliasedItems();
      this.items.length = 0;
      return this;
    };
    Runner3.prototype.destroy = function() {
      this.removeAll();
      this.items = null;
      this._name = null;
    };
    Object.defineProperty(Runner3.prototype, "empty", {
      /**
       * `true` if there are no this Runner contains no listeners
       *
       * @member {boolean}
       * @readonly
       */
      get: function() {
        return this.items.length === 0;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Runner3.prototype, "name", {
      /**
       * The name of the runner.
       *
       * @member {string}
       * @readonly
       */
      get: function() {
        return this._name;
      },
      enumerable: false,
      configurable: true
    });
    return Runner3;
  }()
);
Object.defineProperties(Runner.prototype, {
  /**
   * Alias for `emit`
   * @memberof PIXI.Runner#
   * @method dispatch
   * @see PIXI.Runner#emit
   */
  dispatch: { value: Runner.prototype.emit },
  /**
   * Alias for `emit`
   * @memberof PIXI.Runner#
   * @method run
   * @see PIXI.Runner#emit
   */
  run: { value: Runner.prototype.emit }
});

// node_modules/@pixi/loaders/node_modules/@pixi/ticker/lib/ticker.es.js
settings.TARGET_FPMS = 0.06;
var UPDATE_PRIORITY;
(function(UPDATE_PRIORITY3) {
  UPDATE_PRIORITY3[UPDATE_PRIORITY3["INTERACTION"] = 50] = "INTERACTION";
  UPDATE_PRIORITY3[UPDATE_PRIORITY3["HIGH"] = 25] = "HIGH";
  UPDATE_PRIORITY3[UPDATE_PRIORITY3["NORMAL"] = 0] = "NORMAL";
  UPDATE_PRIORITY3[UPDATE_PRIORITY3["LOW"] = -25] = "LOW";
  UPDATE_PRIORITY3[UPDATE_PRIORITY3["UTILITY"] = -50] = "UTILITY";
})(UPDATE_PRIORITY || (UPDATE_PRIORITY = {}));
var TickerListener = (
  /** @class */
  function() {
    function TickerListener3(fn, context3, priority, once) {
      if (context3 === void 0) {
        context3 = null;
      }
      if (priority === void 0) {
        priority = 0;
      }
      if (once === void 0) {
        once = false;
      }
      this.fn = fn;
      this.context = context3;
      this.priority = priority;
      this.once = once;
      this.next = null;
      this.previous = null;
      this._destroyed = false;
    }
    TickerListener3.prototype.match = function(fn, context3) {
      if (context3 === void 0) {
        context3 = null;
      }
      return this.fn === fn && this.context === context3;
    };
    TickerListener3.prototype.emit = function(deltaTime) {
      if (this.fn) {
        if (this.context) {
          this.fn.call(this.context, deltaTime);
        } else {
          this.fn(deltaTime);
        }
      }
      var redirect = this.next;
      if (this.once) {
        this.destroy(true);
      }
      if (this._destroyed) {
        this.next = null;
      }
      return redirect;
    };
    TickerListener3.prototype.connect = function(previous) {
      this.previous = previous;
      if (previous.next) {
        previous.next.previous = this;
      }
      this.next = previous.next;
      previous.next = this;
    };
    TickerListener3.prototype.destroy = function(hard) {
      if (hard === void 0) {
        hard = false;
      }
      this._destroyed = true;
      this.fn = null;
      this.context = null;
      if (this.previous) {
        this.previous.next = this.next;
      }
      if (this.next) {
        this.next.previous = this.previous;
      }
      var redirect = this.next;
      this.next = hard ? null : redirect;
      this.previous = null;
      return redirect;
    };
    return TickerListener3;
  }()
);
var Ticker = (
  /** @class */
  function() {
    function Ticker3() {
      var _this = this;
      this._head = new TickerListener(null, null, Infinity);
      this._requestId = null;
      this._maxElapsedMS = 100;
      this._minElapsedMS = 0;
      this.autoStart = false;
      this.deltaTime = 1;
      this.deltaMS = 1 / settings.TARGET_FPMS;
      this.elapsedMS = 1 / settings.TARGET_FPMS;
      this.lastTime = -1;
      this.speed = 1;
      this.started = false;
      this._protected = false;
      this._lastFrame = -1;
      this._tick = function(time) {
        _this._requestId = null;
        if (_this.started) {
          _this.update(time);
          if (_this.started && _this._requestId === null && _this._head.next) {
            _this._requestId = requestAnimationFrame(_this._tick);
          }
        }
      };
    }
    Ticker3.prototype._requestIfNeeded = function() {
      if (this._requestId === null && this._head.next) {
        this.lastTime = performance.now();
        this._lastFrame = this.lastTime;
        this._requestId = requestAnimationFrame(this._tick);
      }
    };
    Ticker3.prototype._cancelIfNeeded = function() {
      if (this._requestId !== null) {
        cancelAnimationFrame(this._requestId);
        this._requestId = null;
      }
    };
    Ticker3.prototype._startIfPossible = function() {
      if (this.started) {
        this._requestIfNeeded();
      } else if (this.autoStart) {
        this.start();
      }
    };
    Ticker3.prototype.add = function(fn, context3, priority) {
      if (priority === void 0) {
        priority = UPDATE_PRIORITY.NORMAL;
      }
      return this._addListener(new TickerListener(fn, context3, priority));
    };
    Ticker3.prototype.addOnce = function(fn, context3, priority) {
      if (priority === void 0) {
        priority = UPDATE_PRIORITY.NORMAL;
      }
      return this._addListener(new TickerListener(fn, context3, priority, true));
    };
    Ticker3.prototype._addListener = function(listener) {
      var current = this._head.next;
      var previous = this._head;
      if (!current) {
        listener.connect(previous);
      } else {
        while (current) {
          if (listener.priority > current.priority) {
            listener.connect(previous);
            break;
          }
          previous = current;
          current = current.next;
        }
        if (!listener.previous) {
          listener.connect(previous);
        }
      }
      this._startIfPossible();
      return this;
    };
    Ticker3.prototype.remove = function(fn, context3) {
      var listener = this._head.next;
      while (listener) {
        if (listener.match(fn, context3)) {
          listener = listener.destroy();
        } else {
          listener = listener.next;
        }
      }
      if (!this._head.next) {
        this._cancelIfNeeded();
      }
      return this;
    };
    Object.defineProperty(Ticker3.prototype, "count", {
      /**
       * The number of listeners on this ticker, calculated by walking through linked list
       *
       * @readonly
       * @member {number}
       */
      get: function() {
        if (!this._head) {
          return 0;
        }
        var count = 0;
        var current = this._head;
        while (current = current.next) {
          count++;
        }
        return count;
      },
      enumerable: false,
      configurable: true
    });
    Ticker3.prototype.start = function() {
      if (!this.started) {
        this.started = true;
        this._requestIfNeeded();
      }
    };
    Ticker3.prototype.stop = function() {
      if (this.started) {
        this.started = false;
        this._cancelIfNeeded();
      }
    };
    Ticker3.prototype.destroy = function() {
      if (!this._protected) {
        this.stop();
        var listener = this._head.next;
        while (listener) {
          listener = listener.destroy(true);
        }
        this._head.destroy();
        this._head = null;
      }
    };
    Ticker3.prototype.update = function(currentTime) {
      if (currentTime === void 0) {
        currentTime = performance.now();
      }
      var elapsedMS;
      if (currentTime > this.lastTime) {
        elapsedMS = this.elapsedMS = currentTime - this.lastTime;
        if (elapsedMS > this._maxElapsedMS) {
          elapsedMS = this._maxElapsedMS;
        }
        elapsedMS *= this.speed;
        if (this._minElapsedMS) {
          var delta = currentTime - this._lastFrame | 0;
          if (delta < this._minElapsedMS) {
            return;
          }
          this._lastFrame = currentTime - delta % this._minElapsedMS;
        }
        this.deltaMS = elapsedMS;
        this.deltaTime = this.deltaMS * settings.TARGET_FPMS;
        var head = this._head;
        var listener = head.next;
        while (listener) {
          listener = listener.emit(this.deltaTime);
        }
        if (!head.next) {
          this._cancelIfNeeded();
        }
      } else {
        this.deltaTime = this.deltaMS = this.elapsedMS = 0;
      }
      this.lastTime = currentTime;
    };
    Object.defineProperty(Ticker3.prototype, "FPS", {
      /**
       * The frames per second at which this ticker is running.
       * The default is approximately 60 in most modern browsers.
       * **Note:** This does not factor in the value of
       * {@link PIXI.Ticker#speed}, which is specific
       * to scaling {@link PIXI.Ticker#deltaTime}.
       *
       * @member {number}
       * @readonly
       */
      get: function() {
        return 1e3 / this.elapsedMS;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Ticker3.prototype, "minFPS", {
      /**
       * Manages the maximum amount of milliseconds allowed to
       * elapse between invoking {@link PIXI.Ticker#update}.
       * This value is used to cap {@link PIXI.Ticker#deltaTime},
       * but does not effect the measured value of {@link PIXI.Ticker#FPS}.
       * When setting this property it is clamped to a value between
       * `0` and `PIXI.settings.TARGET_FPMS * 1000`.
       *
       * @member {number}
       * @default 10
       */
      get: function() {
        return 1e3 / this._maxElapsedMS;
      },
      set: function(fps) {
        var minFPS = Math.min(this.maxFPS, fps);
        var minFPMS = Math.min(Math.max(0, minFPS) / 1e3, settings.TARGET_FPMS);
        this._maxElapsedMS = 1 / minFPMS;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Ticker3.prototype, "maxFPS", {
      /**
       * Manages the minimum amount of milliseconds required to
       * elapse between invoking {@link PIXI.Ticker#update}.
       * This will effect the measured value of {@link PIXI.Ticker#FPS}.
       * If it is set to `0`, then there is no limit; PixiJS will render as many frames as it can.
       * Otherwise it will be at least `minFPS`
       *
       * @member {number}
       * @default 0
       */
      get: function() {
        if (this._minElapsedMS) {
          return Math.round(1e3 / this._minElapsedMS);
        }
        return 0;
      },
      set: function(fps) {
        if (fps === 0) {
          this._minElapsedMS = 0;
        } else {
          var maxFPS = Math.max(this.minFPS, fps);
          this._minElapsedMS = 1 / (maxFPS / 1e3);
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Ticker3, "shared", {
      /**
       * The shared ticker instance used by {@link PIXI.AnimatedSprite} and by
       * {@link PIXI.VideoResource} to update animation frames / video textures.
       *
       * It may also be used by {@link PIXI.Application} if created with the `sharedTicker` option property set to true.
       *
       * The property {@link PIXI.Ticker#autoStart} is set to `true` for this instance.
       * Please follow the examples for usage, including how to opt-out of auto-starting the shared ticker.
       *
       * @example
       * let ticker = PIXI.Ticker.shared;
       * // Set this to prevent starting this ticker when listeners are added.
       * // By default this is true only for the PIXI.Ticker.shared instance.
       * ticker.autoStart = false;
       * // FYI, call this to ensure the ticker is stopped. It should be stopped
       * // if you have not attempted to render anything yet.
       * ticker.stop();
       * // Call this when you are ready for a running shared ticker.
       * ticker.start();
       *
       * @example
       * // You may use the shared ticker to render...
       * let renderer = PIXI.autoDetectRenderer();
       * let stage = new PIXI.Container();
       * document.body.appendChild(renderer.view);
       * ticker.add(function (time) {
       *     renderer.render(stage);
       * });
       *
       * @example
       * // Or you can just update it manually.
       * ticker.autoStart = false;
       * ticker.stop();
       * function animate(time) {
       *     ticker.update(time);
       *     renderer.render(stage);
       *     requestAnimationFrame(animate);
       * }
       * animate(performance.now());
       *
       * @member {PIXI.Ticker}
       * @static
       */
      get: function() {
        if (!Ticker3._shared) {
          var shared = Ticker3._shared = new Ticker3();
          shared.autoStart = true;
          shared._protected = true;
        }
        return Ticker3._shared;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Ticker3, "system", {
      /**
       * The system ticker instance used by {@link PIXI.InteractionManager} and by
       * {@link PIXI.BasePrepare} for core timing functionality that shouldn't usually need to be paused,
       * unlike the `shared` ticker which drives visual animations and rendering which may want to be paused.
       *
       * The property {@link PIXI.Ticker#autoStart} is set to `true` for this instance.
       *
       * @member {PIXI.Ticker}
       * @static
       */
      get: function() {
        if (!Ticker3._system) {
          var system = Ticker3._system = new Ticker3();
          system.autoStart = true;
          system._protected = true;
        }
        return Ticker3._system;
      },
      enumerable: false,
      configurable: true
    });
    return Ticker3;
  }()
);
var TickerPlugin = (
  /** @class */
  function() {
    function TickerPlugin3() {
    }
    TickerPlugin3.init = function(options) {
      var _this = this;
      options = Object.assign({
        autoStart: true,
        sharedTicker: false
      }, options);
      Object.defineProperty(this, "ticker", {
        set: function(ticker) {
          if (this._ticker) {
            this._ticker.remove(this.render, this);
          }
          this._ticker = ticker;
          if (ticker) {
            ticker.add(this.render, this, UPDATE_PRIORITY.LOW);
          }
        },
        get: function() {
          return this._ticker;
        }
      });
      this.stop = function() {
        _this._ticker.stop();
      };
      this.start = function() {
        _this._ticker.start();
      };
      this._ticker = null;
      this.ticker = options.sharedTicker ? Ticker.shared : new Ticker();
      if (options.autoStart) {
        this.start();
      }
    };
    TickerPlugin3.destroy = function() {
      if (this._ticker) {
        var oldTicker = this._ticker;
        this.ticker = null;
        oldTicker.destroy();
      }
    };
    return TickerPlugin3;
  }()
);

// node_modules/@pixi/loaders/node_modules/@pixi/math/lib/math.es.js
var PI_2 = Math.PI * 2;
var RAD_TO_DEG = 180 / Math.PI;
var DEG_TO_RAD = Math.PI / 180;
var SHAPES;
(function(SHAPES3) {
  SHAPES3[SHAPES3["POLY"] = 0] = "POLY";
  SHAPES3[SHAPES3["RECT"] = 1] = "RECT";
  SHAPES3[SHAPES3["CIRC"] = 2] = "CIRC";
  SHAPES3[SHAPES3["ELIP"] = 3] = "ELIP";
  SHAPES3[SHAPES3["RREC"] = 4] = "RREC";
})(SHAPES || (SHAPES = {}));
var Rectangle = (
  /** @class */
  function() {
    function Rectangle3(x2, y2, width, height) {
      if (x2 === void 0) {
        x2 = 0;
      }
      if (y2 === void 0) {
        y2 = 0;
      }
      if (width === void 0) {
        width = 0;
      }
      if (height === void 0) {
        height = 0;
      }
      this.x = Number(x2);
      this.y = Number(y2);
      this.width = Number(width);
      this.height = Number(height);
      this.type = SHAPES.RECT;
    }
    Object.defineProperty(Rectangle3.prototype, "left", {
      /**
       * returns the left edge of the rectangle
       *
       * @member {number}
       */
      get: function() {
        return this.x;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Rectangle3.prototype, "right", {
      /**
       * returns the right edge of the rectangle
       *
       * @member {number}
       */
      get: function() {
        return this.x + this.width;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Rectangle3.prototype, "top", {
      /**
       * returns the top edge of the rectangle
       *
       * @member {number}
       */
      get: function() {
        return this.y;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Rectangle3.prototype, "bottom", {
      /**
       * returns the bottom edge of the rectangle
       *
       * @member {number}
       */
      get: function() {
        return this.y + this.height;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Rectangle3, "EMPTY", {
      /**
       * A constant empty rectangle.
       *
       * @static
       * @constant
       * @member {PIXI.Rectangle}
       * @return {PIXI.Rectangle} An empty rectangle
       */
      get: function() {
        return new Rectangle3(0, 0, 0, 0);
      },
      enumerable: false,
      configurable: true
    });
    Rectangle3.prototype.clone = function() {
      return new Rectangle3(this.x, this.y, this.width, this.height);
    };
    Rectangle3.prototype.copyFrom = function(rectangle) {
      this.x = rectangle.x;
      this.y = rectangle.y;
      this.width = rectangle.width;
      this.height = rectangle.height;
      return this;
    };
    Rectangle3.prototype.copyTo = function(rectangle) {
      rectangle.x = this.x;
      rectangle.y = this.y;
      rectangle.width = this.width;
      rectangle.height = this.height;
      return rectangle;
    };
    Rectangle3.prototype.contains = function(x2, y2) {
      if (this.width <= 0 || this.height <= 0) {
        return false;
      }
      if (x2 >= this.x && x2 < this.x + this.width) {
        if (y2 >= this.y && y2 < this.y + this.height) {
          return true;
        }
      }
      return false;
    };
    Rectangle3.prototype.pad = function(paddingX, paddingY) {
      if (paddingX === void 0) {
        paddingX = 0;
      }
      if (paddingY === void 0) {
        paddingY = paddingX;
      }
      this.x -= paddingX;
      this.y -= paddingY;
      this.width += paddingX * 2;
      this.height += paddingY * 2;
      return this;
    };
    Rectangle3.prototype.fit = function(rectangle) {
      var x1 = Math.max(this.x, rectangle.x);
      var x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width);
      var y1 = Math.max(this.y, rectangle.y);
      var y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);
      this.x = x1;
      this.width = Math.max(x2 - x1, 0);
      this.y = y1;
      this.height = Math.max(y2 - y1, 0);
      return this;
    };
    Rectangle3.prototype.ceil = function(resolution, eps) {
      if (resolution === void 0) {
        resolution = 1;
      }
      if (eps === void 0) {
        eps = 1e-3;
      }
      var x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;
      var y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;
      this.x = Math.floor((this.x + eps) * resolution) / resolution;
      this.y = Math.floor((this.y + eps) * resolution) / resolution;
      this.width = x2 - this.x;
      this.height = y2 - this.y;
      return this;
    };
    Rectangle3.prototype.enlarge = function(rectangle) {
      var x1 = Math.min(this.x, rectangle.x);
      var x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);
      var y1 = Math.min(this.y, rectangle.y);
      var y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);
      this.x = x1;
      this.width = x2 - x1;
      this.y = y1;
      this.height = y2 - y1;
      return this;
    };
    return Rectangle3;
  }()
);
var Circle = (
  /** @class */
  function() {
    function Circle3(x2, y2, radius) {
      if (x2 === void 0) {
        x2 = 0;
      }
      if (y2 === void 0) {
        y2 = 0;
      }
      if (radius === void 0) {
        radius = 0;
      }
      this.x = x2;
      this.y = y2;
      this.radius = radius;
      this.type = SHAPES.CIRC;
    }
    Circle3.prototype.clone = function() {
      return new Circle3(this.x, this.y, this.radius);
    };
    Circle3.prototype.contains = function(x2, y2) {
      if (this.radius <= 0) {
        return false;
      }
      var r2 = this.radius * this.radius;
      var dx = this.x - x2;
      var dy = this.y - y2;
      dx *= dx;
      dy *= dy;
      return dx + dy <= r2;
    };
    Circle3.prototype.getBounds = function() {
      return new Rectangle(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
    };
    return Circle3;
  }()
);
var Ellipse = (
  /** @class */
  function() {
    function Ellipse3(x2, y2, halfWidth, halfHeight) {
      if (x2 === void 0) {
        x2 = 0;
      }
      if (y2 === void 0) {
        y2 = 0;
      }
      if (halfWidth === void 0) {
        halfWidth = 0;
      }
      if (halfHeight === void 0) {
        halfHeight = 0;
      }
      this.x = x2;
      this.y = y2;
      this.width = halfWidth;
      this.height = halfHeight;
      this.type = SHAPES.ELIP;
    }
    Ellipse3.prototype.clone = function() {
      return new Ellipse3(this.x, this.y, this.width, this.height);
    };
    Ellipse3.prototype.contains = function(x2, y2) {
      if (this.width <= 0 || this.height <= 0) {
        return false;
      }
      var normx = (x2 - this.x) / this.width;
      var normy = (y2 - this.y) / this.height;
      normx *= normx;
      normy *= normy;
      return normx + normy <= 1;
    };
    Ellipse3.prototype.getBounds = function() {
      return new Rectangle(this.x - this.width, this.y - this.height, this.width, this.height);
    };
    return Ellipse3;
  }()
);
var Polygon = (
  /** @class */
  function() {
    function Polygon3() {
      var arguments$1 = arguments;
      var points = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        points[_i] = arguments$1[_i];
      }
      var flat = Array.isArray(points[0]) ? points[0] : points;
      if (typeof flat[0] !== "number") {
        var p2 = [];
        for (var i = 0, il = flat.length; i < il; i++) {
          p2.push(flat[i].x, flat[i].y);
        }
        flat = p2;
      }
      this.points = flat;
      this.type = SHAPES.POLY;
      this.closeStroke = true;
    }
    Polygon3.prototype.clone = function() {
      var points = this.points.slice();
      var polygon = new Polygon3(points);
      polygon.closeStroke = this.closeStroke;
      return polygon;
    };
    Polygon3.prototype.contains = function(x2, y2) {
      var inside = false;
      var length = this.points.length / 2;
      for (var i = 0, j2 = length - 1; i < length; j2 = i++) {
        var xi = this.points[i * 2];
        var yi = this.points[i * 2 + 1];
        var xj = this.points[j2 * 2];
        var yj = this.points[j2 * 2 + 1];
        var intersect = yi > y2 !== yj > y2 && x2 < (xj - xi) * ((y2 - yi) / (yj - yi)) + xi;
        if (intersect) {
          inside = !inside;
        }
      }
      return inside;
    };
    return Polygon3;
  }()
);
var RoundedRectangle = (
  /** @class */
  function() {
    function RoundedRectangle3(x2, y2, width, height, radius) {
      if (x2 === void 0) {
        x2 = 0;
      }
      if (y2 === void 0) {
        y2 = 0;
      }
      if (width === void 0) {
        width = 0;
      }
      if (height === void 0) {
        height = 0;
      }
      if (radius === void 0) {
        radius = 20;
      }
      this.x = x2;
      this.y = y2;
      this.width = width;
      this.height = height;
      this.radius = radius;
      this.type = SHAPES.RREC;
    }
    RoundedRectangle3.prototype.clone = function() {
      return new RoundedRectangle3(this.x, this.y, this.width, this.height, this.radius);
    };
    RoundedRectangle3.prototype.contains = function(x2, y2) {
      if (this.width <= 0 || this.height <= 0) {
        return false;
      }
      if (x2 >= this.x && x2 <= this.x + this.width) {
        if (y2 >= this.y && y2 <= this.y + this.height) {
          if (y2 >= this.y + this.radius && y2 <= this.y + this.height - this.radius || x2 >= this.x + this.radius && x2 <= this.x + this.width - this.radius) {
            return true;
          }
          var dx = x2 - (this.x + this.radius);
          var dy = y2 - (this.y + this.radius);
          var radius2 = this.radius * this.radius;
          if (dx * dx + dy * dy <= radius2) {
            return true;
          }
          dx = x2 - (this.x + this.width - this.radius);
          if (dx * dx + dy * dy <= radius2) {
            return true;
          }
          dy = y2 - (this.y + this.height - this.radius);
          if (dx * dx + dy * dy <= radius2) {
            return true;
          }
          dx = x2 - (this.x + this.radius);
          if (dx * dx + dy * dy <= radius2) {
            return true;
          }
        }
      }
      return false;
    };
    return RoundedRectangle3;
  }()
);
var Point = (
  /** @class */
  function() {
    function Point3(x2, y2) {
      if (x2 === void 0) {
        x2 = 0;
      }
      if (y2 === void 0) {
        y2 = 0;
      }
      this.x = x2;
      this.y = y2;
    }
    Point3.prototype.clone = function() {
      return new Point3(this.x, this.y);
    };
    Point3.prototype.copyFrom = function(p2) {
      this.set(p2.x, p2.y);
      return this;
    };
    Point3.prototype.copyTo = function(p2) {
      p2.set(this.x, this.y);
      return p2;
    };
    Point3.prototype.equals = function(p2) {
      return p2.x === this.x && p2.y === this.y;
    };
    Point3.prototype.set = function(x2, y2) {
      if (x2 === void 0) {
        x2 = 0;
      }
      if (y2 === void 0) {
        y2 = x2;
      }
      this.x = x2;
      this.y = y2;
      return this;
    };
    return Point3;
  }()
);
var ObservablePoint = (
  /** @class */
  function() {
    function ObservablePoint3(cb, scope, x2, y2) {
      if (x2 === void 0) {
        x2 = 0;
      }
      if (y2 === void 0) {
        y2 = 0;
      }
      this._x = x2;
      this._y = y2;
      this.cb = cb;
      this.scope = scope;
    }
    ObservablePoint3.prototype.clone = function(cb, scope) {
      if (cb === void 0) {
        cb = this.cb;
      }
      if (scope === void 0) {
        scope = this.scope;
      }
      return new ObservablePoint3(cb, scope, this._x, this._y);
    };
    ObservablePoint3.prototype.set = function(x2, y2) {
      if (x2 === void 0) {
        x2 = 0;
      }
      if (y2 === void 0) {
        y2 = x2;
      }
      if (this._x !== x2 || this._y !== y2) {
        this._x = x2;
        this._y = y2;
        this.cb.call(this.scope);
      }
      return this;
    };
    ObservablePoint3.prototype.copyFrom = function(p2) {
      if (this._x !== p2.x || this._y !== p2.y) {
        this._x = p2.x;
        this._y = p2.y;
        this.cb.call(this.scope);
      }
      return this;
    };
    ObservablePoint3.prototype.copyTo = function(p2) {
      p2.set(this._x, this._y);
      return p2;
    };
    ObservablePoint3.prototype.equals = function(p2) {
      return p2.x === this._x && p2.y === this._y;
    };
    Object.defineProperty(ObservablePoint3.prototype, "x", {
      /**
       * The position of the displayObject on the x axis relative to the local coordinates of the parent.
       *
       * @member {number}
       */
      get: function() {
        return this._x;
      },
      set: function(value) {
        if (this._x !== value) {
          this._x = value;
          this.cb.call(this.scope);
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ObservablePoint3.prototype, "y", {
      /**
       * The position of the displayObject on the x axis relative to the local coordinates of the parent.
       *
       * @member {number}
       */
      get: function() {
        return this._y;
      },
      set: function(value) {
        if (this._y !== value) {
          this._y = value;
          this.cb.call(this.scope);
        }
      },
      enumerable: false,
      configurable: true
    });
    return ObservablePoint3;
  }()
);
var Matrix = (
  /** @class */
  function() {
    function Matrix3(a2, b2, c2, d2, tx, ty) {
      if (a2 === void 0) {
        a2 = 1;
      }
      if (b2 === void 0) {
        b2 = 0;
      }
      if (c2 === void 0) {
        c2 = 0;
      }
      if (d2 === void 0) {
        d2 = 1;
      }
      if (tx === void 0) {
        tx = 0;
      }
      if (ty === void 0) {
        ty = 0;
      }
      this.array = null;
      this.a = a2;
      this.b = b2;
      this.c = c2;
      this.d = d2;
      this.tx = tx;
      this.ty = ty;
    }
    Matrix3.prototype.fromArray = function(array) {
      this.a = array[0];
      this.b = array[1];
      this.c = array[3];
      this.d = array[4];
      this.tx = array[2];
      this.ty = array[5];
    };
    Matrix3.prototype.set = function(a2, b2, c2, d2, tx, ty) {
      this.a = a2;
      this.b = b2;
      this.c = c2;
      this.d = d2;
      this.tx = tx;
      this.ty = ty;
      return this;
    };
    Matrix3.prototype.toArray = function(transpose, out) {
      if (!this.array) {
        this.array = new Float32Array(9);
      }
      var array = out || this.array;
      if (transpose) {
        array[0] = this.a;
        array[1] = this.b;
        array[2] = 0;
        array[3] = this.c;
        array[4] = this.d;
        array[5] = 0;
        array[6] = this.tx;
        array[7] = this.ty;
        array[8] = 1;
      } else {
        array[0] = this.a;
        array[1] = this.c;
        array[2] = this.tx;
        array[3] = this.b;
        array[4] = this.d;
        array[5] = this.ty;
        array[6] = 0;
        array[7] = 0;
        array[8] = 1;
      }
      return array;
    };
    Matrix3.prototype.apply = function(pos, newPos) {
      newPos = newPos || new Point();
      var x2 = pos.x;
      var y2 = pos.y;
      newPos.x = this.a * x2 + this.c * y2 + this.tx;
      newPos.y = this.b * x2 + this.d * y2 + this.ty;
      return newPos;
    };
    Matrix3.prototype.applyInverse = function(pos, newPos) {
      newPos = newPos || new Point();
      var id = 1 / (this.a * this.d + this.c * -this.b);
      var x2 = pos.x;
      var y2 = pos.y;
      newPos.x = this.d * id * x2 + -this.c * id * y2 + (this.ty * this.c - this.tx * this.d) * id;
      newPos.y = this.a * id * y2 + -this.b * id * x2 + (-this.ty * this.a + this.tx * this.b) * id;
      return newPos;
    };
    Matrix3.prototype.translate = function(x2, y2) {
      this.tx += x2;
      this.ty += y2;
      return this;
    };
    Matrix3.prototype.scale = function(x2, y2) {
      this.a *= x2;
      this.d *= y2;
      this.c *= x2;
      this.b *= y2;
      this.tx *= x2;
      this.ty *= y2;
      return this;
    };
    Matrix3.prototype.rotate = function(angle) {
      var cos = Math.cos(angle);
      var sin = Math.sin(angle);
      var a1 = this.a;
      var c1 = this.c;
      var tx1 = this.tx;
      this.a = a1 * cos - this.b * sin;
      this.b = a1 * sin + this.b * cos;
      this.c = c1 * cos - this.d * sin;
      this.d = c1 * sin + this.d * cos;
      this.tx = tx1 * cos - this.ty * sin;
      this.ty = tx1 * sin + this.ty * cos;
      return this;
    };
    Matrix3.prototype.append = function(matrix) {
      var a1 = this.a;
      var b1 = this.b;
      var c1 = this.c;
      var d1 = this.d;
      this.a = matrix.a * a1 + matrix.b * c1;
      this.b = matrix.a * b1 + matrix.b * d1;
      this.c = matrix.c * a1 + matrix.d * c1;
      this.d = matrix.c * b1 + matrix.d * d1;
      this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx;
      this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty;
      return this;
    };
    Matrix3.prototype.setTransform = function(x2, y2, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {
      this.a = Math.cos(rotation + skewY) * scaleX;
      this.b = Math.sin(rotation + skewY) * scaleX;
      this.c = -Math.sin(rotation - skewX) * scaleY;
      this.d = Math.cos(rotation - skewX) * scaleY;
      this.tx = x2 - (pivotX * this.a + pivotY * this.c);
      this.ty = y2 - (pivotX * this.b + pivotY * this.d);
      return this;
    };
    Matrix3.prototype.prepend = function(matrix) {
      var tx1 = this.tx;
      if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {
        var a1 = this.a;
        var c1 = this.c;
        this.a = a1 * matrix.a + this.b * matrix.c;
        this.b = a1 * matrix.b + this.b * matrix.d;
        this.c = c1 * matrix.a + this.d * matrix.c;
        this.d = c1 * matrix.b + this.d * matrix.d;
      }
      this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx;
      this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty;
      return this;
    };
    Matrix3.prototype.decompose = function(transform) {
      var a2 = this.a;
      var b2 = this.b;
      var c2 = this.c;
      var d2 = this.d;
      var skewX = -Math.atan2(-c2, d2);
      var skewY = Math.atan2(b2, a2);
      var delta = Math.abs(skewX + skewY);
      if (delta < 1e-5 || Math.abs(PI_2 - delta) < 1e-5) {
        transform.rotation = skewY;
        transform.skew.x = transform.skew.y = 0;
      } else {
        transform.rotation = 0;
        transform.skew.x = skewX;
        transform.skew.y = skewY;
      }
      transform.scale.x = Math.sqrt(a2 * a2 + b2 * b2);
      transform.scale.y = Math.sqrt(c2 * c2 + d2 * d2);
      transform.position.x = this.tx;
      transform.position.y = this.ty;
      return transform;
    };
    Matrix3.prototype.invert = function() {
      var a1 = this.a;
      var b1 = this.b;
      var c1 = this.c;
      var d1 = this.d;
      var tx1 = this.tx;
      var n = a1 * d1 - b1 * c1;
      this.a = d1 / n;
      this.b = -b1 / n;
      this.c = -c1 / n;
      this.d = a1 / n;
      this.tx = (c1 * this.ty - d1 * tx1) / n;
      this.ty = -(a1 * this.ty - b1 * tx1) / n;
      return this;
    };
    Matrix3.prototype.identity = function() {
      this.a = 1;
      this.b = 0;
      this.c = 0;
      this.d = 1;
      this.tx = 0;
      this.ty = 0;
      return this;
    };
    Matrix3.prototype.clone = function() {
      var matrix = new Matrix3();
      matrix.a = this.a;
      matrix.b = this.b;
      matrix.c = this.c;
      matrix.d = this.d;
      matrix.tx = this.tx;
      matrix.ty = this.ty;
      return matrix;
    };
    Matrix3.prototype.copyTo = function(matrix) {
      matrix.a = this.a;
      matrix.b = this.b;
      matrix.c = this.c;
      matrix.d = this.d;
      matrix.tx = this.tx;
      matrix.ty = this.ty;
      return matrix;
    };
    Matrix3.prototype.copyFrom = function(matrix) {
      this.a = matrix.a;
      this.b = matrix.b;
      this.c = matrix.c;
      this.d = matrix.d;
      this.tx = matrix.tx;
      this.ty = matrix.ty;
      return this;
    };
    Object.defineProperty(Matrix3, "IDENTITY", {
      /**
       * A default (identity) matrix
       *
       * @static
       * @const
       * @member {PIXI.Matrix}
       */
      get: function() {
        return new Matrix3();
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Matrix3, "TEMP_MATRIX", {
      /**
       * A temp matrix
       *
       * @static
       * @const
       * @member {PIXI.Matrix}
       */
      get: function() {
        return new Matrix3();
      },
      enumerable: false,
      configurable: true
    });
    return Matrix3;
  }()
);
var ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1];
var uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];
var vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];
var vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];
var rotationCayley = [];
var rotationMatrices = [];
var signum = Math.sign;
function init() {
  for (var i = 0; i < 16; i++) {
    var row = [];
    rotationCayley.push(row);
    for (var j2 = 0; j2 < 16; j2++) {
      var _ux = signum(ux[i] * ux[j2] + vx[i] * uy[j2]);
      var _uy = signum(uy[i] * ux[j2] + vy[i] * uy[j2]);
      var _vx = signum(ux[i] * vx[j2] + vx[i] * vy[j2]);
      var _vy = signum(uy[i] * vx[j2] + vy[i] * vy[j2]);
      for (var k2 = 0; k2 < 16; k2++) {
        if (ux[k2] === _ux && uy[k2] === _uy && vx[k2] === _vx && vy[k2] === _vy) {
          row.push(k2);
          break;
        }
      }
    }
  }
  for (var i = 0; i < 16; i++) {
    var mat = new Matrix();
    mat.set(ux[i], uy[i], vx[i], vy[i], 0, 0);
    rotationMatrices.push(mat);
  }
}
init();
var groupD8 = {
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 0°       | East      |
   *
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  E: 0,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 45°↻     | Southeast |
   *
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  SE: 1,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 90°↻     | South     |
   *
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  S: 2,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 135°↻    | Southwest |
   *
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  SW: 3,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 180°     | West      |
   *
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  W: 4,
  /**
   * | Rotation    | Direction    |
   * |-------------|--------------|
   * | -135°/225°↻ | Northwest    |
   *
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  NW: 5,
  /**
   * | Rotation    | Direction    |
   * |-------------|--------------|
   * | -90°/270°↻  | North        |
   *
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  N: 6,
  /**
   * | Rotation    | Direction    |
   * |-------------|--------------|
   * | -45°/315°↻  | Northeast    |
   *
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  NE: 7,
  /**
   * Reflection about Y-axis.
   *
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  MIRROR_VERTICAL: 8,
  /**
   * Reflection about the main diagonal.
   *
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  MAIN_DIAGONAL: 10,
  /**
   * Reflection about X-axis.
   *
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  MIRROR_HORIZONTAL: 12,
  /**
   * Reflection about reverse diagonal.
   *
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  REVERSE_DIAGONAL: 14,
  /**
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
   * @return {PIXI.GD8Symmetry} The X-component of the U-axis
   *    after rotating the axes.
   */
  uX: function(ind) {
    return ux[ind];
  },
  /**
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
   * @return {PIXI.GD8Symmetry} The Y-component of the U-axis
   *    after rotating the axes.
   */
  uY: function(ind) {
    return uy[ind];
  },
  /**
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
   * @return {PIXI.GD8Symmetry} The X-component of the V-axis
   *    after rotating the axes.
   */
  vX: function(ind) {
    return vx[ind];
  },
  /**
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
   * @return {PIXI.GD8Symmetry} The Y-component of the V-axis
   *    after rotating the axes.
   */
  vY: function(ind) {
    return vy[ind];
  },
  /**
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} rotation - symmetry whose opposite
   *   is needed. Only rotations have opposite symmetries while
   *   reflections don't.
   * @return {PIXI.GD8Symmetry} The opposite symmetry of `rotation`
   */
  inv: function(rotation) {
    if (rotation & 8) {
      return rotation & 15;
    }
    return -rotation & 7;
  },
  /**
   * Composes the two D8 operations.
   *
   * Taking `^` as reflection:
   *
   * |       | E=0 | S=2 | W=4 | N=6 | E^=8 | S^=10 | W^=12 | N^=14 |
   * |-------|-----|-----|-----|-----|------|-------|-------|-------|
   * | E=0   | E   | S   | W   | N   | E^   | S^    | W^    | N^    |
   * | S=2   | S   | W   | N   | E   | S^   | W^    | N^    | E^    |
   * | W=4   | W   | N   | E   | S   | W^   | N^    | E^    | S^    |
   * | N=6   | N   | E   | S   | W   | N^   | E^    | S^    | W^    |
   * | E^=8  | E^  | N^  | W^  | S^  | E    | N     | W     | S     |
   * | S^=10 | S^  | E^  | N^  | W^  | S    | E     | N     | W     |
   * | W^=12 | W^  | S^  | E^  | N^  | W    | S     | E     | N     |
   * | N^=14 | N^  | W^  | S^  | E^  | N    | W     | S     | E     |
   *
   * [This is a Cayley table]{@link https://en.wikipedia.org/wiki/Cayley_table}
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} rotationSecond - Second operation, which
   *   is the row in the above cayley table.
   * @param {PIXI.GD8Symmetry} rotationFirst - First operation, which
   *   is the column in the above cayley table.
   * @return {PIXI.GD8Symmetry} Composed operation
   */
  add: function(rotationSecond, rotationFirst) {
    return rotationCayley[rotationSecond][rotationFirst];
  },
  /**
   * Reverse of `add`.
   *
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} rotationSecond - Second operation
   * @param {PIXI.GD8Symmetry} rotationFirst - First operation
   * @return {PIXI.GD8Symmetry} Result
   */
  sub: function(rotationSecond, rotationFirst) {
    return rotationCayley[rotationSecond][groupD8.inv(rotationFirst)];
  },
  /**
   * Adds 180 degrees to rotation, which is a commutative
   * operation.
   *
   * @memberof PIXI.groupD8
   * @param {number} rotation - The number to rotate.
   * @returns {number} Rotated number
   */
  rotate180: function(rotation) {
    return rotation ^ 4;
  },
  /**
   * Checks if the rotation angle is vertical, i.e. south
   * or north. It doesn't work for reflections.
   *
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} rotation - The number to check.
   * @returns {boolean} Whether or not the direction is vertical
   */
  isVertical: function(rotation) {
    return (rotation & 3) === 2;
  },
  /**
   * Approximates the vector `V(dx,dy)` into one of the
   * eight directions provided by `groupD8`.
   *
   * @memberof PIXI.groupD8
   * @param {number} dx - X-component of the vector
   * @param {number} dy - Y-component of the vector
   * @return {PIXI.GD8Symmetry} Approximation of the vector into
   *  one of the eight symmetries.
   */
  byDirection: function(dx, dy) {
    if (Math.abs(dx) * 2 <= Math.abs(dy)) {
      if (dy >= 0) {
        return groupD8.S;
      }
      return groupD8.N;
    } else if (Math.abs(dy) * 2 <= Math.abs(dx)) {
      if (dx > 0) {
        return groupD8.E;
      }
      return groupD8.W;
    } else if (dy > 0) {
      if (dx > 0) {
        return groupD8.SE;
      }
      return groupD8.SW;
    } else if (dx > 0) {
      return groupD8.NE;
    }
    return groupD8.NW;
  },
  /**
   * Helps sprite to compensate texture packer rotation.
   *
   * @memberof PIXI.groupD8
   * @param {PIXI.Matrix} matrix - sprite world matrix
   * @param {PIXI.GD8Symmetry} rotation - The rotation factor to use.
   * @param {number} tx - sprite anchoring
   * @param {number} ty - sprite anchoring
   */
  matrixAppendRotationInv: function(matrix, rotation, tx, ty) {
    if (tx === void 0) {
      tx = 0;
    }
    if (ty === void 0) {
      ty = 0;
    }
    var mat = rotationMatrices[groupD8.inv(rotation)];
    mat.tx = tx;
    mat.ty = ty;
    matrix.append(mat);
  }
};
var Transform = (
  /** @class */
  function() {
    function Transform3() {
      this.worldTransform = new Matrix();
      this.localTransform = new Matrix();
      this.position = new ObservablePoint(this.onChange, this, 0, 0);
      this.scale = new ObservablePoint(this.onChange, this, 1, 1);
      this.pivot = new ObservablePoint(this.onChange, this, 0, 0);
      this.skew = new ObservablePoint(this.updateSkew, this, 0, 0);
      this._rotation = 0;
      this._cx = 1;
      this._sx = 0;
      this._cy = 0;
      this._sy = 1;
      this._localID = 0;
      this._currentLocalID = 0;
      this._worldID = 0;
      this._parentID = 0;
    }
    Transform3.prototype.onChange = function() {
      this._localID++;
    };
    Transform3.prototype.updateSkew = function() {
      this._cx = Math.cos(this._rotation + this.skew.y);
      this._sx = Math.sin(this._rotation + this.skew.y);
      this._cy = -Math.sin(this._rotation - this.skew.x);
      this._sy = Math.cos(this._rotation - this.skew.x);
      this._localID++;
    };
    Transform3.prototype.updateLocalTransform = function() {
      var lt = this.localTransform;
      if (this._localID !== this._currentLocalID) {
        lt.a = this._cx * this.scale.x;
        lt.b = this._sx * this.scale.x;
        lt.c = this._cy * this.scale.y;
        lt.d = this._sy * this.scale.y;
        lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);
        lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d);
        this._currentLocalID = this._localID;
        this._parentID = -1;
      }
    };
    Transform3.prototype.updateTransform = function(parentTransform) {
      var lt = this.localTransform;
      if (this._localID !== this._currentLocalID) {
        lt.a = this._cx * this.scale.x;
        lt.b = this._sx * this.scale.x;
        lt.c = this._cy * this.scale.y;
        lt.d = this._sy * this.scale.y;
        lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);
        lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d);
        this._currentLocalID = this._localID;
        this._parentID = -1;
      }
      if (this._parentID !== parentTransform._worldID) {
        var pt = parentTransform.worldTransform;
        var wt = this.worldTransform;
        wt.a = lt.a * pt.a + lt.b * pt.c;
        wt.b = lt.a * pt.b + lt.b * pt.d;
        wt.c = lt.c * pt.a + lt.d * pt.c;
        wt.d = lt.c * pt.b + lt.d * pt.d;
        wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx;
        wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty;
        this._parentID = parentTransform._worldID;
        this._worldID++;
      }
    };
    Transform3.prototype.setFromMatrix = function(matrix) {
      matrix.decompose(this);
      this._localID++;
    };
    Object.defineProperty(Transform3.prototype, "rotation", {
      /**
       * The rotation of the object in radians.
       *
       * @member {number}
       */
      get: function() {
        return this._rotation;
      },
      set: function(value) {
        if (this._rotation !== value) {
          this._rotation = value;
          this.updateSkew();
        }
      },
      enumerable: false,
      configurable: true
    });
    Transform3.IDENTITY = new Transform3();
    return Transform3;
  }()
);

// node_modules/@pixi/loaders/node_modules/@pixi/core/lib/core.es.js
settings.PREFER_ENV = isMobile2.any ? ENV.WEBGL : ENV.WEBGL2;
settings.STRICT_TEXTURE_CACHE = false;
var INSTALLED = [];
function autoDetectResource(source, options) {
  if (!source) {
    return null;
  }
  var extension = "";
  if (typeof source === "string") {
    var result = /\.(\w{3,4})(?:$|\?|#)/i.exec(source);
    if (result) {
      extension = result[1].toLowerCase();
    }
  }
  for (var i = INSTALLED.length - 1; i >= 0; --i) {
    var ResourcePlugin = INSTALLED[i];
    if (ResourcePlugin.test && ResourcePlugin.test(source, extension)) {
      return new ResourcePlugin(source, options);
    }
  }
  throw new Error("Unrecognized source type to auto-detect Resource");
}
var extendStatics = function(d2, b2) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3) {
      if (b3.hasOwnProperty(p2)) {
        d3[p2] = b3[p2];
      }
    }
  };
  return extendStatics(d2, b2);
};
function __extends(d2, b2) {
  extendStatics(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var Resource2 = (
  /** @class */
  function() {
    function Resource4(width, height) {
      if (width === void 0) {
        width = 0;
      }
      if (height === void 0) {
        height = 0;
      }
      this._width = width;
      this._height = height;
      this.destroyed = false;
      this.internal = false;
      this.onResize = new Runner("setRealSize");
      this.onUpdate = new Runner("update");
      this.onError = new Runner("onError");
    }
    Resource4.prototype.bind = function(baseTexture) {
      this.onResize.add(baseTexture);
      this.onUpdate.add(baseTexture);
      this.onError.add(baseTexture);
      if (this._width || this._height) {
        this.onResize.emit(this._width, this._height);
      }
    };
    Resource4.prototype.unbind = function(baseTexture) {
      this.onResize.remove(baseTexture);
      this.onUpdate.remove(baseTexture);
      this.onError.remove(baseTexture);
    };
    Resource4.prototype.resize = function(width, height) {
      if (width !== this._width || height !== this._height) {
        this._width = width;
        this._height = height;
        this.onResize.emit(width, height);
      }
    };
    Object.defineProperty(Resource4.prototype, "valid", {
      /**
       * Has been validated
       * @readonly
       * @member {boolean}
       */
      get: function() {
        return !!this._width && !!this._height;
      },
      enumerable: false,
      configurable: true
    });
    Resource4.prototype.update = function() {
      if (!this.destroyed) {
        this.onUpdate.emit();
      }
    };
    Resource4.prototype.load = function() {
      return Promise.resolve(this);
    };
    Object.defineProperty(Resource4.prototype, "width", {
      /**
       * The width of the resource.
       *
       * @member {number}
       * @readonly
       */
      get: function() {
        return this._width;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Resource4.prototype, "height", {
      /**
       * The height of the resource.
       *
       * @member {number}
       * @readonly
       */
      get: function() {
        return this._height;
      },
      enumerable: false,
      configurable: true
    });
    Resource4.prototype.style = function(_renderer, _baseTexture, _glTexture) {
      return false;
    };
    Resource4.prototype.dispose = function() {
    };
    Resource4.prototype.destroy = function() {
      if (!this.destroyed) {
        this.destroyed = true;
        this.dispose();
        this.onError.removeAll();
        this.onError = null;
        this.onResize.removeAll();
        this.onResize = null;
        this.onUpdate.removeAll();
        this.onUpdate = null;
      }
    };
    Resource4.test = function(_source, _extension) {
      return false;
    };
    return Resource4;
  }()
);
var BufferResource = (
  /** @class */
  function(_super) {
    __extends(BufferResource3, _super);
    function BufferResource3(source, options) {
      var _this = this;
      var _a = options || {}, width = _a.width, height = _a.height;
      if (!width || !height) {
        throw new Error("BufferResource width or height invalid");
      }
      _this = _super.call(this, width, height) || this;
      _this.data = source;
      return _this;
    }
    BufferResource3.prototype.upload = function(renderer, baseTexture, glTexture) {
      var gl = renderer.gl;
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === ALPHA_MODES.UNPACK);
      if (glTexture.width === baseTexture.width && glTexture.height === baseTexture.height) {
        gl.texSubImage2D(baseTexture.target, 0, 0, 0, baseTexture.width, baseTexture.height, baseTexture.format, baseTexture.type, this.data);
      } else {
        glTexture.width = baseTexture.width;
        glTexture.height = baseTexture.height;
        gl.texImage2D(baseTexture.target, 0, glTexture.internalFormat, baseTexture.width, baseTexture.height, 0, baseTexture.format, glTexture.type, this.data);
      }
      return true;
    };
    BufferResource3.prototype.dispose = function() {
      this.data = null;
    };
    BufferResource3.test = function(source) {
      return source instanceof Float32Array || source instanceof Uint8Array || source instanceof Uint32Array;
    };
    return BufferResource3;
  }(Resource2)
);
var defaultBufferOptions = {
  scaleMode: SCALE_MODES.NEAREST,
  format: FORMATS.RGBA,
  alphaMode: ALPHA_MODES.NPM
};
var BaseTexture = (
  /** @class */
  function(_super) {
    __extends(BaseTexture3, _super);
    function BaseTexture3(resource, options) {
      if (resource === void 0) {
        resource = null;
      }
      if (options === void 0) {
        options = null;
      }
      var _this = _super.call(this) || this;
      options = options || {};
      var alphaMode = options.alphaMode, mipmap = options.mipmap, anisotropicLevel = options.anisotropicLevel, scaleMode = options.scaleMode, width = options.width, height = options.height, wrapMode = options.wrapMode, format = options.format, type = options.type, target = options.target, resolution = options.resolution, resourceOptions = options.resourceOptions;
      if (resource && !(resource instanceof Resource2)) {
        resource = autoDetectResource(resource, resourceOptions);
        resource.internal = true;
      }
      _this.width = width || 0;
      _this.height = height || 0;
      _this.resolution = resolution || settings.RESOLUTION;
      _this.mipmap = mipmap !== void 0 ? mipmap : settings.MIPMAP_TEXTURES;
      _this.anisotropicLevel = anisotropicLevel !== void 0 ? anisotropicLevel : settings.ANISOTROPIC_LEVEL;
      _this.wrapMode = wrapMode || settings.WRAP_MODE;
      _this.scaleMode = scaleMode !== void 0 ? scaleMode : settings.SCALE_MODE;
      _this.format = format || FORMATS.RGBA;
      _this.type = type || TYPES.UNSIGNED_BYTE;
      _this.target = target || TARGETS.TEXTURE_2D;
      _this.alphaMode = alphaMode !== void 0 ? alphaMode : ALPHA_MODES.UNPACK;
      if (options.premultiplyAlpha !== void 0) {
        _this.premultiplyAlpha = options.premultiplyAlpha;
      }
      _this.uid = uid();
      _this.touched = 0;
      _this.isPowerOfTwo = false;
      _this._refreshPOT();
      _this._glTextures = {};
      _this.dirtyId = 0;
      _this.dirtyStyleId = 0;
      _this.cacheId = null;
      _this.valid = width > 0 && height > 0;
      _this.textureCacheIds = [];
      _this.destroyed = false;
      _this.resource = null;
      _this._batchEnabled = 0;
      _this._batchLocation = 0;
      _this.parentTextureArray = null;
      _this.setResource(resource);
      return _this;
    }
    Object.defineProperty(BaseTexture3.prototype, "realWidth", {
      /**
       * Pixel width of the source of this texture
       *
       * @readonly
       * @member {number}
       */
      get: function() {
        return Math.ceil(this.width * this.resolution - 1e-4);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BaseTexture3.prototype, "realHeight", {
      /**
       * Pixel height of the source of this texture
       *
       * @readonly
       * @member {number}
       */
      get: function() {
        return Math.ceil(this.height * this.resolution - 1e-4);
      },
      enumerable: false,
      configurable: true
    });
    BaseTexture3.prototype.setStyle = function(scaleMode, mipmap) {
      var dirty;
      if (scaleMode !== void 0 && scaleMode !== this.scaleMode) {
        this.scaleMode = scaleMode;
        dirty = true;
      }
      if (mipmap !== void 0 && mipmap !== this.mipmap) {
        this.mipmap = mipmap;
        dirty = true;
      }
      if (dirty) {
        this.dirtyStyleId++;
      }
      return this;
    };
    BaseTexture3.prototype.setSize = function(width, height, resolution) {
      this.resolution = resolution || this.resolution;
      this.width = width;
      this.height = height;
      this._refreshPOT();
      this.update();
      return this;
    };
    BaseTexture3.prototype.setRealSize = function(realWidth, realHeight, resolution) {
      this.resolution = resolution || this.resolution;
      this.width = realWidth / this.resolution;
      this.height = realHeight / this.resolution;
      this._refreshPOT();
      this.update();
      return this;
    };
    BaseTexture3.prototype._refreshPOT = function() {
      this.isPowerOfTwo = isPow2(this.realWidth) && isPow2(this.realHeight);
    };
    BaseTexture3.prototype.setResolution = function(resolution) {
      var oldResolution = this.resolution;
      if (oldResolution === resolution) {
        return this;
      }
      this.resolution = resolution;
      if (this.valid) {
        this.width = this.width * oldResolution / resolution;
        this.height = this.height * oldResolution / resolution;
        this.emit("update", this);
      }
      this._refreshPOT();
      return this;
    };
    BaseTexture3.prototype.setResource = function(resource) {
      if (this.resource === resource) {
        return this;
      }
      if (this.resource) {
        throw new Error("Resource can be set only once");
      }
      resource.bind(this);
      this.resource = resource;
      return this;
    };
    BaseTexture3.prototype.update = function() {
      if (!this.valid) {
        if (this.width > 0 && this.height > 0) {
          this.valid = true;
          this.emit("loaded", this);
          this.emit("update", this);
        }
      } else {
        this.dirtyId++;
        this.dirtyStyleId++;
        this.emit("update", this);
      }
    };
    BaseTexture3.prototype.onError = function(event) {
      this.emit("error", this, event);
    };
    BaseTexture3.prototype.destroy = function() {
      if (this.resource) {
        this.resource.unbind(this);
        if (this.resource.internal) {
          this.resource.destroy();
        }
        this.resource = null;
      }
      if (this.cacheId) {
        delete BaseTextureCache[this.cacheId];
        delete TextureCache[this.cacheId];
        this.cacheId = null;
      }
      this.dispose();
      BaseTexture3.removeFromCache(this);
      this.textureCacheIds = null;
      this.destroyed = true;
    };
    BaseTexture3.prototype.dispose = function() {
      this.emit("dispose", this);
    };
    BaseTexture3.prototype.castToBaseTexture = function() {
      return this;
    };
    BaseTexture3.from = function(source, options, strict) {
      if (strict === void 0) {
        strict = settings.STRICT_TEXTURE_CACHE;
      }
      var isFrame = typeof source === "string";
      var cacheId = null;
      if (isFrame) {
        cacheId = source;
      } else {
        if (!source._pixiId) {
          source._pixiId = "pixiid_" + uid();
        }
        cacheId = source._pixiId;
      }
      var baseTexture = BaseTextureCache[cacheId];
      if (isFrame && strict && !baseTexture) {
        throw new Error('The cacheId "' + cacheId + '" does not exist in BaseTextureCache.');
      }
      if (!baseTexture) {
        baseTexture = new BaseTexture3(source, options);
        baseTexture.cacheId = cacheId;
        BaseTexture3.addToCache(baseTexture, cacheId);
      }
      return baseTexture;
    };
    BaseTexture3.fromBuffer = function(buffer, width, height, options) {
      buffer = buffer || new Float32Array(width * height * 4);
      var resource = new BufferResource(buffer, { width, height });
      var type = buffer instanceof Float32Array ? TYPES.FLOAT : TYPES.UNSIGNED_BYTE;
      return new BaseTexture3(resource, Object.assign(defaultBufferOptions, options || { width, height, type }));
    };
    BaseTexture3.addToCache = function(baseTexture, id) {
      if (id) {
        if (baseTexture.textureCacheIds.indexOf(id) === -1) {
          baseTexture.textureCacheIds.push(id);
        }
        if (BaseTextureCache[id]) {
          console.warn("BaseTexture added to the cache with an id [" + id + "] that already had an entry");
        }
        BaseTextureCache[id] = baseTexture;
      }
    };
    BaseTexture3.removeFromCache = function(baseTexture) {
      if (typeof baseTexture === "string") {
        var baseTextureFromCache = BaseTextureCache[baseTexture];
        if (baseTextureFromCache) {
          var index2 = baseTextureFromCache.textureCacheIds.indexOf(baseTexture);
          if (index2 > -1) {
            baseTextureFromCache.textureCacheIds.splice(index2, 1);
          }
          delete BaseTextureCache[baseTexture];
          return baseTextureFromCache;
        }
      } else if (baseTexture && baseTexture.textureCacheIds) {
        for (var i = 0; i < baseTexture.textureCacheIds.length; ++i) {
          delete BaseTextureCache[baseTexture.textureCacheIds[i]];
        }
        baseTexture.textureCacheIds.length = 0;
        return baseTexture;
      }
      return null;
    };
    BaseTexture3._globalBatch = 0;
    return BaseTexture3;
  }(import_eventemitter3.default)
);
var AbstractMultiResource = (
  /** @class */
  function(_super) {
    __extends(AbstractMultiResource3, _super);
    function AbstractMultiResource3(length, options) {
      var _this = this;
      var _a = options || {}, width = _a.width, height = _a.height;
      _this = _super.call(this, width, height) || this;
      _this.items = [];
      _this.itemDirtyIds = [];
      for (var i = 0; i < length; i++) {
        var partTexture = new BaseTexture();
        _this.items.push(partTexture);
        _this.itemDirtyIds.push(-2);
      }
      _this.length = length;
      _this._load = null;
      _this.baseTexture = null;
      return _this;
    }
    AbstractMultiResource3.prototype.initFromArray = function(resources, options) {
      for (var i = 0; i < this.length; i++) {
        if (!resources[i]) {
          continue;
        }
        if (resources[i].castToBaseTexture) {
          this.addBaseTextureAt(resources[i].castToBaseTexture(), i);
        } else if (resources[i] instanceof Resource2) {
          this.addResourceAt(resources[i], i);
        } else {
          this.addResourceAt(autoDetectResource(resources[i], options), i);
        }
      }
    };
    AbstractMultiResource3.prototype.dispose = function() {
      for (var i = 0, len = this.length; i < len; i++) {
        this.items[i].destroy();
      }
      this.items = null;
      this.itemDirtyIds = null;
      this._load = null;
    };
    AbstractMultiResource3.prototype.addResourceAt = function(resource, index2) {
      if (!this.items[index2]) {
        throw new Error("Index " + index2 + " is out of bounds");
      }
      if (resource.valid && !this.valid) {
        this.resize(resource.width, resource.height);
      }
      this.items[index2].setResource(resource);
      return this;
    };
    AbstractMultiResource3.prototype.bind = function(baseTexture) {
      if (this.baseTexture !== null) {
        throw new Error("Only one base texture per TextureArray is allowed");
      }
      _super.prototype.bind.call(this, baseTexture);
      for (var i = 0; i < this.length; i++) {
        this.items[i].parentTextureArray = baseTexture;
        this.items[i].on("update", baseTexture.update, baseTexture);
      }
    };
    AbstractMultiResource3.prototype.unbind = function(baseTexture) {
      _super.prototype.unbind.call(this, baseTexture);
      for (var i = 0; i < this.length; i++) {
        this.items[i].parentTextureArray = null;
        this.items[i].off("update", baseTexture.update, baseTexture);
      }
    };
    AbstractMultiResource3.prototype.load = function() {
      var _this = this;
      if (this._load) {
        return this._load;
      }
      var resources = this.items.map(function(item) {
        return item.resource;
      }).filter(function(item) {
        return item;
      });
      var promises = resources.map(function(item) {
        return item.load();
      });
      this._load = Promise.all(promises).then(function() {
        var _a = _this.items[0], realWidth = _a.realWidth, realHeight = _a.realHeight;
        _this.resize(realWidth, realHeight);
        return Promise.resolve(_this);
      });
      return this._load;
    };
    return AbstractMultiResource3;
  }(Resource2)
);
var ArrayResource = (
  /** @class */
  function(_super) {
    __extends(ArrayResource3, _super);
    function ArrayResource3(source, options) {
      var _this = this;
      var _a = options || {}, width = _a.width, height = _a.height;
      var urls;
      var length;
      if (Array.isArray(source)) {
        urls = source;
        length = source.length;
      } else {
        length = source;
      }
      _this = _super.call(this, length, { width, height }) || this;
      if (urls) {
        _this.initFromArray(urls, options);
      }
      return _this;
    }
    ArrayResource3.prototype.addBaseTextureAt = function(baseTexture, index2) {
      if (baseTexture.resource) {
        this.addResourceAt(baseTexture.resource, index2);
      } else {
        throw new Error("ArrayResource does not support RenderTexture");
      }
      return this;
    };
    ArrayResource3.prototype.bind = function(baseTexture) {
      _super.prototype.bind.call(this, baseTexture);
      baseTexture.target = TARGETS.TEXTURE_2D_ARRAY;
    };
    ArrayResource3.prototype.upload = function(renderer, texture, glTexture) {
      var _a = this, length = _a.length, itemDirtyIds = _a.itemDirtyIds, items = _a.items;
      var gl = renderer.gl;
      if (glTexture.dirtyId < 0) {
        gl.texImage3D(gl.TEXTURE_2D_ARRAY, 0, texture.format, this._width, this._height, length, 0, texture.format, texture.type, null);
      }
      for (var i = 0; i < length; i++) {
        var item = items[i];
        if (itemDirtyIds[i] < item.dirtyId) {
          itemDirtyIds[i] = item.dirtyId;
          if (item.valid) {
            gl.texSubImage3D(
              gl.TEXTURE_2D_ARRAY,
              0,
              0,
              // xoffset
              0,
              // yoffset
              i,
              // zoffset
              item.resource.width,
              item.resource.height,
              1,
              texture.format,
              texture.type,
              item.resource.source
            );
          }
        }
      }
      return true;
    };
    return ArrayResource3;
  }(AbstractMultiResource)
);
var BaseImageResource = (
  /** @class */
  function(_super) {
    __extends(BaseImageResource3, _super);
    function BaseImageResource3(source) {
      var _this = this;
      var sourceAny = source;
      var width = sourceAny.naturalWidth || sourceAny.videoWidth || sourceAny.width;
      var height = sourceAny.naturalHeight || sourceAny.videoHeight || sourceAny.height;
      _this = _super.call(this, width, height) || this;
      _this.source = source;
      _this.noSubImage = false;
      return _this;
    }
    BaseImageResource3.crossOrigin = function(element, url, crossorigin) {
      if (crossorigin === void 0 && url.indexOf("data:") !== 0) {
        element.crossOrigin = determineCrossOrigin(url);
      } else if (crossorigin !== false) {
        element.crossOrigin = typeof crossorigin === "string" ? crossorigin : "anonymous";
      }
    };
    BaseImageResource3.prototype.upload = function(renderer, baseTexture, glTexture, source) {
      var gl = renderer.gl;
      var width = baseTexture.realWidth;
      var height = baseTexture.realHeight;
      source = source || this.source;
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === ALPHA_MODES.UNPACK);
      if (!this.noSubImage && baseTexture.target === gl.TEXTURE_2D && glTexture.width === width && glTexture.height === height) {
        gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, baseTexture.format, baseTexture.type, source);
      } else {
        glTexture.width = width;
        glTexture.height = height;
        gl.texImage2D(baseTexture.target, 0, baseTexture.format, baseTexture.format, baseTexture.type, source);
      }
      return true;
    };
    BaseImageResource3.prototype.update = function() {
      if (this.destroyed) {
        return;
      }
      var source = this.source;
      var width = source.naturalWidth || source.videoWidth || source.width;
      var height = source.naturalHeight || source.videoHeight || source.height;
      this.resize(width, height);
      _super.prototype.update.call(this);
    };
    BaseImageResource3.prototype.dispose = function() {
      this.source = null;
    };
    return BaseImageResource3;
  }(Resource2)
);
var CanvasResource = (
  /** @class */
  function(_super) {
    __extends(CanvasResource3, _super);
    function CanvasResource3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    CanvasResource3.test = function(source) {
      var OffscreenCanvas = window.OffscreenCanvas;
      if (OffscreenCanvas && source instanceof OffscreenCanvas) {
        return true;
      }
      return source instanceof HTMLCanvasElement;
    };
    return CanvasResource3;
  }(BaseImageResource)
);
var CubeResource = (
  /** @class */
  function(_super) {
    __extends(CubeResource3, _super);
    function CubeResource3(source, options) {
      var _this = this;
      var _a = options || {}, width = _a.width, height = _a.height, autoLoad = _a.autoLoad, linkBaseTexture = _a.linkBaseTexture;
      if (source && source.length !== CubeResource3.SIDES) {
        throw new Error("Invalid length. Got " + source.length + ", expected 6");
      }
      _this = _super.call(this, 6, { width, height }) || this;
      for (var i = 0; i < CubeResource3.SIDES; i++) {
        _this.items[i].target = TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + i;
      }
      _this.linkBaseTexture = linkBaseTexture !== false;
      if (source) {
        _this.initFromArray(source, options);
      }
      if (autoLoad !== false) {
        _this.load();
      }
      return _this;
    }
    CubeResource3.prototype.bind = function(baseTexture) {
      _super.prototype.bind.call(this, baseTexture);
      baseTexture.target = TARGETS.TEXTURE_CUBE_MAP;
    };
    CubeResource3.prototype.addBaseTextureAt = function(baseTexture, index2, linkBaseTexture) {
      if (linkBaseTexture === void 0) {
        linkBaseTexture = this.linkBaseTexture;
      }
      if (!this.items[index2]) {
        throw new Error("Index " + index2 + " is out of bounds");
      }
      if (!this.linkBaseTexture || baseTexture.parentTextureArray || Object.keys(baseTexture._glTextures).length > 0) {
        if (baseTexture.resource) {
          this.addResourceAt(baseTexture.resource, index2);
        } else {
          throw new Error("CubeResource does not support copying of renderTexture.");
        }
      } else {
        baseTexture.target = TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + index2;
        baseTexture.parentTextureArray = this.baseTexture;
        this.items[index2] = baseTexture;
      }
      if (baseTexture.valid && !this.valid) {
        this.resize(baseTexture.realWidth, baseTexture.realHeight);
      }
      this.items[index2] = baseTexture;
      return this;
    };
    CubeResource3.prototype.upload = function(renderer, _baseTexture, glTexture) {
      var dirty = this.itemDirtyIds;
      for (var i = 0; i < CubeResource3.SIDES; i++) {
        var side = this.items[i];
        if (dirty[i] < side.dirtyId) {
          if (side.valid && side.resource) {
            side.resource.upload(renderer, side, glTexture);
            dirty[i] = side.dirtyId;
          } else if (dirty[i] < -1) {
            renderer.gl.texImage2D(side.target, 0, glTexture.internalFormat, _baseTexture.realWidth, _baseTexture.realHeight, 0, _baseTexture.format, glTexture.type, null);
            dirty[i] = -1;
          }
        }
      }
      return true;
    };
    CubeResource3.test = function(source) {
      return Array.isArray(source) && source.length === CubeResource3.SIDES;
    };
    CubeResource3.SIDES = 6;
    return CubeResource3;
  }(AbstractMultiResource)
);
var ImageResource = (
  /** @class */
  function(_super) {
    __extends(ImageResource3, _super);
    function ImageResource3(source, options) {
      var _this = this;
      options = options || {};
      if (!(source instanceof HTMLImageElement)) {
        var imageElement = new Image();
        BaseImageResource.crossOrigin(imageElement, source, options.crossorigin);
        imageElement.src = source;
        source = imageElement;
      }
      _this = _super.call(this, source) || this;
      if (!source.complete && !!_this._width && !!_this._height) {
        _this._width = 0;
        _this._height = 0;
      }
      _this.url = source.src;
      _this._process = null;
      _this.preserveBitmap = false;
      _this.createBitmap = (options.createBitmap !== void 0 ? options.createBitmap : settings.CREATE_IMAGE_BITMAP) && !!window.createImageBitmap;
      _this.alphaMode = typeof options.alphaMode === "number" ? options.alphaMode : null;
      if (options.premultiplyAlpha !== void 0) {
        _this.premultiplyAlpha = options.premultiplyAlpha;
      }
      _this.bitmap = null;
      _this._load = null;
      if (options.autoLoad !== false) {
        _this.load();
      }
      return _this;
    }
    ImageResource3.prototype.load = function(createBitmap) {
      var _this = this;
      if (this._load) {
        return this._load;
      }
      if (createBitmap !== void 0) {
        this.createBitmap = createBitmap;
      }
      this._load = new Promise(function(resolve, reject) {
        var source = _this.source;
        _this.url = source.src;
        var completed = function() {
          if (_this.destroyed) {
            return;
          }
          source.onload = null;
          source.onerror = null;
          _this.resize(source.width, source.height);
          _this._load = null;
          if (_this.createBitmap) {
            resolve(_this.process());
          } else {
            resolve(_this);
          }
        };
        if (source.complete && source.src) {
          completed();
        } else {
          source.onload = completed;
          source.onerror = function(event) {
            reject(event);
            _this.onError.emit(event);
          };
        }
      });
      return this._load;
    };
    ImageResource3.prototype.process = function() {
      var _this = this;
      var source = this.source;
      if (this._process !== null) {
        return this._process;
      }
      if (this.bitmap !== null || !window.createImageBitmap) {
        return Promise.resolve(this);
      }
      this._process = window.createImageBitmap(source, 0, 0, source.width, source.height, {
        premultiplyAlpha: this.alphaMode === ALPHA_MODES.UNPACK ? "premultiply" : "none"
      }).then(function(bitmap) {
        if (_this.destroyed) {
          return Promise.reject();
        }
        _this.bitmap = bitmap;
        _this.update();
        _this._process = null;
        return Promise.resolve(_this);
      });
      return this._process;
    };
    ImageResource3.prototype.upload = function(renderer, baseTexture, glTexture) {
      if (typeof this.alphaMode === "number") {
        baseTexture.alphaMode = this.alphaMode;
      }
      if (!this.createBitmap) {
        return _super.prototype.upload.call(this, renderer, baseTexture, glTexture);
      }
      if (!this.bitmap) {
        this.process();
        if (!this.bitmap) {
          return false;
        }
      }
      _super.prototype.upload.call(this, renderer, baseTexture, glTexture, this.bitmap);
      if (!this.preserveBitmap) {
        var flag = true;
        var glTextures = baseTexture._glTextures;
        for (var key in glTextures) {
          var otherTex = glTextures[key];
          if (otherTex !== glTexture && otherTex.dirtyId !== baseTexture.dirtyId) {
            flag = false;
            break;
          }
        }
        if (flag) {
          if (this.bitmap.close) {
            this.bitmap.close();
          }
          this.bitmap = null;
        }
      }
      return true;
    };
    ImageResource3.prototype.dispose = function() {
      this.source.onload = null;
      this.source.onerror = null;
      _super.prototype.dispose.call(this);
      if (this.bitmap) {
        this.bitmap.close();
        this.bitmap = null;
      }
      this._process = null;
      this._load = null;
    };
    ImageResource3.test = function(source) {
      return typeof source === "string" || source instanceof HTMLImageElement;
    };
    return ImageResource3;
  }(BaseImageResource)
);
var SVGResource = (
  /** @class */
  function(_super) {
    __extends(SVGResource3, _super);
    function SVGResource3(sourceBase64, options) {
      var _this = this;
      options = options || {};
      _this = _super.call(this, document.createElement("canvas")) || this;
      _this._width = 0;
      _this._height = 0;
      _this.svg = sourceBase64;
      _this.scale = options.scale || 1;
      _this._overrideWidth = options.width;
      _this._overrideHeight = options.height;
      _this._resolve = null;
      _this._crossorigin = options.crossorigin;
      _this._load = null;
      if (options.autoLoad !== false) {
        _this.load();
      }
      return _this;
    }
    SVGResource3.prototype.load = function() {
      var _this = this;
      if (this._load) {
        return this._load;
      }
      this._load = new Promise(function(resolve) {
        _this._resolve = function() {
          _this.resize(_this.source.width, _this.source.height);
          resolve(_this);
        };
        if (/^\<svg/.test(_this.svg.trim())) {
          if (!btoa) {
            throw new Error("Your browser doesn't support base64 conversions.");
          }
          _this.svg = "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(_this.svg)));
        }
        _this._loadSvg();
      });
      return this._load;
    };
    SVGResource3.prototype._loadSvg = function() {
      var _this = this;
      var tempImage = new Image();
      BaseImageResource.crossOrigin(tempImage, this.svg, this._crossorigin);
      tempImage.src = this.svg;
      tempImage.onerror = function(event) {
        if (!_this._resolve) {
          return;
        }
        tempImage.onerror = null;
        _this.onError.emit(event);
      };
      tempImage.onload = function() {
        if (!_this._resolve) {
          return;
        }
        var svgWidth = tempImage.width;
        var svgHeight = tempImage.height;
        if (!svgWidth || !svgHeight) {
          throw new Error("The SVG image must have width and height defined (in pixels), canvas API needs them.");
        }
        var width = svgWidth * _this.scale;
        var height = svgHeight * _this.scale;
        if (_this._overrideWidth || _this._overrideHeight) {
          width = _this._overrideWidth || _this._overrideHeight / svgHeight * svgWidth;
          height = _this._overrideHeight || _this._overrideWidth / svgWidth * svgHeight;
        }
        width = Math.round(width);
        height = Math.round(height);
        var canvas = _this.source;
        canvas.width = width;
        canvas.height = height;
        canvas._pixiId = "canvas_" + uid();
        canvas.getContext("2d").drawImage(tempImage, 0, 0, svgWidth, svgHeight, 0, 0, width, height);
        _this._resolve();
        _this._resolve = null;
      };
    };
    SVGResource3.getSize = function(svgString) {
      var sizeMatch = SVGResource3.SVG_SIZE.exec(svgString);
      var size = {};
      if (sizeMatch) {
        size[sizeMatch[1]] = Math.round(parseFloat(sizeMatch[3]));
        size[sizeMatch[5]] = Math.round(parseFloat(sizeMatch[7]));
      }
      return size;
    };
    SVGResource3.prototype.dispose = function() {
      _super.prototype.dispose.call(this);
      this._resolve = null;
      this._crossorigin = null;
    };
    SVGResource3.test = function(source, extension) {
      return extension === "svg" || typeof source === "string" && /^data:image\/svg\+xml(;(charset=utf8|utf8))?;base64/.test(source) || typeof source === "string" && source.indexOf("<svg") === 0;
    };
    SVGResource3.SVG_SIZE = /<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i;
    return SVGResource3;
  }(BaseImageResource)
);
var VideoResource = (
  /** @class */
  function(_super) {
    __extends(VideoResource3, _super);
    function VideoResource3(source, options) {
      var _this = this;
      options = options || {};
      if (!(source instanceof HTMLVideoElement)) {
        var videoElement = document.createElement("video");
        videoElement.setAttribute("preload", "auto");
        videoElement.setAttribute("webkit-playsinline", "");
        videoElement.setAttribute("playsinline", "");
        if (typeof source === "string") {
          source = [source];
        }
        var firstSrc = source[0].src || source[0];
        BaseImageResource.crossOrigin(videoElement, firstSrc, options.crossorigin);
        for (var i = 0; i < source.length; ++i) {
          var sourceElement = document.createElement("source");
          var _a = source[i], src = _a.src, mime = _a.mime;
          src = src || source[i];
          var baseSrc = src.split("?").shift().toLowerCase();
          var ext = baseSrc.substr(baseSrc.lastIndexOf(".") + 1);
          mime = mime || VideoResource3.MIME_TYPES[ext] || "video/" + ext;
          sourceElement.src = src;
          sourceElement.type = mime;
          videoElement.appendChild(sourceElement);
        }
        source = videoElement;
      }
      _this = _super.call(this, source) || this;
      _this.noSubImage = true;
      _this._autoUpdate = true;
      _this._isConnectedToTicker = false;
      _this._updateFPS = options.updateFPS || 0;
      _this._msToNextUpdate = 0;
      _this.autoPlay = options.autoPlay !== false;
      _this._load = null;
      _this._resolve = null;
      _this._onCanPlay = _this._onCanPlay.bind(_this);
      _this._onError = _this._onError.bind(_this);
      if (options.autoLoad !== false) {
        _this.load();
      }
      return _this;
    }
    VideoResource3.prototype.update = function(_deltaTime) {
      if (_deltaTime === void 0) {
        _deltaTime = 0;
      }
      if (!this.destroyed) {
        var elapsedMS = Ticker.shared.elapsedMS * this.source.playbackRate;
        this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);
        if (!this._updateFPS || this._msToNextUpdate <= 0) {
          _super.prototype.update.call(this);
          this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0;
        }
      }
    };
    VideoResource3.prototype.load = function() {
      var _this = this;
      if (this._load) {
        return this._load;
      }
      var source = this.source;
      if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA) && source.width && source.height) {
        source.complete = true;
      }
      source.addEventListener("play", this._onPlayStart.bind(this));
      source.addEventListener("pause", this._onPlayStop.bind(this));
      if (!this._isSourceReady()) {
        source.addEventListener("canplay", this._onCanPlay);
        source.addEventListener("canplaythrough", this._onCanPlay);
        source.addEventListener("error", this._onError, true);
      } else {
        this._onCanPlay();
      }
      this._load = new Promise(function(resolve) {
        if (_this.valid) {
          resolve(_this);
        } else {
          _this._resolve = resolve;
          source.load();
        }
      });
      return this._load;
    };
    VideoResource3.prototype._onError = function(event) {
      this.source.removeEventListener("error", this._onError, true);
      this.onError.emit(event);
    };
    VideoResource3.prototype._isSourcePlaying = function() {
      var source = this.source;
      return source.currentTime > 0 && source.paused === false && source.ended === false && source.readyState > 2;
    };
    VideoResource3.prototype._isSourceReady = function() {
      var source = this.source;
      return source.readyState === 3 || source.readyState === 4;
    };
    VideoResource3.prototype._onPlayStart = function() {
      if (!this.valid) {
        this._onCanPlay();
      }
      if (this.autoUpdate && !this._isConnectedToTicker) {
        Ticker.shared.add(this.update, this);
        this._isConnectedToTicker = true;
      }
    };
    VideoResource3.prototype._onPlayStop = function() {
      if (this._isConnectedToTicker) {
        Ticker.shared.remove(this.update, this);
        this._isConnectedToTicker = false;
      }
    };
    VideoResource3.prototype._onCanPlay = function() {
      var source = this.source;
      source.removeEventListener("canplay", this._onCanPlay);
      source.removeEventListener("canplaythrough", this._onCanPlay);
      var valid = this.valid;
      this.resize(source.videoWidth, source.videoHeight);
      if (!valid && this._resolve) {
        this._resolve(this);
        this._resolve = null;
      }
      if (this._isSourcePlaying()) {
        this._onPlayStart();
      } else if (this.autoPlay) {
        source.play();
      }
    };
    VideoResource3.prototype.dispose = function() {
      if (this._isConnectedToTicker) {
        Ticker.shared.remove(this.update, this);
      }
      var source = this.source;
      if (source) {
        source.removeEventListener("error", this._onError, true);
        source.pause();
        source.src = "";
        source.load();
      }
      _super.prototype.dispose.call(this);
    };
    Object.defineProperty(VideoResource3.prototype, "autoUpdate", {
      /**
       * Should the base texture automatically update itself, set to true by default
       *
       * @member {boolean}
       */
      get: function() {
        return this._autoUpdate;
      },
      set: function(value) {
        if (value !== this._autoUpdate) {
          this._autoUpdate = value;
          if (!this._autoUpdate && this._isConnectedToTicker) {
            Ticker.shared.remove(this.update, this);
            this._isConnectedToTicker = false;
          } else if (this._autoUpdate && !this._isConnectedToTicker && this._isSourcePlaying()) {
            Ticker.shared.add(this.update, this);
            this._isConnectedToTicker = true;
          }
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(VideoResource3.prototype, "updateFPS", {
      /**
       * How many times a second to update the texture from the video. Leave at 0 to update at every render.
       * A lower fps can help performance, as updating the texture at 60fps on a 30ps video may not be efficient.
       *
       * @member {number}
       */
      get: function() {
        return this._updateFPS;
      },
      set: function(value) {
        if (value !== this._updateFPS) {
          this._updateFPS = value;
        }
      },
      enumerable: false,
      configurable: true
    });
    VideoResource3.test = function(source, extension) {
      return source instanceof HTMLVideoElement || VideoResource3.TYPES.indexOf(extension) > -1;
    };
    VideoResource3.TYPES = ["mp4", "m4v", "webm", "ogg", "ogv", "h264", "avi", "mov"];
    VideoResource3.MIME_TYPES = {
      ogv: "video/ogg",
      mov: "video/quicktime",
      m4v: "video/mp4"
    };
    return VideoResource3;
  }(BaseImageResource)
);
var ImageBitmapResource = (
  /** @class */
  function(_super) {
    __extends(ImageBitmapResource3, _super);
    function ImageBitmapResource3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    ImageBitmapResource3.test = function(source) {
      return !!window.createImageBitmap && source instanceof ImageBitmap;
    };
    return ImageBitmapResource3;
  }(BaseImageResource)
);
INSTALLED.push(ImageResource, ImageBitmapResource, CanvasResource, VideoResource, SVGResource, BufferResource, CubeResource, ArrayResource);
var System = (
  /** @class */
  function() {
    function System3(renderer) {
      this.renderer = renderer;
    }
    System3.prototype.destroy = function() {
      this.renderer = null;
    };
    return System3;
  }()
);
var DepthResource = (
  /** @class */
  function(_super) {
    __extends(DepthResource3, _super);
    function DepthResource3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    DepthResource3.prototype.upload = function(renderer, baseTexture, glTexture) {
      var gl = renderer.gl;
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === ALPHA_MODES.UNPACK);
      if (glTexture.width === baseTexture.width && glTexture.height === baseTexture.height) {
        gl.texSubImage2D(baseTexture.target, 0, 0, 0, baseTexture.width, baseTexture.height, baseTexture.format, baseTexture.type, this.data);
      } else {
        glTexture.width = baseTexture.width;
        glTexture.height = baseTexture.height;
        gl.texImage2D(
          baseTexture.target,
          0,
          //  gl.DEPTH_COMPONENT16 Needed for depth to render properly in webgl2.0
          renderer.context.webGLVersion === 1 ? gl.DEPTH_COMPONENT : gl.DEPTH_COMPONENT16,
          baseTexture.width,
          baseTexture.height,
          0,
          baseTexture.format,
          baseTexture.type,
          this.data
        );
      }
      return true;
    };
    return DepthResource3;
  }(BufferResource)
);
var Framebuffer = (
  /** @class */
  function() {
    function Framebuffer3(width, height) {
      this.width = Math.ceil(width || 100);
      this.height = Math.ceil(height || 100);
      this.stencil = false;
      this.depth = false;
      this.dirtyId = 0;
      this.dirtyFormat = 0;
      this.dirtySize = 0;
      this.depthTexture = null;
      this.colorTextures = [];
      this.glFramebuffers = {};
      this.disposeRunner = new Runner("disposeFramebuffer");
      this.multisample = MSAA_QUALITY.NONE;
    }
    Object.defineProperty(Framebuffer3.prototype, "colorTexture", {
      /**
       * Reference to the colorTexture.
       *
       * @member {PIXI.BaseTexture[]}
       * @readonly
       */
      get: function() {
        return this.colorTextures[0];
      },
      enumerable: false,
      configurable: true
    });
    Framebuffer3.prototype.addColorTexture = function(index2, texture) {
      if (index2 === void 0) {
        index2 = 0;
      }
      this.colorTextures[index2] = texture || new BaseTexture(null, {
        scaleMode: SCALE_MODES.NEAREST,
        resolution: 1,
        mipmap: MIPMAP_MODES.OFF,
        width: this.width,
        height: this.height
      });
      this.dirtyId++;
      this.dirtyFormat++;
      return this;
    };
    Framebuffer3.prototype.addDepthTexture = function(texture) {
      this.depthTexture = texture || new BaseTexture(new DepthResource(null, { width: this.width, height: this.height }), {
        scaleMode: SCALE_MODES.NEAREST,
        resolution: 1,
        width: this.width,
        height: this.height,
        mipmap: MIPMAP_MODES.OFF,
        format: FORMATS.DEPTH_COMPONENT,
        type: TYPES.UNSIGNED_SHORT
      });
      this.dirtyId++;
      this.dirtyFormat++;
      return this;
    };
    Framebuffer3.prototype.enableDepth = function() {
      this.depth = true;
      this.dirtyId++;
      this.dirtyFormat++;
      return this;
    };
    Framebuffer3.prototype.enableStencil = function() {
      this.stencil = true;
      this.dirtyId++;
      this.dirtyFormat++;
      return this;
    };
    Framebuffer3.prototype.resize = function(width, height) {
      width = Math.ceil(width);
      height = Math.ceil(height);
      if (width === this.width && height === this.height) {
        return;
      }
      this.width = width;
      this.height = height;
      this.dirtyId++;
      this.dirtySize++;
      for (var i = 0; i < this.colorTextures.length; i++) {
        var texture = this.colorTextures[i];
        var resolution = texture.resolution;
        texture.setSize(width / resolution, height / resolution);
      }
      if (this.depthTexture) {
        var resolution = this.depthTexture.resolution;
        this.depthTexture.setSize(width / resolution, height / resolution);
      }
    };
    Framebuffer3.prototype.dispose = function() {
      this.disposeRunner.emit(this, false);
    };
    Framebuffer3.prototype.destroyDepthTexture = function() {
      if (this.depthTexture) {
        this.depthTexture.destroy();
        this.depthTexture = null;
        ++this.dirtyId;
        ++this.dirtyFormat;
      }
    };
    return Framebuffer3;
  }()
);
var BaseRenderTexture = (
  /** @class */
  function(_super) {
    __extends(BaseRenderTexture3, _super);
    function BaseRenderTexture3(options) {
      var _this = this;
      if (typeof options === "number") {
        var width_1 = arguments[0];
        var height_1 = arguments[1];
        var scaleMode = arguments[2];
        var resolution = arguments[3];
        options = { width: width_1, height: height_1, scaleMode, resolution };
      }
      _this = _super.call(this, null, options) || this;
      var _a = options || {}, width = _a.width, height = _a.height;
      _this.mipmap = 0;
      _this.width = Math.ceil(width) || 100;
      _this.height = Math.ceil(height) || 100;
      _this.valid = true;
      _this.clearColor = [0, 0, 0, 0];
      _this.framebuffer = new Framebuffer(_this.width * _this.resolution, _this.height * _this.resolution).addColorTexture(0, _this);
      _this.maskStack = [];
      _this.filterStack = [{}];
      return _this;
    }
    BaseRenderTexture3.prototype.resize = function(width, height) {
      width = Math.ceil(width);
      height = Math.ceil(height);
      this.framebuffer.resize(width * this.resolution, height * this.resolution);
    };
    BaseRenderTexture3.prototype.dispose = function() {
      this.framebuffer.dispose();
      _super.prototype.dispose.call(this);
    };
    BaseRenderTexture3.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      this.framebuffer.destroyDepthTexture();
      this.framebuffer = null;
    };
    return BaseRenderTexture3;
  }(BaseTexture)
);
var TextureUvs = (
  /** @class */
  function() {
    function TextureUvs3() {
      this.x0 = 0;
      this.y0 = 0;
      this.x1 = 1;
      this.y1 = 0;
      this.x2 = 1;
      this.y2 = 1;
      this.x3 = 0;
      this.y3 = 1;
      this.uvsFloat32 = new Float32Array(8);
    }
    TextureUvs3.prototype.set = function(frame, baseFrame, rotate) {
      var tw = baseFrame.width;
      var th = baseFrame.height;
      if (rotate) {
        var w2 = frame.width / 2 / tw;
        var h2 = frame.height / 2 / th;
        var cX = frame.x / tw + w2;
        var cY = frame.y / th + h2;
        rotate = groupD8.add(rotate, groupD8.NW);
        this.x0 = cX + w2 * groupD8.uX(rotate);
        this.y0 = cY + h2 * groupD8.uY(rotate);
        rotate = groupD8.add(rotate, 2);
        this.x1 = cX + w2 * groupD8.uX(rotate);
        this.y1 = cY + h2 * groupD8.uY(rotate);
        rotate = groupD8.add(rotate, 2);
        this.x2 = cX + w2 * groupD8.uX(rotate);
        this.y2 = cY + h2 * groupD8.uY(rotate);
        rotate = groupD8.add(rotate, 2);
        this.x3 = cX + w2 * groupD8.uX(rotate);
        this.y3 = cY + h2 * groupD8.uY(rotate);
      } else {
        this.x0 = frame.x / tw;
        this.y0 = frame.y / th;
        this.x1 = (frame.x + frame.width) / tw;
        this.y1 = frame.y / th;
        this.x2 = (frame.x + frame.width) / tw;
        this.y2 = (frame.y + frame.height) / th;
        this.x3 = frame.x / tw;
        this.y3 = (frame.y + frame.height) / th;
      }
      this.uvsFloat32[0] = this.x0;
      this.uvsFloat32[1] = this.y0;
      this.uvsFloat32[2] = this.x1;
      this.uvsFloat32[3] = this.y1;
      this.uvsFloat32[4] = this.x2;
      this.uvsFloat32[5] = this.y2;
      this.uvsFloat32[6] = this.x3;
      this.uvsFloat32[7] = this.y3;
    };
    return TextureUvs3;
  }()
);
var DEFAULT_UVS = new TextureUvs();
var Texture = (
  /** @class */
  function(_super) {
    __extends(Texture3, _super);
    function Texture3(baseTexture, frame, orig, trim, rotate, anchor) {
      var _this = _super.call(this) || this;
      _this.noFrame = false;
      if (!frame) {
        _this.noFrame = true;
        frame = new Rectangle(0, 0, 1, 1);
      }
      if (baseTexture instanceof Texture3) {
        baseTexture = baseTexture.baseTexture;
      }
      _this.baseTexture = baseTexture;
      _this._frame = frame;
      _this.trim = trim;
      _this.valid = false;
      _this._uvs = DEFAULT_UVS;
      _this.uvMatrix = null;
      _this.orig = orig || frame;
      _this._rotate = Number(rotate || 0);
      if (rotate === true) {
        _this._rotate = 2;
      } else if (_this._rotate % 2 !== 0) {
        throw new Error("attempt to use diamond-shaped UVs. If you are sure, set rotation manually");
      }
      _this.defaultAnchor = anchor ? new Point(anchor.x, anchor.y) : new Point(0, 0);
      _this._updateID = 0;
      _this.textureCacheIds = [];
      if (!baseTexture.valid) {
        baseTexture.once("loaded", _this.onBaseTextureUpdated, _this);
      } else if (_this.noFrame) {
        if (baseTexture.valid) {
          _this.onBaseTextureUpdated(baseTexture);
        }
      } else {
        _this.frame = frame;
      }
      if (_this.noFrame) {
        baseTexture.on("update", _this.onBaseTextureUpdated, _this);
      }
      return _this;
    }
    Texture3.prototype.update = function() {
      if (this.baseTexture.resource) {
        this.baseTexture.resource.update();
      }
    };
    Texture3.prototype.onBaseTextureUpdated = function(baseTexture) {
      if (this.noFrame) {
        if (!this.baseTexture.valid) {
          return;
        }
        this._frame.width = baseTexture.width;
        this._frame.height = baseTexture.height;
        this.valid = true;
        this.updateUvs();
      } else {
        this.frame = this._frame;
      }
      this.emit("update", this);
    };
    Texture3.prototype.destroy = function(destroyBase) {
      if (this.baseTexture) {
        if (destroyBase) {
          var resource = this.baseTexture;
          if (resource && resource.url && TextureCache[resource.url]) {
            Texture3.removeFromCache(resource.url);
          }
          this.baseTexture.destroy();
        }
        this.baseTexture.off("loaded", this.onBaseTextureUpdated, this);
        this.baseTexture.off("update", this.onBaseTextureUpdated, this);
        this.baseTexture = null;
      }
      this._frame = null;
      this._uvs = null;
      this.trim = null;
      this.orig = null;
      this.valid = false;
      Texture3.removeFromCache(this);
      this.textureCacheIds = null;
    };
    Texture3.prototype.clone = function() {
      return new Texture3(this.baseTexture, this.frame.clone(), this.orig.clone(), this.trim && this.trim.clone(), this.rotate, this.defaultAnchor);
    };
    Texture3.prototype.updateUvs = function() {
      if (this._uvs === DEFAULT_UVS) {
        this._uvs = new TextureUvs();
      }
      this._uvs.set(this._frame, this.baseTexture, this.rotate);
      this._updateID++;
    };
    Texture3.from = function(source, options, strict) {
      if (options === void 0) {
        options = {};
      }
      if (strict === void 0) {
        strict = settings.STRICT_TEXTURE_CACHE;
      }
      var isFrame = typeof source === "string";
      var cacheId = null;
      if (isFrame) {
        cacheId = source;
      } else {
        if (!source._pixiId) {
          source._pixiId = "pixiid_" + uid();
        }
        cacheId = source._pixiId;
      }
      var texture = TextureCache[cacheId];
      if (isFrame && strict && !texture) {
        throw new Error('The cacheId "' + cacheId + '" does not exist in TextureCache.');
      }
      if (!texture) {
        if (!options.resolution) {
          options.resolution = getResolutionOfUrl(source);
        }
        texture = new Texture3(new BaseTexture(source, options));
        texture.baseTexture.cacheId = cacheId;
        BaseTexture.addToCache(texture.baseTexture, cacheId);
        Texture3.addToCache(texture, cacheId);
      }
      return texture;
    };
    Texture3.fromURL = function(url, options) {
      var resourceOptions = Object.assign({ autoLoad: false }, options === null || options === void 0 ? void 0 : options.resourceOptions);
      var texture = Texture3.from(url, Object.assign({ resourceOptions }, options), false);
      var resource = texture.baseTexture.resource;
      if (texture.baseTexture.valid) {
        return Promise.resolve(texture);
      }
      return resource.load().then(function() {
        return Promise.resolve(texture);
      });
    };
    Texture3.fromBuffer = function(buffer, width, height, options) {
      return new Texture3(BaseTexture.fromBuffer(buffer, width, height, options));
    };
    Texture3.fromLoader = function(source, imageUrl, name) {
      var resource = new ImageResource(source);
      resource.url = imageUrl;
      var baseTexture = new BaseTexture(resource, {
        scaleMode: settings.SCALE_MODE,
        resolution: getResolutionOfUrl(imageUrl)
      });
      var texture = new Texture3(baseTexture);
      if (!name) {
        name = imageUrl;
      }
      BaseTexture.addToCache(texture.baseTexture, name);
      Texture3.addToCache(texture, name);
      if (name !== imageUrl) {
        BaseTexture.addToCache(texture.baseTexture, imageUrl);
        Texture3.addToCache(texture, imageUrl);
      }
      return texture;
    };
    Texture3.addToCache = function(texture, id) {
      if (id) {
        if (texture.textureCacheIds.indexOf(id) === -1) {
          texture.textureCacheIds.push(id);
        }
        if (TextureCache[id]) {
          console.warn("Texture added to the cache with an id [" + id + "] that already had an entry");
        }
        TextureCache[id] = texture;
      }
    };
    Texture3.removeFromCache = function(texture) {
      if (typeof texture === "string") {
        var textureFromCache = TextureCache[texture];
        if (textureFromCache) {
          var index2 = textureFromCache.textureCacheIds.indexOf(texture);
          if (index2 > -1) {
            textureFromCache.textureCacheIds.splice(index2, 1);
          }
          delete TextureCache[texture];
          return textureFromCache;
        }
      } else if (texture && texture.textureCacheIds) {
        for (var i = 0; i < texture.textureCacheIds.length; ++i) {
          if (TextureCache[texture.textureCacheIds[i]] === texture) {
            delete TextureCache[texture.textureCacheIds[i]];
          }
        }
        texture.textureCacheIds.length = 0;
        return texture;
      }
      return null;
    };
    Object.defineProperty(Texture3.prototype, "resolution", {
      /**
       * Returns resolution of baseTexture
       *
       * @member {number}
       * @readonly
       */
      get: function() {
        return this.baseTexture.resolution;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Texture3.prototype, "frame", {
      /**
       * The frame specifies the region of the base texture that this texture uses.
       * Please call `updateUvs()` after you change coordinates of `frame` manually.
       *
       * @member {PIXI.Rectangle}
       */
      get: function() {
        return this._frame;
      },
      set: function(frame) {
        this._frame = frame;
        this.noFrame = false;
        var x2 = frame.x, y2 = frame.y, width = frame.width, height = frame.height;
        var xNotFit = x2 + width > this.baseTexture.width;
        var yNotFit = y2 + height > this.baseTexture.height;
        if (xNotFit || yNotFit) {
          var relationship = xNotFit && yNotFit ? "and" : "or";
          var errorX = "X: " + x2 + " + " + width + " = " + (x2 + width) + " > " + this.baseTexture.width;
          var errorY = "Y: " + y2 + " + " + height + " = " + (y2 + height) + " > " + this.baseTexture.height;
          throw new Error("Texture Error: frame does not fit inside the base Texture dimensions: " + (errorX + " " + relationship + " " + errorY));
        }
        this.valid = width && height && this.baseTexture.valid;
        if (!this.trim && !this.rotate) {
          this.orig = frame;
        }
        if (this.valid) {
          this.updateUvs();
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Texture3.prototype, "rotate", {
      /**
       * Indicates whether the texture is rotated inside the atlas
       * set to 2 to compensate for texture packer rotation
       * set to 6 to compensate for spine packer rotation
       * can be used to rotate or mirror sprites
       * See {@link PIXI.groupD8} for explanation
       *
       * @member {number}
       */
      get: function() {
        return this._rotate;
      },
      set: function(rotate) {
        this._rotate = rotate;
        if (this.valid) {
          this.updateUvs();
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Texture3.prototype, "width", {
      /**
       * The width of the Texture in pixels.
       *
       * @member {number}
       */
      get: function() {
        return this.orig.width;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Texture3.prototype, "height", {
      /**
       * The height of the Texture in pixels.
       *
       * @member {number}
       */
      get: function() {
        return this.orig.height;
      },
      enumerable: false,
      configurable: true
    });
    Texture3.prototype.castToBaseTexture = function() {
      return this.baseTexture;
    };
    return Texture3;
  }(import_eventemitter3.default)
);
function createWhiteTexture() {
  var canvas = document.createElement("canvas");
  canvas.width = 16;
  canvas.height = 16;
  var context3 = canvas.getContext("2d");
  context3.fillStyle = "white";
  context3.fillRect(0, 0, 16, 16);
  return new Texture(new BaseTexture(new CanvasResource(canvas)));
}
function removeAllHandlers(tex) {
  tex.destroy = function _emptyDestroy() {
  };
  tex.on = function _emptyOn() {
  };
  tex.once = function _emptyOnce() {
  };
  tex.emit = function _emptyEmit() {
  };
}
Texture.EMPTY = new Texture(new BaseTexture());
removeAllHandlers(Texture.EMPTY);
removeAllHandlers(Texture.EMPTY.baseTexture);
Texture.WHITE = createWhiteTexture();
removeAllHandlers(Texture.WHITE);
removeAllHandlers(Texture.WHITE.baseTexture);
var RenderTexture = (
  /** @class */
  function(_super) {
    __extends(RenderTexture3, _super);
    function RenderTexture3(baseRenderTexture, frame) {
      var _this = this;
      var _legacyRenderer = null;
      if (!(baseRenderTexture instanceof BaseRenderTexture)) {
        var width = arguments[1];
        var height = arguments[2];
        var scaleMode = arguments[3];
        var resolution = arguments[4];
        console.warn("Please use RenderTexture.create(" + width + ", " + height + ") instead of the ctor directly.");
        _legacyRenderer = arguments[0];
        frame = null;
        baseRenderTexture = new BaseRenderTexture({
          width,
          height,
          scaleMode,
          resolution
        });
      }
      _this = _super.call(this, baseRenderTexture, frame) || this;
      _this.legacyRenderer = _legacyRenderer;
      _this.valid = true;
      _this.filterFrame = null;
      _this.filterPoolKey = null;
      _this.updateUvs();
      return _this;
    }
    Object.defineProperty(RenderTexture3.prototype, "framebuffer", {
      /**
       * Shortcut to `this.baseTexture.framebuffer`, saves baseTexture cast.
       * @member {PIXI.Framebuffer}
       * @readonly
       */
      get: function() {
        return this.baseTexture.framebuffer;
      },
      enumerable: false,
      configurable: true
    });
    RenderTexture3.prototype.resize = function(width, height, resizeBaseTexture) {
      if (resizeBaseTexture === void 0) {
        resizeBaseTexture = true;
      }
      width = Math.ceil(width);
      height = Math.ceil(height);
      this.valid = width > 0 && height > 0;
      this._frame.width = this.orig.width = width;
      this._frame.height = this.orig.height = height;
      if (resizeBaseTexture) {
        this.baseTexture.resize(width, height);
      }
      this.updateUvs();
    };
    RenderTexture3.prototype.setResolution = function(resolution) {
      var baseTexture = this.baseTexture;
      if (baseTexture.resolution === resolution) {
        return;
      }
      baseTexture.setResolution(resolution);
      this.resize(baseTexture.width, baseTexture.height, false);
    };
    RenderTexture3.create = function(options) {
      if (typeof options === "number") {
        options = {
          width: options,
          height: arguments[1],
          scaleMode: arguments[2],
          resolution: arguments[3]
        };
      }
      return new RenderTexture3(new BaseRenderTexture(options));
    };
    return RenderTexture3;
  }(Texture)
);
var RenderTexturePool = (
  /** @class */
  function() {
    function RenderTexturePool3(textureOptions) {
      this.texturePool = {};
      this.textureOptions = textureOptions || {};
      this.enableFullScreen = false;
      this._pixelsWidth = 0;
      this._pixelsHeight = 0;
    }
    RenderTexturePool3.prototype.createTexture = function(realWidth, realHeight) {
      var baseRenderTexture = new BaseRenderTexture(Object.assign({
        width: realWidth,
        height: realHeight,
        resolution: 1
      }, this.textureOptions));
      return new RenderTexture(baseRenderTexture);
    };
    RenderTexturePool3.prototype.getOptimalTexture = function(minWidth, minHeight, resolution) {
      if (resolution === void 0) {
        resolution = 1;
      }
      var key = RenderTexturePool3.SCREEN_KEY;
      minWidth *= resolution;
      minHeight *= resolution;
      if (!this.enableFullScreen || minWidth !== this._pixelsWidth || minHeight !== this._pixelsHeight) {
        minWidth = nextPow2(minWidth);
        minHeight = nextPow2(minHeight);
        key = (minWidth & 65535) << 16 | minHeight & 65535;
      }
      if (!this.texturePool[key]) {
        this.texturePool[key] = [];
      }
      var renderTexture = this.texturePool[key].pop();
      if (!renderTexture) {
        renderTexture = this.createTexture(minWidth, minHeight);
      }
      renderTexture.filterPoolKey = key;
      renderTexture.setResolution(resolution);
      return renderTexture;
    };
    RenderTexturePool3.prototype.getFilterTexture = function(input, resolution) {
      var filterTexture = this.getOptimalTexture(input.width, input.height, resolution || input.resolution);
      filterTexture.filterFrame = input.filterFrame;
      return filterTexture;
    };
    RenderTexturePool3.prototype.returnTexture = function(renderTexture) {
      var key = renderTexture.filterPoolKey;
      renderTexture.filterFrame = null;
      this.texturePool[key].push(renderTexture);
    };
    RenderTexturePool3.prototype.returnFilterTexture = function(renderTexture) {
      this.returnTexture(renderTexture);
    };
    RenderTexturePool3.prototype.clear = function(destroyTextures) {
      destroyTextures = destroyTextures !== false;
      if (destroyTextures) {
        for (var i in this.texturePool) {
          var textures = this.texturePool[i];
          if (textures) {
            for (var j2 = 0; j2 < textures.length; j2++) {
              textures[j2].destroy(true);
            }
          }
        }
      }
      this.texturePool = {};
    };
    RenderTexturePool3.prototype.setScreenSize = function(size) {
      if (size.width === this._pixelsWidth && size.height === this._pixelsHeight) {
        return;
      }
      var screenKey = RenderTexturePool3.SCREEN_KEY;
      var textures = this.texturePool[screenKey];
      this.enableFullScreen = size.width > 0 && size.height > 0;
      if (textures) {
        for (var j2 = 0; j2 < textures.length; j2++) {
          textures[j2].destroy(true);
        }
      }
      this.texturePool[screenKey] = [];
      this._pixelsWidth = size.width;
      this._pixelsHeight = size.height;
    };
    RenderTexturePool3.SCREEN_KEY = "screen";
    return RenderTexturePool3;
  }()
);
var Attribute = (
  /** @class */
  function() {
    function Attribute3(buffer, size, normalized, type, stride, start, instance) {
      if (size === void 0) {
        size = 0;
      }
      if (normalized === void 0) {
        normalized = false;
      }
      if (type === void 0) {
        type = 5126;
      }
      this.buffer = buffer;
      this.size = size;
      this.normalized = normalized;
      this.type = type;
      this.stride = stride;
      this.start = start;
      this.instance = instance;
    }
    Attribute3.prototype.destroy = function() {
      this.buffer = null;
    };
    Attribute3.from = function(buffer, size, normalized, type, stride) {
      return new Attribute3(buffer, size, normalized, type, stride);
    };
    return Attribute3;
  }()
);
var UID = 0;
var Buffer = (
  /** @class */
  function() {
    function Buffer3(data, _static, index2) {
      if (_static === void 0) {
        _static = true;
      }
      if (index2 === void 0) {
        index2 = false;
      }
      this.data = data || new Float32Array(1);
      this._glBuffers = {};
      this._updateID = 0;
      this.index = index2;
      this.static = _static;
      this.id = UID++;
      this.disposeRunner = new Runner("disposeBuffer");
    }
    Buffer3.prototype.update = function(data) {
      this.data = data || this.data;
      this._updateID++;
    };
    Buffer3.prototype.dispose = function() {
      this.disposeRunner.emit(this, false);
    };
    Buffer3.prototype.destroy = function() {
      this.dispose();
      this.data = null;
    };
    Buffer3.from = function(data) {
      if (data instanceof Array) {
        data = new Float32Array(data);
      }
      return new Buffer3(data);
    };
    return Buffer3;
  }()
);
function getBufferType(array) {
  if (array.BYTES_PER_ELEMENT === 4) {
    if (array instanceof Float32Array) {
      return "Float32Array";
    } else if (array instanceof Uint32Array) {
      return "Uint32Array";
    }
    return "Int32Array";
  } else if (array.BYTES_PER_ELEMENT === 2) {
    if (array instanceof Uint16Array) {
      return "Uint16Array";
    }
  } else if (array.BYTES_PER_ELEMENT === 1) {
    if (array instanceof Uint8Array) {
      return "Uint8Array";
    }
  }
  return null;
}
var map = {
  Float32Array,
  Uint32Array,
  Int32Array,
  Uint8Array
};
function interleaveTypedArrays(arrays, sizes) {
  var outSize = 0;
  var stride = 0;
  var views = {};
  for (var i = 0; i < arrays.length; i++) {
    stride += sizes[i];
    outSize += arrays[i].length;
  }
  var buffer = new ArrayBuffer(outSize * 4);
  var out = null;
  var littleOffset = 0;
  for (var i = 0; i < arrays.length; i++) {
    var size = sizes[i];
    var array = arrays[i];
    var type = getBufferType(array);
    if (!views[type]) {
      views[type] = new map[type](buffer);
    }
    out = views[type];
    for (var j2 = 0; j2 < array.length; j2++) {
      var indexStart = (j2 / size | 0) * stride + littleOffset;
      var index2 = j2 % size;
      out[indexStart + index2] = array[j2];
    }
    littleOffset += size;
  }
  return new Float32Array(buffer);
}
var byteSizeMap = { 5126: 4, 5123: 2, 5121: 1 };
var UID$1 = 0;
var map$1 = {
  Float32Array,
  Uint32Array,
  Int32Array,
  Uint8Array,
  Uint16Array
};
var Geometry = (
  /** @class */
  function() {
    function Geometry3(buffers, attributes) {
      if (buffers === void 0) {
        buffers = [];
      }
      if (attributes === void 0) {
        attributes = {};
      }
      this.buffers = buffers;
      this.indexBuffer = null;
      this.attributes = attributes;
      this.glVertexArrayObjects = {};
      this.id = UID$1++;
      this.instanced = false;
      this.instanceCount = 1;
      this.disposeRunner = new Runner("disposeGeometry");
      this.refCount = 0;
    }
    Geometry3.prototype.addAttribute = function(id, buffer, size, normalized, type, stride, start, instance) {
      if (size === void 0) {
        size = 0;
      }
      if (normalized === void 0) {
        normalized = false;
      }
      if (instance === void 0) {
        instance = false;
      }
      if (!buffer) {
        throw new Error("You must pass a buffer when creating an attribute");
      }
      if (!(buffer instanceof Buffer)) {
        if (buffer instanceof Array) {
          buffer = new Float32Array(buffer);
        }
        buffer = new Buffer(buffer);
      }
      var ids = id.split("|");
      if (ids.length > 1) {
        for (var i = 0; i < ids.length; i++) {
          this.addAttribute(ids[i], buffer, size, normalized, type);
        }
        return this;
      }
      var bufferIndex = this.buffers.indexOf(buffer);
      if (bufferIndex === -1) {
        this.buffers.push(buffer);
        bufferIndex = this.buffers.length - 1;
      }
      this.attributes[id] = new Attribute(bufferIndex, size, normalized, type, stride, start, instance);
      this.instanced = this.instanced || instance;
      return this;
    };
    Geometry3.prototype.getAttribute = function(id) {
      return this.attributes[id];
    };
    Geometry3.prototype.getBuffer = function(id) {
      return this.buffers[this.getAttribute(id).buffer];
    };
    Geometry3.prototype.addIndex = function(buffer) {
      if (!(buffer instanceof Buffer)) {
        if (buffer instanceof Array) {
          buffer = new Uint16Array(buffer);
        }
        buffer = new Buffer(buffer);
      }
      buffer.index = true;
      this.indexBuffer = buffer;
      if (this.buffers.indexOf(buffer) === -1) {
        this.buffers.push(buffer);
      }
      return this;
    };
    Geometry3.prototype.getIndex = function() {
      return this.indexBuffer;
    };
    Geometry3.prototype.interleave = function() {
      if (this.buffers.length === 1 || this.buffers.length === 2 && this.indexBuffer) {
        return this;
      }
      var arrays = [];
      var sizes = [];
      var interleavedBuffer = new Buffer();
      var i;
      for (i in this.attributes) {
        var attribute = this.attributes[i];
        var buffer = this.buffers[attribute.buffer];
        arrays.push(buffer.data);
        sizes.push(attribute.size * byteSizeMap[attribute.type] / 4);
        attribute.buffer = 0;
      }
      interleavedBuffer.data = interleaveTypedArrays(arrays, sizes);
      for (i = 0; i < this.buffers.length; i++) {
        if (this.buffers[i] !== this.indexBuffer) {
          this.buffers[i].destroy();
        }
      }
      this.buffers = [interleavedBuffer];
      if (this.indexBuffer) {
        this.buffers.push(this.indexBuffer);
      }
      return this;
    };
    Geometry3.prototype.getSize = function() {
      for (var i in this.attributes) {
        var attribute = this.attributes[i];
        var buffer = this.buffers[attribute.buffer];
        return buffer.data.length / (attribute.stride / 4 || attribute.size);
      }
      return 0;
    };
    Geometry3.prototype.dispose = function() {
      this.disposeRunner.emit(this, false);
    };
    Geometry3.prototype.destroy = function() {
      this.dispose();
      this.buffers = null;
      this.indexBuffer = null;
      this.attributes = null;
    };
    Geometry3.prototype.clone = function() {
      var geometry = new Geometry3();
      for (var i = 0; i < this.buffers.length; i++) {
        geometry.buffers[i] = new Buffer(this.buffers[i].data.slice(0));
      }
      for (var i in this.attributes) {
        var attrib = this.attributes[i];
        geometry.attributes[i] = new Attribute(attrib.buffer, attrib.size, attrib.normalized, attrib.type, attrib.stride, attrib.start, attrib.instance);
      }
      if (this.indexBuffer) {
        geometry.indexBuffer = geometry.buffers[this.buffers.indexOf(this.indexBuffer)];
        geometry.indexBuffer.index = true;
      }
      return geometry;
    };
    Geometry3.merge = function(geometries) {
      var geometryOut = new Geometry3();
      var arrays = [];
      var sizes = [];
      var offsets = [];
      var geometry;
      for (var i = 0; i < geometries.length; i++) {
        geometry = geometries[i];
        for (var j2 = 0; j2 < geometry.buffers.length; j2++) {
          sizes[j2] = sizes[j2] || 0;
          sizes[j2] += geometry.buffers[j2].data.length;
          offsets[j2] = 0;
        }
      }
      for (var i = 0; i < geometry.buffers.length; i++) {
        arrays[i] = new map$1[getBufferType(geometry.buffers[i].data)](sizes[i]);
        geometryOut.buffers[i] = new Buffer(arrays[i]);
      }
      for (var i = 0; i < geometries.length; i++) {
        geometry = geometries[i];
        for (var j2 = 0; j2 < geometry.buffers.length; j2++) {
          arrays[j2].set(geometry.buffers[j2].data, offsets[j2]);
          offsets[j2] += geometry.buffers[j2].data.length;
        }
      }
      geometryOut.attributes = geometry.attributes;
      if (geometry.indexBuffer) {
        geometryOut.indexBuffer = geometryOut.buffers[geometry.buffers.indexOf(geometry.indexBuffer)];
        geometryOut.indexBuffer.index = true;
        var offset = 0;
        var stride = 0;
        var offset2 = 0;
        var bufferIndexToCount = 0;
        for (var i = 0; i < geometry.buffers.length; i++) {
          if (geometry.buffers[i] !== geometry.indexBuffer) {
            bufferIndexToCount = i;
            break;
          }
        }
        for (var i in geometry.attributes) {
          var attribute = geometry.attributes[i];
          if ((attribute.buffer | 0) === bufferIndexToCount) {
            stride += attribute.size * byteSizeMap[attribute.type] / 4;
          }
        }
        for (var i = 0; i < geometries.length; i++) {
          var indexBufferData = geometries[i].indexBuffer.data;
          for (var j2 = 0; j2 < indexBufferData.length; j2++) {
            geometryOut.indexBuffer.data[j2 + offset2] += offset;
          }
          offset += geometry.buffers[bufferIndexToCount].data.length / stride;
          offset2 += indexBufferData.length;
        }
      }
      return geometryOut;
    };
    return Geometry3;
  }()
);
var Quad = (
  /** @class */
  function(_super) {
    __extends(Quad3, _super);
    function Quad3() {
      var _this = _super.call(this) || this;
      _this.addAttribute("aVertexPosition", new Float32Array([
        0,
        0,
        1,
        0,
        1,
        1,
        0,
        1
      ])).addIndex([0, 1, 3, 2]);
      return _this;
    }
    return Quad3;
  }(Geometry)
);
var QuadUv = (
  /** @class */
  function(_super) {
    __extends(QuadUv3, _super);
    function QuadUv3() {
      var _this = _super.call(this) || this;
      _this.vertices = new Float32Array([
        -1,
        -1,
        1,
        -1,
        1,
        1,
        -1,
        1
      ]);
      _this.uvs = new Float32Array([
        0,
        0,
        1,
        0,
        1,
        1,
        0,
        1
      ]);
      _this.vertexBuffer = new Buffer(_this.vertices);
      _this.uvBuffer = new Buffer(_this.uvs);
      _this.addAttribute("aVertexPosition", _this.vertexBuffer).addAttribute("aTextureCoord", _this.uvBuffer).addIndex([0, 1, 2, 0, 2, 3]);
      return _this;
    }
    QuadUv3.prototype.map = function(targetTextureFrame, destinationFrame) {
      var x2 = 0;
      var y2 = 0;
      this.uvs[0] = x2;
      this.uvs[1] = y2;
      this.uvs[2] = x2 + destinationFrame.width / targetTextureFrame.width;
      this.uvs[3] = y2;
      this.uvs[4] = x2 + destinationFrame.width / targetTextureFrame.width;
      this.uvs[5] = y2 + destinationFrame.height / targetTextureFrame.height;
      this.uvs[6] = x2;
      this.uvs[7] = y2 + destinationFrame.height / targetTextureFrame.height;
      x2 = destinationFrame.x;
      y2 = destinationFrame.y;
      this.vertices[0] = x2;
      this.vertices[1] = y2;
      this.vertices[2] = x2 + destinationFrame.width;
      this.vertices[3] = y2;
      this.vertices[4] = x2 + destinationFrame.width;
      this.vertices[5] = y2 + destinationFrame.height;
      this.vertices[6] = x2;
      this.vertices[7] = y2 + destinationFrame.height;
      this.invalidate();
      return this;
    };
    QuadUv3.prototype.invalidate = function() {
      this.vertexBuffer._updateID++;
      this.uvBuffer._updateID++;
      return this;
    };
    return QuadUv3;
  }(Geometry)
);
var UID$2 = 0;
var UniformGroup = (
  /** @class */
  function() {
    function UniformGroup3(uniforms, _static) {
      this.uniforms = uniforms;
      this.group = true;
      this.syncUniforms = {};
      this.dirtyId = 0;
      this.id = UID$2++;
      this.static = !!_static;
    }
    UniformGroup3.prototype.update = function() {
      this.dirtyId++;
    };
    UniformGroup3.prototype.add = function(name, uniforms, _static) {
      this.uniforms[name] = new UniformGroup3(uniforms, _static);
    };
    UniformGroup3.from = function(uniforms, _static) {
      return new UniformGroup3(uniforms, _static);
    };
    return UniformGroup3;
  }()
);
var FilterState = (
  /** @class */
  function() {
    function FilterState3() {
      this.renderTexture = null;
      this.target = null;
      this.legacy = false;
      this.resolution = 1;
      this.sourceFrame = new Rectangle();
      this.destinationFrame = new Rectangle();
      this.filters = [];
    }
    FilterState3.prototype.clear = function() {
      this.target = null;
      this.filters = null;
      this.renderTexture = null;
    };
    return FilterState3;
  }()
);
var FilterSystem = (
  /** @class */
  function(_super) {
    __extends(FilterSystem3, _super);
    function FilterSystem3(renderer) {
      var _this = _super.call(this, renderer) || this;
      _this.defaultFilterStack = [{}];
      _this.texturePool = new RenderTexturePool();
      _this.texturePool.setScreenSize(renderer.view);
      _this.statePool = [];
      _this.quad = new Quad();
      _this.quadUv = new QuadUv();
      _this.tempRect = new Rectangle();
      _this.activeState = {};
      _this.globalUniforms = new UniformGroup({
        outputFrame: _this.tempRect,
        inputSize: new Float32Array(4),
        inputPixel: new Float32Array(4),
        inputClamp: new Float32Array(4),
        resolution: 1,
        // legacy variables
        filterArea: new Float32Array(4),
        filterClamp: new Float32Array(4)
      }, true);
      _this.forceClear = false;
      _this.useMaxPadding = false;
      return _this;
    }
    FilterSystem3.prototype.push = function(target, filters) {
      var renderer = this.renderer;
      var filterStack = this.defaultFilterStack;
      var state = this.statePool.pop() || new FilterState();
      var resolution = filters[0].resolution;
      var padding = filters[0].padding;
      var autoFit = filters[0].autoFit;
      var legacy = filters[0].legacy;
      for (var i = 1; i < filters.length; i++) {
        var filter = filters[i];
        resolution = Math.min(resolution, filter.resolution);
        padding = this.useMaxPadding ? Math.max(padding, filter.padding) : padding + filter.padding;
        autoFit = autoFit && filter.autoFit;
        legacy = legacy || filter.legacy;
      }
      if (filterStack.length === 1) {
        this.defaultFilterStack[0].renderTexture = renderer.renderTexture.current;
      }
      filterStack.push(state);
      state.resolution = resolution;
      state.legacy = legacy;
      state.target = target;
      state.sourceFrame.copyFrom(target.filterArea || target.getBounds(true));
      state.sourceFrame.pad(padding);
      if (autoFit) {
        state.sourceFrame.fit(this.renderer.renderTexture.sourceFrame);
      }
      state.sourceFrame.ceil(resolution);
      state.renderTexture = this.getOptimalFilterTexture(state.sourceFrame.width, state.sourceFrame.height, resolution);
      state.filters = filters;
      state.destinationFrame.width = state.renderTexture.width;
      state.destinationFrame.height = state.renderTexture.height;
      var destinationFrame = this.tempRect;
      destinationFrame.width = state.sourceFrame.width;
      destinationFrame.height = state.sourceFrame.height;
      state.renderTexture.filterFrame = state.sourceFrame;
      renderer.renderTexture.bind(state.renderTexture, state.sourceFrame, destinationFrame);
      renderer.renderTexture.clear();
    };
    FilterSystem3.prototype.pop = function() {
      var filterStack = this.defaultFilterStack;
      var state = filterStack.pop();
      var filters = state.filters;
      this.activeState = state;
      var globalUniforms = this.globalUniforms.uniforms;
      globalUniforms.outputFrame = state.sourceFrame;
      globalUniforms.resolution = state.resolution;
      var inputSize = globalUniforms.inputSize;
      var inputPixel = globalUniforms.inputPixel;
      var inputClamp = globalUniforms.inputClamp;
      inputSize[0] = state.destinationFrame.width;
      inputSize[1] = state.destinationFrame.height;
      inputSize[2] = 1 / inputSize[0];
      inputSize[3] = 1 / inputSize[1];
      inputPixel[0] = inputSize[0] * state.resolution;
      inputPixel[1] = inputSize[1] * state.resolution;
      inputPixel[2] = 1 / inputPixel[0];
      inputPixel[3] = 1 / inputPixel[1];
      inputClamp[0] = 0.5 * inputPixel[2];
      inputClamp[1] = 0.5 * inputPixel[3];
      inputClamp[2] = state.sourceFrame.width * inputSize[2] - 0.5 * inputPixel[2];
      inputClamp[3] = state.sourceFrame.height * inputSize[3] - 0.5 * inputPixel[3];
      if (state.legacy) {
        var filterArea = globalUniforms.filterArea;
        filterArea[0] = state.destinationFrame.width;
        filterArea[1] = state.destinationFrame.height;
        filterArea[2] = state.sourceFrame.x;
        filterArea[3] = state.sourceFrame.y;
        globalUniforms.filterClamp = globalUniforms.inputClamp;
      }
      this.globalUniforms.update();
      var lastState = filterStack[filterStack.length - 1];
      if (state.renderTexture.framebuffer.multisample > 1) {
        this.renderer.framebuffer.blit();
      }
      if (filters.length === 1) {
        filters[0].apply(this, state.renderTexture, lastState.renderTexture, CLEAR_MODES.BLEND, state);
        this.returnFilterTexture(state.renderTexture);
      } else {
        var flip = state.renderTexture;
        var flop = this.getOptimalFilterTexture(flip.width, flip.height, state.resolution);
        flop.filterFrame = flip.filterFrame;
        var i = 0;
        for (i = 0; i < filters.length - 1; ++i) {
          filters[i].apply(this, flip, flop, CLEAR_MODES.CLEAR, state);
          var t = flip;
          flip = flop;
          flop = t;
        }
        filters[i].apply(this, flip, lastState.renderTexture, CLEAR_MODES.BLEND, state);
        this.returnFilterTexture(flip);
        this.returnFilterTexture(flop);
      }
      state.clear();
      this.statePool.push(state);
    };
    FilterSystem3.prototype.bindAndClear = function(filterTexture, clearMode) {
      if (clearMode === void 0) {
        clearMode = CLEAR_MODES.CLEAR;
      }
      if (filterTexture && filterTexture.filterFrame) {
        var destinationFrame = this.tempRect;
        destinationFrame.width = filterTexture.filterFrame.width;
        destinationFrame.height = filterTexture.filterFrame.height;
        this.renderer.renderTexture.bind(filterTexture, filterTexture.filterFrame, destinationFrame);
      } else {
        this.renderer.renderTexture.bind(filterTexture);
      }
      if (typeof clearMode === "boolean") {
        clearMode = clearMode ? CLEAR_MODES.CLEAR : CLEAR_MODES.BLEND;
        deprecation("5.2.1", "Use CLEAR_MODES when using clear applyFilter option");
      }
      if (clearMode === CLEAR_MODES.CLEAR || clearMode === CLEAR_MODES.BLIT && this.forceClear) {
        this.renderer.renderTexture.clear();
      }
    };
    FilterSystem3.prototype.applyFilter = function(filter, input, output, clearMode) {
      var renderer = this.renderer;
      this.bindAndClear(output, clearMode);
      filter.uniforms.uSampler = input;
      filter.uniforms.filterGlobals = this.globalUniforms;
      renderer.state.set(filter.state);
      renderer.shader.bind(filter);
      if (filter.legacy) {
        this.quadUv.map(input._frame, input.filterFrame);
        renderer.geometry.bind(this.quadUv);
        renderer.geometry.draw(DRAW_MODES.TRIANGLES);
      } else {
        renderer.geometry.bind(this.quad);
        renderer.geometry.draw(DRAW_MODES.TRIANGLE_STRIP);
      }
    };
    FilterSystem3.prototype.calculateSpriteMatrix = function(outputMatrix, sprite) {
      var _a = this.activeState, sourceFrame = _a.sourceFrame, destinationFrame = _a.destinationFrame;
      var orig = sprite._texture.orig;
      var mappedMatrix = outputMatrix.set(destinationFrame.width, 0, 0, destinationFrame.height, sourceFrame.x, sourceFrame.y);
      var worldTransform = sprite.worldTransform.copyTo(Matrix.TEMP_MATRIX);
      worldTransform.invert();
      mappedMatrix.prepend(worldTransform);
      mappedMatrix.scale(1 / orig.width, 1 / orig.height);
      mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);
      return mappedMatrix;
    };
    FilterSystem3.prototype.destroy = function() {
      this.texturePool.clear(false);
    };
    FilterSystem3.prototype.getOptimalFilterTexture = function(minWidth, minHeight, resolution) {
      if (resolution === void 0) {
        resolution = 1;
      }
      return this.texturePool.getOptimalTexture(minWidth, minHeight, resolution);
    };
    FilterSystem3.prototype.getFilterTexture = function(input, resolution) {
      if (typeof input === "number") {
        var swap = input;
        input = resolution;
        resolution = swap;
      }
      input = input || this.activeState.renderTexture;
      var filterTexture = this.texturePool.getOptimalTexture(input.width, input.height, resolution || input.resolution);
      filterTexture.filterFrame = input.filterFrame;
      return filterTexture;
    };
    FilterSystem3.prototype.returnFilterTexture = function(renderTexture) {
      this.texturePool.returnTexture(renderTexture);
    };
    FilterSystem3.prototype.emptyPool = function() {
      this.texturePool.clear(true);
    };
    FilterSystem3.prototype.resize = function() {
      this.texturePool.setScreenSize(this.renderer.view);
    };
    return FilterSystem3;
  }(System)
);
var ObjectRenderer = (
  /** @class */
  function() {
    function ObjectRenderer3(renderer) {
      this.renderer = renderer;
    }
    ObjectRenderer3.prototype.flush = function() {
    };
    ObjectRenderer3.prototype.destroy = function() {
      this.renderer = null;
    };
    ObjectRenderer3.prototype.start = function() {
    };
    ObjectRenderer3.prototype.stop = function() {
      this.flush();
    };
    ObjectRenderer3.prototype.render = function(_object) {
    };
    return ObjectRenderer3;
  }()
);
var BatchSystem = (
  /** @class */
  function(_super) {
    __extends(BatchSystem3, _super);
    function BatchSystem3(renderer) {
      var _this = _super.call(this, renderer) || this;
      _this.emptyRenderer = new ObjectRenderer(renderer);
      _this.currentRenderer = _this.emptyRenderer;
      return _this;
    }
    BatchSystem3.prototype.setObjectRenderer = function(objectRenderer) {
      if (this.currentRenderer === objectRenderer) {
        return;
      }
      this.currentRenderer.stop();
      this.currentRenderer = objectRenderer;
      this.currentRenderer.start();
    };
    BatchSystem3.prototype.flush = function() {
      this.setObjectRenderer(this.emptyRenderer);
    };
    BatchSystem3.prototype.reset = function() {
      this.setObjectRenderer(this.emptyRenderer);
    };
    BatchSystem3.prototype.copyBoundTextures = function(arr, maxTextures) {
      var boundTextures = this.renderer.texture.boundTextures;
      for (var i = maxTextures - 1; i >= 0; --i) {
        arr[i] = boundTextures[i] || null;
        if (arr[i]) {
          arr[i]._batchLocation = i;
        }
      }
    };
    BatchSystem3.prototype.boundArray = function(texArray, boundTextures, batchId, maxTextures) {
      var elements = texArray.elements, ids = texArray.ids, count = texArray.count;
      var j2 = 0;
      for (var i = 0; i < count; i++) {
        var tex = elements[i];
        var loc = tex._batchLocation;
        if (loc >= 0 && loc < maxTextures && boundTextures[loc] === tex) {
          ids[i] = loc;
          continue;
        }
        while (j2 < maxTextures) {
          var bound = boundTextures[j2];
          if (bound && bound._batchEnabled === batchId && bound._batchLocation === j2) {
            j2++;
            continue;
          }
          ids[i] = j2;
          tex._batchLocation = j2;
          boundTextures[j2] = tex;
          break;
        }
      }
    };
    return BatchSystem3;
  }(System)
);
var CONTEXT_UID_COUNTER = 0;
var ContextSystem = (
  /** @class */
  function(_super) {
    __extends(ContextSystem3, _super);
    function ContextSystem3(renderer) {
      var _this = _super.call(this, renderer) || this;
      _this.webGLVersion = 1;
      _this.extensions = {};
      _this.supports = {
        uint32Indices: false
      };
      _this.handleContextLost = _this.handleContextLost.bind(_this);
      _this.handleContextRestored = _this.handleContextRestored.bind(_this);
      renderer.view.addEventListener("webglcontextlost", _this.handleContextLost, false);
      renderer.view.addEventListener("webglcontextrestored", _this.handleContextRestored, false);
      return _this;
    }
    Object.defineProperty(ContextSystem3.prototype, "isLost", {
      /**
       * `true` if the context is lost
       * @member {boolean}
       * @readonly
       */
      get: function() {
        return !this.gl || this.gl.isContextLost();
      },
      enumerable: false,
      configurable: true
    });
    ContextSystem3.prototype.contextChange = function(gl) {
      this.gl = gl;
      this.renderer.gl = gl;
      this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++;
      if (gl.isContextLost() && gl.getExtension("WEBGL_lose_context")) {
        gl.getExtension("WEBGL_lose_context").restoreContext();
      }
    };
    ContextSystem3.prototype.initFromContext = function(gl) {
      this.gl = gl;
      this.validateContext(gl);
      this.renderer.gl = gl;
      this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++;
      this.renderer.runners.contextChange.emit(gl);
    };
    ContextSystem3.prototype.initFromOptions = function(options) {
      var gl = this.createContext(this.renderer.view, options);
      this.initFromContext(gl);
    };
    ContextSystem3.prototype.createContext = function(canvas, options) {
      var gl;
      if (settings.PREFER_ENV >= ENV.WEBGL2) {
        gl = canvas.getContext("webgl2", options);
      }
      if (gl) {
        this.webGLVersion = 2;
      } else {
        this.webGLVersion = 1;
        gl = canvas.getContext("webgl", options) || canvas.getContext("experimental-webgl", options);
        if (!gl) {
          throw new Error("This browser does not support WebGL. Try using the canvas renderer");
        }
      }
      this.gl = gl;
      this.getExtensions();
      return this.gl;
    };
    ContextSystem3.prototype.getExtensions = function() {
      var gl = this.gl;
      if (this.webGLVersion === 1) {
        Object.assign(this.extensions, {
          drawBuffers: gl.getExtension("WEBGL_draw_buffers"),
          depthTexture: gl.getExtension("WEBGL_depth_texture"),
          loseContext: gl.getExtension("WEBGL_lose_context"),
          vertexArrayObject: gl.getExtension("OES_vertex_array_object") || gl.getExtension("MOZ_OES_vertex_array_object") || gl.getExtension("WEBKIT_OES_vertex_array_object"),
          anisotropicFiltering: gl.getExtension("EXT_texture_filter_anisotropic"),
          uint32ElementIndex: gl.getExtension("OES_element_index_uint"),
          // Floats and half-floats
          floatTexture: gl.getExtension("OES_texture_float"),
          floatTextureLinear: gl.getExtension("OES_texture_float_linear"),
          textureHalfFloat: gl.getExtension("OES_texture_half_float"),
          textureHalfFloatLinear: gl.getExtension("OES_texture_half_float_linear")
        });
      } else if (this.webGLVersion === 2) {
        Object.assign(this.extensions, {
          anisotropicFiltering: gl.getExtension("EXT_texture_filter_anisotropic"),
          // Floats and half-floats
          colorBufferFloat: gl.getExtension("EXT_color_buffer_float"),
          floatTextureLinear: gl.getExtension("OES_texture_float_linear")
        });
      }
    };
    ContextSystem3.prototype.handleContextLost = function(event) {
      event.preventDefault();
    };
    ContextSystem3.prototype.handleContextRestored = function() {
      this.renderer.runners.contextChange.emit(this.gl);
    };
    ContextSystem3.prototype.destroy = function() {
      var view = this.renderer.view;
      view.removeEventListener("webglcontextlost", this.handleContextLost);
      view.removeEventListener("webglcontextrestored", this.handleContextRestored);
      this.gl.useProgram(null);
      if (this.extensions.loseContext) {
        this.extensions.loseContext.loseContext();
      }
    };
    ContextSystem3.prototype.postrender = function() {
      if (this.renderer.renderingToScreen) {
        this.gl.flush();
      }
    };
    ContextSystem3.prototype.validateContext = function(gl) {
      var attributes = gl.getContextAttributes();
      var isWebGl2 = "WebGL2RenderingContext" in window && gl instanceof window.WebGL2RenderingContext;
      if (isWebGl2) {
        this.webGLVersion = 2;
      }
      if (!attributes.stencil) {
        console.warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
      }
      var hasuint32 = isWebGl2 || !!gl.getExtension("OES_element_index_uint");
      this.supports.uint32Indices = hasuint32;
      if (!hasuint32) {
        console.warn("Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly");
      }
    };
    return ContextSystem3;
  }(System)
);
var GLFramebuffer = (
  /** @class */
  /* @__PURE__ */ function() {
    function GLFramebuffer3(framebuffer) {
      this.framebuffer = framebuffer;
      this.stencil = null;
      this.dirtyId = 0;
      this.dirtyFormat = 0;
      this.dirtySize = 0;
      this.multisample = MSAA_QUALITY.NONE;
      this.msaaBuffer = null;
      this.blitFramebuffer = null;
    }
    return GLFramebuffer3;
  }()
);
var tempRectangle = new Rectangle();
var FramebufferSystem = (
  /** @class */
  function(_super) {
    __extends(FramebufferSystem3, _super);
    function FramebufferSystem3(renderer) {
      var _this = _super.call(this, renderer) || this;
      _this.managedFramebuffers = [];
      _this.unknownFramebuffer = new Framebuffer(10, 10);
      _this.msaaSamples = null;
      return _this;
    }
    FramebufferSystem3.prototype.contextChange = function() {
      var gl = this.gl = this.renderer.gl;
      this.CONTEXT_UID = this.renderer.CONTEXT_UID;
      this.current = this.unknownFramebuffer;
      this.viewport = new Rectangle();
      this.hasMRT = true;
      this.writeDepthTexture = true;
      this.disposeAll(true);
      if (this.renderer.context.webGLVersion === 1) {
        var nativeDrawBuffersExtension_1 = this.renderer.context.extensions.drawBuffers;
        var nativeDepthTextureExtension = this.renderer.context.extensions.depthTexture;
        if (settings.PREFER_ENV === ENV.WEBGL_LEGACY) {
          nativeDrawBuffersExtension_1 = null;
          nativeDepthTextureExtension = null;
        }
        if (nativeDrawBuffersExtension_1) {
          gl.drawBuffers = function(activeTextures) {
            return nativeDrawBuffersExtension_1.drawBuffersWEBGL(activeTextures);
          };
        } else {
          this.hasMRT = false;
          gl.drawBuffers = function() {
          };
        }
        if (!nativeDepthTextureExtension) {
          this.writeDepthTexture = false;
        }
      } else {
        this.msaaSamples = gl.getInternalformatParameter(gl.RENDERBUFFER, gl.RGBA8, gl.SAMPLES);
      }
    };
    FramebufferSystem3.prototype.bind = function(framebuffer, frame) {
      var gl = this.gl;
      if (framebuffer) {
        var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(framebuffer);
        if (this.current !== framebuffer) {
          this.current = framebuffer;
          gl.bindFramebuffer(gl.FRAMEBUFFER, fbo.framebuffer);
        }
        if (fbo.dirtyId !== framebuffer.dirtyId) {
          fbo.dirtyId = framebuffer.dirtyId;
          if (fbo.dirtyFormat !== framebuffer.dirtyFormat) {
            fbo.dirtyFormat = framebuffer.dirtyFormat;
            this.updateFramebuffer(framebuffer);
          } else if (fbo.dirtySize !== framebuffer.dirtySize) {
            fbo.dirtySize = framebuffer.dirtySize;
            this.resizeFramebuffer(framebuffer);
          }
        }
        for (var i = 0; i < framebuffer.colorTextures.length; i++) {
          var tex = framebuffer.colorTextures[i];
          this.renderer.texture.unbind(tex.parentTextureArray || tex);
        }
        if (framebuffer.depthTexture) {
          this.renderer.texture.unbind(framebuffer.depthTexture);
        }
        if (frame) {
          this.setViewport(frame.x, frame.y, frame.width, frame.height);
        } else {
          this.setViewport(0, 0, framebuffer.width, framebuffer.height);
        }
      } else {
        if (this.current) {
          this.current = null;
          gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        }
        if (frame) {
          this.setViewport(frame.x, frame.y, frame.width, frame.height);
        } else {
          this.setViewport(0, 0, this.renderer.width, this.renderer.height);
        }
      }
    };
    FramebufferSystem3.prototype.setViewport = function(x2, y2, width, height) {
      var v2 = this.viewport;
      if (v2.width !== width || v2.height !== height || v2.x !== x2 || v2.y !== y2) {
        v2.x = x2;
        v2.y = y2;
        v2.width = width;
        v2.height = height;
        this.gl.viewport(x2, y2, width, height);
      }
    };
    Object.defineProperty(FramebufferSystem3.prototype, "size", {
      /**
       * Get the size of the current width and height. Returns object with `width` and `height` values.
       *
       * @member {object}
       * @readonly
       */
      get: function() {
        if (this.current) {
          return { x: 0, y: 0, width: this.current.width, height: this.current.height };
        }
        return { x: 0, y: 0, width: this.renderer.width, height: this.renderer.height };
      },
      enumerable: false,
      configurable: true
    });
    FramebufferSystem3.prototype.clear = function(r2, g2, b2, a2, mask) {
      if (mask === void 0) {
        mask = BUFFER_BITS.COLOR | BUFFER_BITS.DEPTH;
      }
      var gl = this.gl;
      gl.clearColor(r2, g2, b2, a2);
      gl.clear(mask);
    };
    FramebufferSystem3.prototype.initFramebuffer = function(framebuffer) {
      var gl = this.gl;
      var fbo = new GLFramebuffer(gl.createFramebuffer());
      fbo.multisample = this.detectSamples(framebuffer.multisample);
      framebuffer.glFramebuffers[this.CONTEXT_UID] = fbo;
      this.managedFramebuffers.push(framebuffer);
      framebuffer.disposeRunner.add(this);
      return fbo;
    };
    FramebufferSystem3.prototype.resizeFramebuffer = function(framebuffer) {
      var gl = this.gl;
      var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
      if (fbo.stencil) {
        gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.stencil);
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, framebuffer.width, framebuffer.height);
      }
      var colorTextures = framebuffer.colorTextures;
      for (var i = 0; i < colorTextures.length; i++) {
        this.renderer.texture.bind(colorTextures[i], 0);
      }
      if (framebuffer.depthTexture) {
        this.renderer.texture.bind(framebuffer.depthTexture, 0);
      }
    };
    FramebufferSystem3.prototype.updateFramebuffer = function(framebuffer) {
      var gl = this.gl;
      var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
      var colorTextures = framebuffer.colorTextures;
      var count = colorTextures.length;
      if (!gl.drawBuffers) {
        count = Math.min(count, 1);
      }
      if (fbo.multisample > 1) {
        fbo.msaaBuffer = gl.createRenderbuffer();
        gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.msaaBuffer);
        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.RGBA8, framebuffer.width, framebuffer.height);
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, fbo.msaaBuffer);
      }
      var activeTextures = [];
      for (var i = 0; i < count; i++) {
        if (i === 0 && fbo.multisample > 1) {
          continue;
        }
        var texture = framebuffer.colorTextures[i];
        var parentTexture = texture.parentTextureArray || texture;
        this.renderer.texture.bind(parentTexture, 0);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, texture.target, parentTexture._glTextures[this.CONTEXT_UID].texture, 0);
        activeTextures.push(gl.COLOR_ATTACHMENT0 + i);
      }
      if (activeTextures.length > 1) {
        gl.drawBuffers(activeTextures);
      }
      if (framebuffer.depthTexture) {
        var writeDepthTexture = this.writeDepthTexture;
        if (writeDepthTexture) {
          var depthTexture = framebuffer.depthTexture;
          this.renderer.texture.bind(depthTexture, 0);
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, depthTexture._glTextures[this.CONTEXT_UID].texture, 0);
        }
      }
      if (!fbo.stencil && (framebuffer.stencil || framebuffer.depth)) {
        fbo.stencil = gl.createRenderbuffer();
        gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.stencil);
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, framebuffer.width, framebuffer.height);
        if (!framebuffer.depthTexture) {
          gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, fbo.stencil);
        }
      }
    };
    FramebufferSystem3.prototype.detectSamples = function(samples) {
      var msaaSamples = this.msaaSamples;
      var res = MSAA_QUALITY.NONE;
      if (samples <= 1 || msaaSamples === null) {
        return res;
      }
      for (var i = 0; i < msaaSamples.length; i++) {
        if (msaaSamples[i] <= samples) {
          res = msaaSamples[i];
          break;
        }
      }
      if (res === 1) {
        res = MSAA_QUALITY.NONE;
      }
      return res;
    };
    FramebufferSystem3.prototype.blit = function(framebuffer, sourcePixels, destPixels) {
      var _a = this, current = _a.current, renderer = _a.renderer, gl = _a.gl, CONTEXT_UID = _a.CONTEXT_UID;
      if (renderer.context.webGLVersion !== 2) {
        return;
      }
      if (!current) {
        return;
      }
      var fbo = current.glFramebuffers[CONTEXT_UID];
      if (!fbo) {
        return;
      }
      if (!framebuffer) {
        if (fbo.multisample <= 1) {
          return;
        }
        if (!fbo.blitFramebuffer) {
          fbo.blitFramebuffer = new Framebuffer(current.width, current.height);
          fbo.blitFramebuffer.addColorTexture(0, current.colorTextures[0]);
        }
        framebuffer = fbo.blitFramebuffer;
        framebuffer.width = current.width;
        framebuffer.height = current.height;
      }
      if (!sourcePixels) {
        sourcePixels = tempRectangle;
        sourcePixels.width = current.width;
        sourcePixels.height = current.height;
      }
      if (!destPixels) {
        destPixels = sourcePixels;
      }
      var sameSize = sourcePixels.width === destPixels.width && sourcePixels.height === destPixels.height;
      this.bind(framebuffer);
      gl.bindFramebuffer(gl.READ_FRAMEBUFFER, fbo.framebuffer);
      gl.blitFramebuffer(sourcePixels.x, sourcePixels.y, sourcePixels.width, sourcePixels.height, destPixels.x, destPixels.y, destPixels.width, destPixels.height, gl.COLOR_BUFFER_BIT, sameSize ? gl.NEAREST : gl.LINEAR);
    };
    FramebufferSystem3.prototype.disposeFramebuffer = function(framebuffer, contextLost) {
      var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
      var gl = this.gl;
      if (!fbo) {
        return;
      }
      delete framebuffer.glFramebuffers[this.CONTEXT_UID];
      var index2 = this.managedFramebuffers.indexOf(framebuffer);
      if (index2 >= 0) {
        this.managedFramebuffers.splice(index2, 1);
      }
      framebuffer.disposeRunner.remove(this);
      if (!contextLost) {
        gl.deleteFramebuffer(fbo.framebuffer);
        if (fbo.stencil) {
          gl.deleteRenderbuffer(fbo.stencil);
        }
      }
    };
    FramebufferSystem3.prototype.disposeAll = function(contextLost) {
      var list = this.managedFramebuffers;
      this.managedFramebuffers = [];
      for (var i = 0; i < list.length; i++) {
        this.disposeFramebuffer(list[i], contextLost);
      }
    };
    FramebufferSystem3.prototype.forceStencil = function() {
      var framebuffer = this.current;
      if (!framebuffer) {
        return;
      }
      var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
      if (!fbo || fbo.stencil) {
        return;
      }
      framebuffer.enableStencil();
      var w2 = framebuffer.width;
      var h2 = framebuffer.height;
      var gl = this.gl;
      var stencil = gl.createRenderbuffer();
      gl.bindRenderbuffer(gl.RENDERBUFFER, stencil);
      gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, w2, h2);
      fbo.stencil = stencil;
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, stencil);
    };
    FramebufferSystem3.prototype.reset = function() {
      this.current = this.unknownFramebuffer;
      this.viewport = new Rectangle();
    };
    return FramebufferSystem3;
  }(System)
);
var GLBuffer = (
  /** @class */
  /* @__PURE__ */ function() {
    function GLBuffer3(buffer) {
      this.buffer = buffer || null;
      this.updateID = -1;
      this.byteLength = -1;
      this.refCount = 0;
    }
    return GLBuffer3;
  }()
);
var byteSizeMap$1 = { 5126: 4, 5123: 2, 5121: 1 };
var GeometrySystem = (
  /** @class */
  function(_super) {
    __extends(GeometrySystem3, _super);
    function GeometrySystem3(renderer) {
      var _this = _super.call(this, renderer) || this;
      _this._activeGeometry = null;
      _this._activeVao = null;
      _this.hasVao = true;
      _this.hasInstance = true;
      _this.canUseUInt32ElementIndex = false;
      _this.managedGeometries = {};
      _this.managedBuffers = {};
      return _this;
    }
    GeometrySystem3.prototype.contextChange = function() {
      this.disposeAll(true);
      var gl = this.gl = this.renderer.gl;
      var context3 = this.renderer.context;
      this.CONTEXT_UID = this.renderer.CONTEXT_UID;
      if (context3.webGLVersion !== 2) {
        var nativeVaoExtension_1 = this.renderer.context.extensions.vertexArrayObject;
        if (settings.PREFER_ENV === ENV.WEBGL_LEGACY) {
          nativeVaoExtension_1 = null;
        }
        if (nativeVaoExtension_1) {
          gl.createVertexArray = function() {
            return nativeVaoExtension_1.createVertexArrayOES();
          };
          gl.bindVertexArray = function(vao) {
            return nativeVaoExtension_1.bindVertexArrayOES(vao);
          };
          gl.deleteVertexArray = function(vao) {
            return nativeVaoExtension_1.deleteVertexArrayOES(vao);
          };
        } else {
          this.hasVao = false;
          gl.createVertexArray = function() {
            return null;
          };
          gl.bindVertexArray = function() {
            return null;
          };
          gl.deleteVertexArray = function() {
            return null;
          };
        }
      }
      if (context3.webGLVersion !== 2) {
        var instanceExt_1 = gl.getExtension("ANGLE_instanced_arrays");
        if (instanceExt_1) {
          gl.vertexAttribDivisor = function(a2, b2) {
            return instanceExt_1.vertexAttribDivisorANGLE(a2, b2);
          };
          gl.drawElementsInstanced = function(a2, b2, c2, d2, e) {
            return instanceExt_1.drawElementsInstancedANGLE(a2, b2, c2, d2, e);
          };
          gl.drawArraysInstanced = function(a2, b2, c2, d2) {
            return instanceExt_1.drawArraysInstancedANGLE(a2, b2, c2, d2);
          };
        } else {
          this.hasInstance = false;
        }
      }
      this.canUseUInt32ElementIndex = context3.webGLVersion === 2 || !!context3.extensions.uint32ElementIndex;
    };
    GeometrySystem3.prototype.bind = function(geometry, shader) {
      shader = shader || this.renderer.shader.shader;
      var gl = this.gl;
      var vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];
      var incRefCount = false;
      if (!vaos) {
        this.managedGeometries[geometry.id] = geometry;
        geometry.disposeRunner.add(this);
        geometry.glVertexArrayObjects[this.CONTEXT_UID] = vaos = {};
        incRefCount = true;
      }
      var vao = vaos[shader.program.id] || this.initGeometryVao(geometry, shader.program, incRefCount);
      this._activeGeometry = geometry;
      if (this._activeVao !== vao) {
        this._activeVao = vao;
        if (this.hasVao) {
          gl.bindVertexArray(vao);
        } else {
          this.activateVao(geometry, shader.program);
        }
      }
      this.updateBuffers();
    };
    GeometrySystem3.prototype.reset = function() {
      this.unbind();
    };
    GeometrySystem3.prototype.updateBuffers = function() {
      var geometry = this._activeGeometry;
      var gl = this.gl;
      for (var i = 0; i < geometry.buffers.length; i++) {
        var buffer = geometry.buffers[i];
        var glBuffer = buffer._glBuffers[this.CONTEXT_UID];
        if (buffer._updateID !== glBuffer.updateID) {
          glBuffer.updateID = buffer._updateID;
          var type = buffer.index ? gl.ELEMENT_ARRAY_BUFFER : gl.ARRAY_BUFFER;
          gl.bindBuffer(type, glBuffer.buffer);
          this._boundBuffer = glBuffer;
          if (glBuffer.byteLength >= buffer.data.byteLength) {
            gl.bufferSubData(type, 0, buffer.data);
          } else {
            var drawType = buffer.static ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW;
            glBuffer.byteLength = buffer.data.byteLength;
            gl.bufferData(type, buffer.data, drawType);
          }
        }
      }
    };
    GeometrySystem3.prototype.checkCompatibility = function(geometry, program) {
      var geometryAttributes = geometry.attributes;
      var shaderAttributes = program.attributeData;
      for (var j2 in shaderAttributes) {
        if (!geometryAttributes[j2]) {
          throw new Error('shader and geometry incompatible, geometry missing the "' + j2 + '" attribute');
        }
      }
    };
    GeometrySystem3.prototype.getSignature = function(geometry, program) {
      var attribs = geometry.attributes;
      var shaderAttributes = program.attributeData;
      var strings = ["g", geometry.id];
      for (var i in attribs) {
        if (shaderAttributes[i]) {
          strings.push(i);
        }
      }
      return strings.join("-");
    };
    GeometrySystem3.prototype.initGeometryVao = function(geometry, program, incRefCount) {
      if (incRefCount === void 0) {
        incRefCount = true;
      }
      this.checkCompatibility(geometry, program);
      var gl = this.gl;
      var CONTEXT_UID = this.CONTEXT_UID;
      var signature = this.getSignature(geometry, program);
      var vaoObjectHash = geometry.glVertexArrayObjects[this.CONTEXT_UID];
      var vao = vaoObjectHash[signature];
      if (vao) {
        vaoObjectHash[program.id] = vao;
        return vao;
      }
      var buffers = geometry.buffers;
      var attributes = geometry.attributes;
      var tempStride = {};
      var tempStart = {};
      for (var j2 in buffers) {
        tempStride[j2] = 0;
        tempStart[j2] = 0;
      }
      for (var j2 in attributes) {
        if (!attributes[j2].size && program.attributeData[j2]) {
          attributes[j2].size = program.attributeData[j2].size;
        } else if (!attributes[j2].size) {
          console.warn("PIXI Geometry attribute '" + j2 + "' size cannot be determined (likely the bound shader does not have the attribute)");
        }
        tempStride[attributes[j2].buffer] += attributes[j2].size * byteSizeMap$1[attributes[j2].type];
      }
      for (var j2 in attributes) {
        var attribute = attributes[j2];
        var attribSize = attribute.size;
        if (attribute.stride === void 0) {
          if (tempStride[attribute.buffer] === attribSize * byteSizeMap$1[attribute.type]) {
            attribute.stride = 0;
          } else {
            attribute.stride = tempStride[attribute.buffer];
          }
        }
        if (attribute.start === void 0) {
          attribute.start = tempStart[attribute.buffer];
          tempStart[attribute.buffer] += attribSize * byteSizeMap$1[attribute.type];
        }
      }
      vao = gl.createVertexArray();
      gl.bindVertexArray(vao);
      for (var i = 0; i < buffers.length; i++) {
        var buffer = buffers[i];
        if (!buffer._glBuffers[CONTEXT_UID]) {
          buffer._glBuffers[CONTEXT_UID] = new GLBuffer(gl.createBuffer());
          this.managedBuffers[buffer.id] = buffer;
          buffer.disposeRunner.add(this);
        }
        if (incRefCount) {
          buffer._glBuffers[CONTEXT_UID].refCount++;
        }
      }
      this.activateVao(geometry, program);
      this._activeVao = vao;
      vaoObjectHash[program.id] = vao;
      vaoObjectHash[signature] = vao;
      return vao;
    };
    GeometrySystem3.prototype.disposeBuffer = function(buffer, contextLost) {
      if (!this.managedBuffers[buffer.id]) {
        return;
      }
      delete this.managedBuffers[buffer.id];
      var glBuffer = buffer._glBuffers[this.CONTEXT_UID];
      var gl = this.gl;
      buffer.disposeRunner.remove(this);
      if (!glBuffer) {
        return;
      }
      if (!contextLost) {
        gl.deleteBuffer(glBuffer.buffer);
      }
      delete buffer._glBuffers[this.CONTEXT_UID];
    };
    GeometrySystem3.prototype.disposeGeometry = function(geometry, contextLost) {
      if (!this.managedGeometries[geometry.id]) {
        return;
      }
      delete this.managedGeometries[geometry.id];
      var vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];
      var gl = this.gl;
      var buffers = geometry.buffers;
      geometry.disposeRunner.remove(this);
      if (!vaos) {
        return;
      }
      for (var i = 0; i < buffers.length; i++) {
        var buf = buffers[i]._glBuffers[this.CONTEXT_UID];
        buf.refCount--;
        if (buf.refCount === 0 && !contextLost) {
          this.disposeBuffer(buffers[i], contextLost);
        }
      }
      if (!contextLost) {
        for (var vaoId in vaos) {
          if (vaoId[0] === "g") {
            var vao = vaos[vaoId];
            if (this._activeVao === vao) {
              this.unbind();
            }
            gl.deleteVertexArray(vao);
          }
        }
      }
      delete geometry.glVertexArrayObjects[this.CONTEXT_UID];
    };
    GeometrySystem3.prototype.disposeAll = function(contextLost) {
      var all = Object.keys(this.managedGeometries);
      for (var i = 0; i < all.length; i++) {
        this.disposeGeometry(this.managedGeometries[all[i]], contextLost);
      }
      all = Object.keys(this.managedBuffers);
      for (var i = 0; i < all.length; i++) {
        this.disposeBuffer(this.managedBuffers[all[i]], contextLost);
      }
    };
    GeometrySystem3.prototype.activateVao = function(geometry, program) {
      var gl = this.gl;
      var CONTEXT_UID = this.CONTEXT_UID;
      var buffers = geometry.buffers;
      var attributes = geometry.attributes;
      if (geometry.indexBuffer) {
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, geometry.indexBuffer._glBuffers[CONTEXT_UID].buffer);
      }
      var lastBuffer = null;
      for (var j2 in attributes) {
        var attribute = attributes[j2];
        var buffer = buffers[attribute.buffer];
        var glBuffer = buffer._glBuffers[CONTEXT_UID];
        if (program.attributeData[j2]) {
          if (lastBuffer !== glBuffer) {
            gl.bindBuffer(gl.ARRAY_BUFFER, glBuffer.buffer);
            lastBuffer = glBuffer;
          }
          var location = program.attributeData[j2].location;
          gl.enableVertexAttribArray(location);
          gl.vertexAttribPointer(location, attribute.size, attribute.type || gl.FLOAT, attribute.normalized, attribute.stride, attribute.start);
          if (attribute.instance) {
            if (this.hasInstance) {
              gl.vertexAttribDivisor(location, 1);
            } else {
              throw new Error("geometry error, GPU Instancing is not supported on this device");
            }
          }
        }
      }
    };
    GeometrySystem3.prototype.draw = function(type, size, start, instanceCount) {
      var gl = this.gl;
      var geometry = this._activeGeometry;
      if (geometry.indexBuffer) {
        var byteSize = geometry.indexBuffer.data.BYTES_PER_ELEMENT;
        var glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;
        if (byteSize === 2 || byteSize === 4 && this.canUseUInt32ElementIndex) {
          if (geometry.instanced) {
            gl.drawElementsInstanced(type, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize, instanceCount || 1);
          } else {
            gl.drawElements(type, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize);
          }
        } else {
          console.warn("unsupported index buffer type: uint32");
        }
      } else if (geometry.instanced) {
        gl.drawArraysInstanced(type, start, size || geometry.getSize(), instanceCount || 1);
      } else {
        gl.drawArrays(type, start, size || geometry.getSize());
      }
      return this;
    };
    GeometrySystem3.prototype.unbind = function() {
      this.gl.bindVertexArray(null);
      this._activeVao = null;
      this._activeGeometry = null;
    };
    return GeometrySystem3;
  }(System)
);
var MaskData = (
  /** @class */
  function() {
    function MaskData3(maskObject) {
      if (maskObject === void 0) {
        maskObject = null;
      }
      this.type = MASK_TYPES.NONE;
      this.autoDetect = true;
      this.maskObject = maskObject || null;
      this.pooled = false;
      this.isMaskData = true;
      this._stencilCounter = 0;
      this._scissorCounter = 0;
      this._scissorRect = null;
      this._target = null;
    }
    MaskData3.prototype.reset = function() {
      if (this.pooled) {
        this.maskObject = null;
        this.type = MASK_TYPES.NONE;
        this.autoDetect = true;
      }
      this._target = null;
    };
    MaskData3.prototype.copyCountersOrReset = function(maskAbove) {
      if (maskAbove) {
        this._stencilCounter = maskAbove._stencilCounter;
        this._scissorCounter = maskAbove._scissorCounter;
        this._scissorRect = maskAbove._scissorRect;
      } else {
        this._stencilCounter = 0;
        this._scissorCounter = 0;
        this._scissorRect = null;
      }
    };
    return MaskData3;
  }()
);
function compileShader(gl, type, src) {
  var shader = gl.createShader(type);
  gl.shaderSource(shader, src);
  gl.compileShader(shader);
  return shader;
}
function compileProgram(gl, vertexSrc, fragmentSrc, attributeLocations) {
  var glVertShader = compileShader(gl, gl.VERTEX_SHADER, vertexSrc);
  var glFragShader = compileShader(gl, gl.FRAGMENT_SHADER, fragmentSrc);
  var program = gl.createProgram();
  gl.attachShader(program, glVertShader);
  gl.attachShader(program, glFragShader);
  if (attributeLocations) {
    for (var i in attributeLocations) {
      gl.bindAttribLocation(program, attributeLocations[i], i);
    }
  }
  gl.linkProgram(program);
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    if (!gl.getShaderParameter(glVertShader, gl.COMPILE_STATUS)) {
      console.warn(vertexSrc);
      console.error(gl.getShaderInfoLog(glVertShader));
    }
    if (!gl.getShaderParameter(glFragShader, gl.COMPILE_STATUS)) {
      console.warn(fragmentSrc);
      console.error(gl.getShaderInfoLog(glFragShader));
    }
    console.error("Pixi.js Error: Could not initialize shader.");
    console.error("gl.VALIDATE_STATUS", gl.getProgramParameter(program, gl.VALIDATE_STATUS));
    console.error("gl.getError()", gl.getError());
    if (gl.getProgramInfoLog(program) !== "") {
      console.warn("Pixi.js Warning: gl.getProgramInfoLog()", gl.getProgramInfoLog(program));
    }
    gl.deleteProgram(program);
    program = null;
  }
  gl.deleteShader(glVertShader);
  gl.deleteShader(glFragShader);
  return program;
}
function booleanArray(size) {
  var array = new Array(size);
  for (var i = 0; i < array.length; i++) {
    array[i] = false;
  }
  return array;
}
function defaultValue(type, size) {
  switch (type) {
    case "float":
      return 0;
    case "vec2":
      return new Float32Array(2 * size);
    case "vec3":
      return new Float32Array(3 * size);
    case "vec4":
      return new Float32Array(4 * size);
    case "int":
    case "sampler2D":
    case "sampler2DArray":
      return 0;
    case "ivec2":
      return new Int32Array(2 * size);
    case "ivec3":
      return new Int32Array(3 * size);
    case "ivec4":
      return new Int32Array(4 * size);
    case "bool":
      return false;
    case "bvec2":
      return booleanArray(2 * size);
    case "bvec3":
      return booleanArray(3 * size);
    case "bvec4":
      return booleanArray(4 * size);
    case "mat2":
      return new Float32Array([
        1,
        0,
        0,
        1
      ]);
    case "mat3":
      return new Float32Array([
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      ]);
    case "mat4":
      return new Float32Array([
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ]);
  }
  return null;
}
var unknownContext = {};
var context = unknownContext;
function getTestContext() {
  if (context === unknownContext || context && context.isContextLost()) {
    var canvas = document.createElement("canvas");
    var gl = void 0;
    if (settings.PREFER_ENV >= ENV.WEBGL2) {
      gl = canvas.getContext("webgl2", {});
    }
    if (!gl) {
      gl = canvas.getContext("webgl", {}) || canvas.getContext("experimental-webgl", {});
      if (!gl) {
        gl = null;
      } else {
        gl.getExtension("WEBGL_draw_buffers");
      }
    }
    context = gl;
  }
  return context;
}
var maxFragmentPrecision;
function getMaxFragmentPrecision() {
  if (!maxFragmentPrecision) {
    maxFragmentPrecision = PRECISION.MEDIUM;
    var gl = getTestContext();
    if (gl) {
      if (gl.getShaderPrecisionFormat) {
        var shaderFragment = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);
        maxFragmentPrecision = shaderFragment.precision ? PRECISION.HIGH : PRECISION.MEDIUM;
      }
    }
  }
  return maxFragmentPrecision;
}
function setPrecision(src, requestedPrecision, maxSupportedPrecision) {
  if (src.substring(0, 9) !== "precision") {
    var precision = requestedPrecision;
    if (requestedPrecision === PRECISION.HIGH && maxSupportedPrecision !== PRECISION.HIGH) {
      precision = PRECISION.MEDIUM;
    }
    return "precision " + precision + " float;\n" + src;
  } else if (maxSupportedPrecision !== PRECISION.HIGH && src.substring(0, 15) === "precision highp") {
    return src.replace("precision highp", "precision mediump");
  }
  return src;
}
var GLSL_TO_SIZE = {
  float: 1,
  vec2: 2,
  vec3: 3,
  vec4: 4,
  int: 1,
  ivec2: 2,
  ivec3: 3,
  ivec4: 4,
  bool: 1,
  bvec2: 2,
  bvec3: 3,
  bvec4: 4,
  mat2: 4,
  mat3: 9,
  mat4: 16,
  sampler2D: 1
};
function mapSize(type) {
  return GLSL_TO_SIZE[type];
}
var GL_TABLE = null;
var GL_TO_GLSL_TYPES = {
  FLOAT: "float",
  FLOAT_VEC2: "vec2",
  FLOAT_VEC3: "vec3",
  FLOAT_VEC4: "vec4",
  INT: "int",
  INT_VEC2: "ivec2",
  INT_VEC3: "ivec3",
  INT_VEC4: "ivec4",
  BOOL: "bool",
  BOOL_VEC2: "bvec2",
  BOOL_VEC3: "bvec3",
  BOOL_VEC4: "bvec4",
  FLOAT_MAT2: "mat2",
  FLOAT_MAT3: "mat3",
  FLOAT_MAT4: "mat4",
  SAMPLER_2D: "sampler2D",
  INT_SAMPLER_2D: "sampler2D",
  UNSIGNED_INT_SAMPLER_2D: "sampler2D",
  SAMPLER_CUBE: "samplerCube",
  INT_SAMPLER_CUBE: "samplerCube",
  UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
  SAMPLER_2D_ARRAY: "sampler2DArray",
  INT_SAMPLER_2D_ARRAY: "sampler2DArray",
  UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"
};
function mapType(gl, type) {
  if (!GL_TABLE) {
    var typeNames = Object.keys(GL_TO_GLSL_TYPES);
    GL_TABLE = {};
    for (var i = 0; i < typeNames.length; ++i) {
      var tn = typeNames[i];
      GL_TABLE[gl[tn]] = GL_TO_GLSL_TYPES[tn];
    }
  }
  return GL_TABLE[type];
}
var uniformParsers = [
  // a float cache layer
  {
    test: function(data) {
      return data.type === "float" && data.size === 1;
    },
    code: function(name) {
      return '\n            if(uv["' + name + '"] !== ud["' + name + '"].value)\n            {\n                ud["' + name + '"].value = uv["' + name + '"]\n                gl.uniform1f(ud["' + name + '"].location, uv["' + name + '"])\n            }\n            ';
    }
  },
  // handling samplers
  {
    test: function(data) {
      return (data.type === "sampler2D" || data.type === "samplerCube" || data.type === "sampler2DArray") && data.size === 1 && !data.isArray;
    },
    code: function(name) {
      return 't = syncData.textureCount++;\n\n            renderer.texture.bind(uv["' + name + '"], t);\n\n            if(ud["' + name + '"].value !== t)\n            {\n                ud["' + name + '"].value = t;\n                gl.uniform1i(ud["' + name + '"].location, t);\n; // eslint-disable-line max-len\n            }';
    }
  },
  // uploading pixi matrix object to mat3
  {
    test: function(data, uniform) {
      return data.type === "mat3" && data.size === 1 && uniform.a !== void 0;
    },
    code: function(name) {
      return '\n            gl.uniformMatrix3fv(ud["' + name + '"].location, false, uv["' + name + '"].toArray(true));\n            ';
    }
  },
  // uploading a pixi point as a vec2 with caching layer
  {
    test: function(data, uniform) {
      return data.type === "vec2" && data.size === 1 && uniform.x !== void 0;
    },
    code: function(name) {
      return '\n                cv = ud["' + name + '"].value;\n                v = uv["' + name + '"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    gl.uniform2f(ud["' + name + '"].location, v.x, v.y);\n                }';
    }
  },
  // caching layer for a vec2
  {
    test: function(data) {
      return data.type === "vec2" && data.size === 1;
    },
    code: function(name) {
      return '\n                cv = ud["' + name + '"].value;\n                v = uv["' + name + '"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    gl.uniform2f(ud["' + name + '"].location, v[0], v[1]);\n                }\n            ';
    }
  },
  // upload a pixi rectangle as a vec4 with caching layer
  {
    test: function(data, uniform) {
      return data.type === "vec4" && data.size === 1 && uniform.width !== void 0;
    },
    code: function(name) {
      return '\n                cv = ud["' + name + '"].value;\n                v = uv["' + name + '"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    cv[2] = v.width;\n                    cv[3] = v.height;\n                    gl.uniform4f(ud["' + name + '"].location, v.x, v.y, v.width, v.height)\n                }';
    }
  },
  // a caching layer for vec4 uploading
  {
    test: function(data) {
      return data.type === "vec4" && data.size === 1;
    },
    code: function(name) {
      return '\n                cv = ud["' + name + '"].value;\n                v = uv["' + name + '"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    cv[2] = v[2];\n                    cv[3] = v[3];\n\n                    gl.uniform4f(ud["' + name + '"].location, v[0], v[1], v[2], v[3])\n                }';
    }
  }
];
var GLSL_TO_SINGLE_SETTERS_CACHED = {
  float: "\n    if(cv !== v)\n    {\n        cv.v = v;\n        gl.uniform1f(location, v)\n    }",
  vec2: "\n    if(cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        gl.uniform2f(location, v[0], v[1])\n    }",
  vec3: "\n    if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3f(location, v[0], v[1], v[2])\n    }",
  vec4: "gl.uniform4f(location, v[0], v[1], v[2], v[3])",
  int: "gl.uniform1i(location, v)",
  ivec2: "gl.uniform2i(location, v[0], v[1])",
  ivec3: "gl.uniform3i(location, v[0], v[1], v[2])",
  ivec4: "gl.uniform4i(location, v[0], v[1], v[2], v[3])",
  bool: "gl.uniform1i(location, v)",
  bvec2: "gl.uniform2i(location, v[0], v[1])",
  bvec3: "gl.uniform3i(location, v[0], v[1], v[2])",
  bvec4: "gl.uniform4i(location, v[0], v[1], v[2], v[3])",
  mat2: "gl.uniformMatrix2fv(location, false, v)",
  mat3: "gl.uniformMatrix3fv(location, false, v)",
  mat4: "gl.uniformMatrix4fv(location, false, v)",
  sampler2D: "gl.uniform1i(location, v)",
  samplerCube: "gl.uniform1i(location, v)",
  sampler2DArray: "gl.uniform1i(location, v)"
};
var GLSL_TO_ARRAY_SETTERS = {
  float: "gl.uniform1fv(location, v)",
  vec2: "gl.uniform2fv(location, v)",
  vec3: "gl.uniform3fv(location, v)",
  vec4: "gl.uniform4fv(location, v)",
  mat4: "gl.uniformMatrix4fv(location, false, v)",
  mat3: "gl.uniformMatrix3fv(location, false, v)",
  mat2: "gl.uniformMatrix2fv(location, false, v)",
  int: "gl.uniform1iv(location, v)",
  ivec2: "gl.uniform2iv(location, v)",
  ivec3: "gl.uniform3iv(location, v)",
  ivec4: "gl.uniform4iv(location, v)",
  bool: "gl.uniform1iv(location, v)",
  bvec2: "gl.uniform2iv(location, v)",
  bvec3: "gl.uniform3iv(location, v)",
  bvec4: "gl.uniform4iv(location, v)",
  sampler2D: "gl.uniform1iv(location, v)",
  samplerCube: "gl.uniform1iv(location, v)",
  sampler2DArray: "gl.uniform1iv(location, v)"
};
function generateUniformsSync(group, uniformData) {
  var funcFragments = ["\n        var v = null;\n        var cv = null\n        var t = 0;\n        var gl = renderer.gl\n    "];
  for (var i in group.uniforms) {
    var data = uniformData[i];
    if (!data) {
      if (group.uniforms[i].group) {
        funcFragments.push('\n                    renderer.shader.syncUniformGroup(uv["' + i + '"], syncData);\n                ');
      }
      continue;
    }
    var uniform = group.uniforms[i];
    var parsed = false;
    for (var j2 = 0; j2 < uniformParsers.length; j2++) {
      if (uniformParsers[j2].test(data, uniform)) {
        funcFragments.push(uniformParsers[j2].code(i, uniform));
        parsed = true;
        break;
      }
    }
    if (!parsed) {
      var templateType = data.size === 1 ? GLSL_TO_SINGLE_SETTERS_CACHED : GLSL_TO_ARRAY_SETTERS;
      var template = templateType[data.type].replace("location", 'ud["' + i + '"].location');
      funcFragments.push('\n            cv = ud["' + i + '"].value;\n            v = uv["' + i + '"];\n            ' + template + ";");
    }
  }
  return new Function("ud", "uv", "renderer", "syncData", funcFragments.join("\n"));
}
var fragTemplate = [
  "precision mediump float;",
  "void main(void){",
  "float test = 0.1;",
  "%forloop%",
  "gl_FragColor = vec4(0.0);",
  "}"
].join("\n");
function generateIfTestSrc(maxIfs) {
  var src = "";
  for (var i = 0; i < maxIfs; ++i) {
    if (i > 0) {
      src += "\nelse ";
    }
    if (i < maxIfs - 1) {
      src += "if(test == " + i + ".0){}";
    }
  }
  return src;
}
function checkMaxIfStatementsInShader(maxIfs, gl) {
  if (maxIfs === 0) {
    throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
  }
  var shader = gl.createShader(gl.FRAGMENT_SHADER);
  while (true) {
    var fragmentSrc = fragTemplate.replace(/%forloop%/gi, generateIfTestSrc(maxIfs));
    gl.shaderSource(shader, fragmentSrc);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      maxIfs = maxIfs / 2 | 0;
    } else {
      break;
    }
  }
  return maxIfs;
}
var unsafeEval;
function unsafeEvalSupported() {
  if (typeof unsafeEval === "boolean") {
    return unsafeEval;
  }
  try {
    var func = new Function("param1", "param2", "param3", "return param1[param2] === param3;");
    unsafeEval = func({ a: "b" }, "a", "b") === true;
  } catch (e) {
    unsafeEval = false;
  }
  return unsafeEval;
}
var defaultFragment = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor *= texture2D(uSampler, vTextureCoord);\n}";
var defaultVertex = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void){\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n   vTextureCoord = aTextureCoord;\n}\n";
var UID$3 = 0;
var nameCache = {};
var Program = (
  /** @class */
  function() {
    function Program3(vertexSrc, fragmentSrc, name) {
      if (name === void 0) {
        name = "pixi-shader";
      }
      this.id = UID$3++;
      this.vertexSrc = vertexSrc || Program3.defaultVertexSrc;
      this.fragmentSrc = fragmentSrc || Program3.defaultFragmentSrc;
      this.vertexSrc = this.vertexSrc.trim();
      this.fragmentSrc = this.fragmentSrc.trim();
      if (this.vertexSrc.substring(0, 8) !== "#version") {
        name = name.replace(/\s+/g, "-");
        if (nameCache[name]) {
          nameCache[name]++;
          name += "-" + nameCache[name];
        } else {
          nameCache[name] = 1;
        }
        this.vertexSrc = "#define SHADER_NAME " + name + "\n" + this.vertexSrc;
        this.fragmentSrc = "#define SHADER_NAME " + name + "\n" + this.fragmentSrc;
        this.vertexSrc = setPrecision(this.vertexSrc, settings.PRECISION_VERTEX, PRECISION.HIGH);
        this.fragmentSrc = setPrecision(this.fragmentSrc, settings.PRECISION_FRAGMENT, getMaxFragmentPrecision());
      }
      this.extractData(this.vertexSrc, this.fragmentSrc);
      this.glPrograms = {};
      this.syncUniforms = null;
    }
    Program3.prototype.extractData = function(vertexSrc, fragmentSrc) {
      var gl = getTestContext();
      if (gl) {
        var program = compileProgram(gl, vertexSrc, fragmentSrc);
        this.attributeData = this.getAttributeData(program, gl);
        this.uniformData = this.getUniformData(program, gl);
        gl.deleteProgram(program);
      } else {
        this.uniformData = {};
        this.attributeData = {};
      }
    };
    Program3.prototype.getAttributeData = function(program, gl) {
      var attributes = {};
      var attributesArray = [];
      var totalAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
      for (var i = 0; i < totalAttributes; i++) {
        var attribData = gl.getActiveAttrib(program, i);
        var type = mapType(gl, attribData.type);
        var data = {
          type,
          name: attribData.name,
          size: mapSize(type),
          location: 0
        };
        attributes[attribData.name] = data;
        attributesArray.push(data);
      }
      attributesArray.sort(function(a2, b2) {
        return a2.name > b2.name ? 1 : -1;
      });
      for (var i = 0; i < attributesArray.length; i++) {
        attributesArray[i].location = i;
      }
      return attributes;
    };
    Program3.prototype.getUniformData = function(program, gl) {
      var uniforms = {};
      var totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
      for (var i = 0; i < totalUniforms; i++) {
        var uniformData = gl.getActiveUniform(program, i);
        var name = uniformData.name.replace(/\[.*?\]$/, "");
        var isArray = uniformData.name.match(/\[.*?\]$/);
        var type = mapType(gl, uniformData.type);
        uniforms[name] = {
          type,
          size: uniformData.size,
          isArray,
          value: defaultValue(type, uniformData.size)
        };
      }
      return uniforms;
    };
    Object.defineProperty(Program3, "defaultVertexSrc", {
      /**
       * The default vertex shader source
       *
       * @static
       * @constant
       * @member {string}
       */
      get: function() {
        return defaultVertex;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Program3, "defaultFragmentSrc", {
      /**
       * The default fragment shader source
       *
       * @static
       * @constant
       * @member {string}
       */
      get: function() {
        return defaultFragment;
      },
      enumerable: false,
      configurable: true
    });
    Program3.from = function(vertexSrc, fragmentSrc, name) {
      var key = vertexSrc + fragmentSrc;
      var program = ProgramCache[key];
      if (!program) {
        ProgramCache[key] = program = new Program3(vertexSrc, fragmentSrc, name);
      }
      return program;
    };
    return Program3;
  }()
);
var Shader = (
  /** @class */
  function() {
    function Shader3(program, uniforms) {
      this.program = program;
      if (uniforms) {
        if (uniforms instanceof UniformGroup) {
          this.uniformGroup = uniforms;
        } else {
          this.uniformGroup = new UniformGroup(uniforms);
        }
      } else {
        this.uniformGroup = new UniformGroup({});
      }
      for (var i in program.uniformData) {
        if (this.uniformGroup.uniforms[i] instanceof Array) {
          this.uniformGroup.uniforms[i] = new Float32Array(this.uniformGroup.uniforms[i]);
        }
      }
    }
    Shader3.prototype.checkUniformExists = function(name, group) {
      if (group.uniforms[name]) {
        return true;
      }
      for (var i in group.uniforms) {
        var uniform = group.uniforms[i];
        if (uniform.group) {
          if (this.checkUniformExists(name, uniform)) {
            return true;
          }
        }
      }
      return false;
    };
    Shader3.prototype.destroy = function() {
      this.uniformGroup = null;
    };
    Object.defineProperty(Shader3.prototype, "uniforms", {
      /**
       * Shader uniform values, shortcut for `uniformGroup.uniforms`
       * @readonly
       * @member {object}
       */
      get: function() {
        return this.uniformGroup.uniforms;
      },
      enumerable: false,
      configurable: true
    });
    Shader3.from = function(vertexSrc, fragmentSrc, uniforms) {
      var program = Program.from(vertexSrc, fragmentSrc);
      return new Shader3(program, uniforms);
    };
    return Shader3;
  }()
);
var BLEND = 0;
var OFFSET = 1;
var CULLING = 2;
var DEPTH_TEST = 3;
var WINDING = 4;
var State = (
  /** @class */
  function() {
    function State3() {
      this.data = 0;
      this.blendMode = BLEND_MODES.NORMAL;
      this.polygonOffset = 0;
      this.blend = true;
    }
    Object.defineProperty(State3.prototype, "blend", {
      /**
       * Activates blending of the computed fragment color values
       *
       * @member {boolean}
       */
      get: function() {
        return !!(this.data & 1 << BLEND);
      },
      set: function(value) {
        if (!!(this.data & 1 << BLEND) !== value) {
          this.data ^= 1 << BLEND;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(State3.prototype, "offsets", {
      /**
       * Activates adding an offset to depth values of polygon's fragments
       *
       * @member {boolean}
       * @default false
       */
      get: function() {
        return !!(this.data & 1 << OFFSET);
      },
      set: function(value) {
        if (!!(this.data & 1 << OFFSET) !== value) {
          this.data ^= 1 << OFFSET;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(State3.prototype, "culling", {
      /**
       * Activates culling of polygons.
       *
       * @member {boolean}
       * @default false
       */
      get: function() {
        return !!(this.data & 1 << CULLING);
      },
      set: function(value) {
        if (!!(this.data & 1 << CULLING) !== value) {
          this.data ^= 1 << CULLING;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(State3.prototype, "depthTest", {
      /**
       * Activates depth comparisons and updates to the depth buffer.
       *
       * @member {boolean}
       * @default false
       */
      get: function() {
        return !!(this.data & 1 << DEPTH_TEST);
      },
      set: function(value) {
        if (!!(this.data & 1 << DEPTH_TEST) !== value) {
          this.data ^= 1 << DEPTH_TEST;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(State3.prototype, "clockwiseFrontFace", {
      /**
       * Specifies whether or not front or back-facing polygons can be culled.
       * @member {boolean}
       * @default false
       */
      get: function() {
        return !!(this.data & 1 << WINDING);
      },
      set: function(value) {
        if (!!(this.data & 1 << WINDING) !== value) {
          this.data ^= 1 << WINDING;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(State3.prototype, "blendMode", {
      /**
       * The blend mode to be applied when this state is set. Apply a value of `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.
       * Setting this mode to anything other than NO_BLEND will automatically switch blending on.
       *
       * @member {number}
       * @default PIXI.BLEND_MODES.NORMAL
       * @see PIXI.BLEND_MODES
       */
      get: function() {
        return this._blendMode;
      },
      set: function(value) {
        this.blend = value !== BLEND_MODES.NONE;
        this._blendMode = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(State3.prototype, "polygonOffset", {
      /**
       * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.
       *
       * @member {number}
       * @default 0
       */
      get: function() {
        return this._polygonOffset;
      },
      set: function(value) {
        this.offsets = !!value;
        this._polygonOffset = value;
      },
      enumerable: false,
      configurable: true
    });
    State3.for2d = function() {
      var state = new State3();
      state.depthTest = false;
      state.blend = true;
      return state;
    };
    return State3;
  }()
);
var defaultVertex$1 = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n";
var defaultFragment$1 = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor = texture2D(uSampler, vTextureCoord);\n}\n";
var Filter = (
  /** @class */
  function(_super) {
    __extends(Filter3, _super);
    function Filter3(vertexSrc, fragmentSrc, uniforms) {
      var _this = this;
      var program = Program.from(vertexSrc || Filter3.defaultVertexSrc, fragmentSrc || Filter3.defaultFragmentSrc);
      _this = _super.call(this, program, uniforms) || this;
      _this.padding = 0;
      _this.resolution = settings.FILTER_RESOLUTION;
      _this.enabled = true;
      _this.autoFit = true;
      _this.legacy = !!_this.program.attributeData.aTextureCoord;
      _this.state = new State();
      return _this;
    }
    Filter3.prototype.apply = function(filterManager, input, output, clearMode, _currentState) {
      filterManager.applyFilter(this, input, output, clearMode);
    };
    Object.defineProperty(Filter3.prototype, "blendMode", {
      /**
       * Sets the blendmode of the filter
       *
       * @member {number}
       * @default PIXI.BLEND_MODES.NORMAL
       */
      get: function() {
        return this.state.blendMode;
      },
      set: function(value) {
        this.state.blendMode = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Filter3, "defaultVertexSrc", {
      /**
       * The default vertex shader source
       *
       * @static
       * @type {string}
       * @constant
       */
      get: function() {
        return defaultVertex$1;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Filter3, "defaultFragmentSrc", {
      /**
       * The default fragment shader source
       *
       * @static
       * @type {string}
       * @constant
       */
      get: function() {
        return defaultFragment$1;
      },
      enumerable: false,
      configurable: true
    });
    return Filter3;
  }(Shader)
);
var vertex = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 otherMatrix;\n\nvarying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n}\n";
var fragment = "varying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform sampler2D mask;\nuniform float alpha;\nuniform float npmAlpha;\nuniform vec4 maskClamp;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(maskClamp.x, vMaskCoord.x) +\n        step(maskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, maskClamp.z) +\n        step(vMaskCoord.y, maskClamp.w));\n\n    vec4 original = texture2D(uSampler, vTextureCoord);\n    vec4 masky = texture2D(mask, vMaskCoord);\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\n\n    original *= (alphaMul * masky.r * alpha * clip);\n\n    gl_FragColor = original;\n}\n";
var tempMat = new Matrix();
var TextureMatrix = (
  /** @class */
  function() {
    function TextureMatrix3(texture, clampMargin) {
      this._texture = texture;
      this.mapCoord = new Matrix();
      this.uClampFrame = new Float32Array(4);
      this.uClampOffset = new Float32Array(2);
      this._textureID = -1;
      this._updateID = 0;
      this.clampOffset = 0;
      this.clampMargin = typeof clampMargin === "undefined" ? 0.5 : clampMargin;
      this.isSimple = false;
    }
    Object.defineProperty(TextureMatrix3.prototype, "texture", {
      /**
       * texture property
       * @member {PIXI.Texture}
       */
      get: function() {
        return this._texture;
      },
      set: function(value) {
        this._texture = value;
        this._textureID = -1;
      },
      enumerable: false,
      configurable: true
    });
    TextureMatrix3.prototype.multiplyUvs = function(uvs, out) {
      if (out === void 0) {
        out = uvs;
      }
      var mat = this.mapCoord;
      for (var i = 0; i < uvs.length; i += 2) {
        var x2 = uvs[i];
        var y2 = uvs[i + 1];
        out[i] = x2 * mat.a + y2 * mat.c + mat.tx;
        out[i + 1] = x2 * mat.b + y2 * mat.d + mat.ty;
      }
      return out;
    };
    TextureMatrix3.prototype.update = function(forceUpdate) {
      var tex = this._texture;
      if (!tex || !tex.valid) {
        return false;
      }
      if (!forceUpdate && this._textureID === tex._updateID) {
        return false;
      }
      this._textureID = tex._updateID;
      this._updateID++;
      var uvs = tex._uvs;
      this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);
      var orig = tex.orig;
      var trim = tex.trim;
      if (trim) {
        tempMat.set(orig.width / trim.width, 0, 0, orig.height / trim.height, -trim.x / trim.width, -trim.y / trim.height);
        this.mapCoord.append(tempMat);
      }
      var texBase = tex.baseTexture;
      var frame = this.uClampFrame;
      var margin = this.clampMargin / texBase.resolution;
      var offset = this.clampOffset;
      frame[0] = (tex._frame.x + margin + offset) / texBase.width;
      frame[1] = (tex._frame.y + margin + offset) / texBase.height;
      frame[2] = (tex._frame.x + tex._frame.width - margin + offset) / texBase.width;
      frame[3] = (tex._frame.y + tex._frame.height - margin + offset) / texBase.height;
      this.uClampOffset[0] = offset / texBase.realWidth;
      this.uClampOffset[1] = offset / texBase.realHeight;
      this.isSimple = tex._frame.width === texBase.width && tex._frame.height === texBase.height && tex.rotate === 0;
      return true;
    };
    return TextureMatrix3;
  }()
);
var SpriteMaskFilter = (
  /** @class */
  function(_super) {
    __extends(SpriteMaskFilter3, _super);
    function SpriteMaskFilter3(sprite) {
      var _this = this;
      var maskMatrix = new Matrix();
      _this = _super.call(this, vertex, fragment) || this;
      sprite.renderable = false;
      _this.maskSprite = sprite;
      _this.maskMatrix = maskMatrix;
      return _this;
    }
    SpriteMaskFilter3.prototype.apply = function(filterManager, input, output, clearMode) {
      var maskSprite = this.maskSprite;
      var tex = maskSprite._texture;
      if (!tex.valid) {
        return;
      }
      if (!tex.uvMatrix) {
        tex.uvMatrix = new TextureMatrix(tex, 0);
      }
      tex.uvMatrix.update();
      this.uniforms.npmAlpha = tex.baseTexture.alphaMode ? 0 : 1;
      this.uniforms.mask = tex;
      this.uniforms.otherMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, maskSprite).prepend(tex.uvMatrix.mapCoord);
      this.uniforms.alpha = maskSprite.worldAlpha;
      this.uniforms.maskClamp = tex.uvMatrix.uClampFrame;
      filterManager.applyFilter(this, input, output, clearMode);
    };
    return SpriteMaskFilter3;
  }(Filter)
);
var MaskSystem = (
  /** @class */
  function(_super) {
    __extends(MaskSystem3, _super);
    function MaskSystem3(renderer) {
      var _this = _super.call(this, renderer) || this;
      _this.enableScissor = false;
      _this.alphaMaskPool = [];
      _this.maskDataPool = [];
      _this.maskStack = [];
      _this.alphaMaskIndex = 0;
      return _this;
    }
    MaskSystem3.prototype.setMaskStack = function(maskStack) {
      this.maskStack = maskStack;
      this.renderer.scissor.setMaskStack(maskStack);
      this.renderer.stencil.setMaskStack(maskStack);
    };
    MaskSystem3.prototype.push = function(target, maskDataOrTarget) {
      var maskData = maskDataOrTarget;
      if (!maskData.isMaskData) {
        var d2 = this.maskDataPool.pop() || new MaskData();
        d2.pooled = true;
        d2.maskObject = maskDataOrTarget;
        maskData = d2;
      }
      if (maskData.autoDetect) {
        this.detect(maskData);
      }
      maskData.copyCountersOrReset(this.maskStack[this.maskStack.length - 1]);
      maskData._target = target;
      switch (maskData.type) {
        case MASK_TYPES.SCISSOR:
          this.maskStack.push(maskData);
          this.renderer.scissor.push(maskData);
          break;
        case MASK_TYPES.STENCIL:
          this.maskStack.push(maskData);
          this.renderer.stencil.push(maskData);
          break;
        case MASK_TYPES.SPRITE:
          maskData.copyCountersOrReset(null);
          this.pushSpriteMask(maskData);
          this.maskStack.push(maskData);
          break;
        default:
          break;
      }
    };
    MaskSystem3.prototype.pop = function(target) {
      var maskData = this.maskStack.pop();
      if (!maskData || maskData._target !== target) {
        return;
      }
      switch (maskData.type) {
        case MASK_TYPES.SCISSOR:
          this.renderer.scissor.pop();
          break;
        case MASK_TYPES.STENCIL:
          this.renderer.stencil.pop(maskData.maskObject);
          break;
        case MASK_TYPES.SPRITE:
          this.popSpriteMask();
          break;
        default:
          break;
      }
      maskData.reset();
      if (maskData.pooled) {
        this.maskDataPool.push(maskData);
      }
    };
    MaskSystem3.prototype.detect = function(maskData) {
      var maskObject = maskData.maskObject;
      if (maskObject.isSprite) {
        maskData.type = MASK_TYPES.SPRITE;
        return;
      }
      maskData.type = MASK_TYPES.STENCIL;
      if (this.enableScissor && maskObject.isFastRect && maskObject.isFastRect()) {
        var matrix = maskObject.worldTransform;
        var rotX = Math.atan2(matrix.b, matrix.a);
        var rotXY = Math.atan2(matrix.d, matrix.c);
        rotX = Math.round(rotX * (180 / Math.PI) * 100);
        rotXY = Math.round(rotXY * (180 / Math.PI) * 100) - rotX;
        rotX = (rotX % 9e3 + 9e3) % 9e3;
        rotXY = (rotXY % 18e3 + 18e3) % 18e3;
        if (rotX === 0 && rotXY === 9e3) {
          maskData.type = MASK_TYPES.SCISSOR;
        }
      }
    };
    MaskSystem3.prototype.pushSpriteMask = function(maskData) {
      var maskObject = maskData.maskObject;
      var target = maskData._target;
      var alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex];
      if (!alphaMaskFilter) {
        alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex] = [new SpriteMaskFilter(maskObject)];
      }
      alphaMaskFilter[0].resolution = this.renderer.resolution;
      alphaMaskFilter[0].maskSprite = maskObject;
      var stashFilterArea = target.filterArea;
      target.filterArea = maskObject.getBounds(true);
      this.renderer.filter.push(target, alphaMaskFilter);
      target.filterArea = stashFilterArea;
      this.alphaMaskIndex++;
    };
    MaskSystem3.prototype.popSpriteMask = function() {
      this.renderer.filter.pop();
      this.alphaMaskIndex--;
    };
    return MaskSystem3;
  }(System)
);
var AbstractMaskSystem = (
  /** @class */
  function(_super) {
    __extends(AbstractMaskSystem3, _super);
    function AbstractMaskSystem3(renderer) {
      var _this = _super.call(this, renderer) || this;
      _this.maskStack = [];
      _this.glConst = 0;
      return _this;
    }
    AbstractMaskSystem3.prototype.getStackLength = function() {
      return this.maskStack.length;
    };
    AbstractMaskSystem3.prototype.setMaskStack = function(maskStack) {
      var gl = this.renderer.gl;
      var curStackLen = this.getStackLength();
      this.maskStack = maskStack;
      var newStackLen = this.getStackLength();
      if (newStackLen !== curStackLen) {
        if (newStackLen === 0) {
          gl.disable(this.glConst);
        } else {
          gl.enable(this.glConst);
          this._useCurrent();
        }
      }
    };
    AbstractMaskSystem3.prototype._useCurrent = function() {
    };
    AbstractMaskSystem3.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      this.maskStack = null;
    };
    return AbstractMaskSystem3;
  }(System)
);
var ScissorSystem = (
  /** @class */
  function(_super) {
    __extends(ScissorSystem3, _super);
    function ScissorSystem3(renderer) {
      var _this = _super.call(this, renderer) || this;
      _this.glConst = WebGLRenderingContext.SCISSOR_TEST;
      return _this;
    }
    ScissorSystem3.prototype.getStackLength = function() {
      var maskData = this.maskStack[this.maskStack.length - 1];
      if (maskData) {
        return maskData._scissorCounter;
      }
      return 0;
    };
    ScissorSystem3.prototype.push = function(maskData) {
      var maskObject = maskData.maskObject;
      maskObject.renderable = true;
      var prevData = maskData._scissorRect;
      var bounds = maskObject.getBounds(true);
      var gl = this.renderer.gl;
      maskObject.renderable = false;
      if (prevData) {
        bounds.fit(prevData);
      } else {
        gl.enable(gl.SCISSOR_TEST);
      }
      maskData._scissorCounter++;
      maskData._scissorRect = bounds;
      this._useCurrent();
    };
    ScissorSystem3.prototype.pop = function() {
      var gl = this.renderer.gl;
      if (this.getStackLength() > 0) {
        this._useCurrent();
      } else {
        gl.disable(gl.SCISSOR_TEST);
      }
    };
    ScissorSystem3.prototype._useCurrent = function() {
      var rect = this.maskStack[this.maskStack.length - 1]._scissorRect;
      var rt = this.renderer.renderTexture.current;
      var _a = this.renderer.projection, transform = _a.transform, sourceFrame = _a.sourceFrame, destinationFrame = _a.destinationFrame;
      var resolution = rt ? rt.resolution : this.renderer.resolution;
      var x2 = (rect.x - sourceFrame.x) * resolution + destinationFrame.x;
      var y2 = (rect.y - sourceFrame.y) * resolution + destinationFrame.y;
      var width = rect.width * resolution;
      var height = rect.height * resolution;
      if (transform) {
        x2 += transform.tx * resolution;
        y2 += transform.ty * resolution;
      }
      if (!rt) {
        y2 = this.renderer.height - height - y2;
      }
      this.renderer.gl.scissor(x2, y2, width, height);
    };
    return ScissorSystem3;
  }(AbstractMaskSystem)
);
var StencilSystem = (
  /** @class */
  function(_super) {
    __extends(StencilSystem3, _super);
    function StencilSystem3(renderer) {
      var _this = _super.call(this, renderer) || this;
      _this.glConst = WebGLRenderingContext.STENCIL_TEST;
      return _this;
    }
    StencilSystem3.prototype.getStackLength = function() {
      var maskData = this.maskStack[this.maskStack.length - 1];
      if (maskData) {
        return maskData._stencilCounter;
      }
      return 0;
    };
    StencilSystem3.prototype.push = function(maskData) {
      var maskObject = maskData.maskObject;
      var gl = this.renderer.gl;
      var prevMaskCount = maskData._stencilCounter;
      if (prevMaskCount === 0) {
        this.renderer.framebuffer.forceStencil();
        gl.enable(gl.STENCIL_TEST);
      }
      maskData._stencilCounter++;
      gl.colorMask(false, false, false, false);
      gl.stencilFunc(gl.EQUAL, prevMaskCount, this._getBitwiseMask());
      gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);
      maskObject.renderable = true;
      maskObject.render(this.renderer);
      this.renderer.batch.flush();
      maskObject.renderable = false;
      this._useCurrent();
    };
    StencilSystem3.prototype.pop = function(maskObject) {
      var gl = this.renderer.gl;
      if (this.getStackLength() === 0) {
        gl.disable(gl.STENCIL_TEST);
        gl.clear(gl.STENCIL_BUFFER_BIT);
        gl.clearStencil(0);
      } else {
        gl.colorMask(false, false, false, false);
        gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR);
        maskObject.renderable = true;
        maskObject.render(this.renderer);
        this.renderer.batch.flush();
        maskObject.renderable = false;
        this._useCurrent();
      }
    };
    StencilSystem3.prototype._useCurrent = function() {
      var gl = this.renderer.gl;
      gl.colorMask(true, true, true, true);
      gl.stencilFunc(gl.EQUAL, this.getStackLength(), this._getBitwiseMask());
      gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
    };
    StencilSystem3.prototype._getBitwiseMask = function() {
      return (1 << this.getStackLength()) - 1;
    };
    return StencilSystem3;
  }(AbstractMaskSystem)
);
var ProjectionSystem = (
  /** @class */
  function(_super) {
    __extends(ProjectionSystem3, _super);
    function ProjectionSystem3(renderer) {
      var _this = _super.call(this, renderer) || this;
      _this.destinationFrame = null;
      _this.sourceFrame = null;
      _this.defaultFrame = null;
      _this.projectionMatrix = new Matrix();
      _this.transform = null;
      return _this;
    }
    ProjectionSystem3.prototype.update = function(destinationFrame, sourceFrame, resolution, root) {
      this.destinationFrame = destinationFrame || this.destinationFrame || this.defaultFrame;
      this.sourceFrame = sourceFrame || this.sourceFrame || destinationFrame;
      this.calculateProjection(this.destinationFrame, this.sourceFrame, resolution, root);
      if (this.transform) {
        this.projectionMatrix.append(this.transform);
      }
      var renderer = this.renderer;
      renderer.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix;
      renderer.globalUniforms.update();
      if (renderer.shader.shader) {
        renderer.shader.syncUniformGroup(renderer.shader.shader.uniforms.globals);
      }
    };
    ProjectionSystem3.prototype.calculateProjection = function(_destinationFrame, sourceFrame, _resolution, root) {
      var pm = this.projectionMatrix;
      var sign = !root ? 1 : -1;
      pm.identity();
      pm.a = 1 / sourceFrame.width * 2;
      pm.d = sign * (1 / sourceFrame.height * 2);
      pm.tx = -1 - sourceFrame.x * pm.a;
      pm.ty = -sign - sourceFrame.y * pm.d;
    };
    ProjectionSystem3.prototype.setTransform = function(_matrix) {
    };
    return ProjectionSystem3;
  }(System)
);
var tempRect = new Rectangle();
var tempRect2 = new Rectangle();
var viewportFrame = new Rectangle();
var RenderTextureSystem = (
  /** @class */
  function(_super) {
    __extends(RenderTextureSystem3, _super);
    function RenderTextureSystem3(renderer) {
      var _this = _super.call(this, renderer) || this;
      _this.clearColor = renderer._backgroundColorRgba;
      _this.defaultMaskStack = [];
      _this.current = null;
      _this.sourceFrame = new Rectangle();
      _this.destinationFrame = new Rectangle();
      return _this;
    }
    RenderTextureSystem3.prototype.bind = function(renderTexture, sourceFrame, destinationFrame) {
      if (renderTexture === void 0) {
        renderTexture = null;
      }
      var renderer = this.renderer;
      this.current = renderTexture;
      var baseTexture;
      var framebuffer;
      var resolution;
      if (renderTexture) {
        baseTexture = renderTexture.baseTexture;
        resolution = baseTexture.resolution;
        if (!sourceFrame) {
          tempRect.width = renderTexture.frame.width;
          tempRect.height = renderTexture.frame.height;
          sourceFrame = tempRect;
        }
        if (!destinationFrame) {
          tempRect2.x = renderTexture.frame.x;
          tempRect2.y = renderTexture.frame.y;
          tempRect2.width = sourceFrame.width;
          tempRect2.height = sourceFrame.height;
          destinationFrame = tempRect2;
        }
        framebuffer = baseTexture.framebuffer;
      } else {
        resolution = renderer.resolution;
        if (!sourceFrame) {
          tempRect.width = renderer.screen.width;
          tempRect.height = renderer.screen.height;
          sourceFrame = tempRect;
        }
        if (!destinationFrame) {
          destinationFrame = tempRect;
          destinationFrame.width = sourceFrame.width;
          destinationFrame.height = sourceFrame.height;
        }
      }
      viewportFrame.x = destinationFrame.x * resolution;
      viewportFrame.y = destinationFrame.y * resolution;
      viewportFrame.width = destinationFrame.width * resolution;
      viewportFrame.height = destinationFrame.height * resolution;
      this.renderer.framebuffer.bind(framebuffer, viewportFrame);
      this.renderer.projection.update(destinationFrame, sourceFrame, resolution, !framebuffer);
      if (renderTexture) {
        this.renderer.mask.setMaskStack(baseTexture.maskStack);
      } else {
        this.renderer.mask.setMaskStack(this.defaultMaskStack);
      }
      this.sourceFrame.copyFrom(sourceFrame);
      this.destinationFrame.copyFrom(destinationFrame);
    };
    RenderTextureSystem3.prototype.clear = function(clearColor, mask) {
      if (this.current) {
        clearColor = clearColor || this.current.baseTexture.clearColor;
      } else {
        clearColor = clearColor || this.clearColor;
      }
      this.renderer.framebuffer.clear(clearColor[0], clearColor[1], clearColor[2], clearColor[3], mask);
    };
    RenderTextureSystem3.prototype.resize = function() {
      this.bind(null);
    };
    RenderTextureSystem3.prototype.reset = function() {
      this.bind(null);
    };
    return RenderTextureSystem3;
  }(System)
);
var GLProgram = (
  /** @class */
  function() {
    function GLProgram3(program, uniformData) {
      this.program = program;
      this.uniformData = uniformData;
      this.uniformGroups = {};
    }
    GLProgram3.prototype.destroy = function() {
      this.uniformData = null;
      this.uniformGroups = null;
      this.program = null;
    };
    return GLProgram3;
  }()
);
var UID$4 = 0;
var defaultSyncData = { textureCount: 0 };
var ShaderSystem = (
  /** @class */
  function(_super) {
    __extends(ShaderSystem3, _super);
    function ShaderSystem3(renderer) {
      var _this = _super.call(this, renderer) || this;
      _this.destroyed = false;
      _this.systemCheck();
      _this.gl = null;
      _this.shader = null;
      _this.program = null;
      _this.cache = {};
      _this.id = UID$4++;
      return _this;
    }
    ShaderSystem3.prototype.systemCheck = function() {
      if (!unsafeEvalSupported()) {
        throw new Error("Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.");
      }
    };
    ShaderSystem3.prototype.contextChange = function(gl) {
      this.gl = gl;
      this.reset();
    };
    ShaderSystem3.prototype.bind = function(shader, dontSync) {
      shader.uniforms.globals = this.renderer.globalUniforms;
      var program = shader.program;
      var glProgram = program.glPrograms[this.renderer.CONTEXT_UID] || this.generateShader(shader);
      this.shader = shader;
      if (this.program !== program) {
        this.program = program;
        this.gl.useProgram(glProgram.program);
      }
      if (!dontSync) {
        defaultSyncData.textureCount = 0;
        this.syncUniformGroup(shader.uniformGroup, defaultSyncData);
      }
      return glProgram;
    };
    ShaderSystem3.prototype.setUniforms = function(uniforms) {
      var shader = this.shader.program;
      var glProgram = shader.glPrograms[this.renderer.CONTEXT_UID];
      shader.syncUniforms(glProgram.uniformData, uniforms, this.renderer);
    };
    ShaderSystem3.prototype.syncUniformGroup = function(group, syncData) {
      var glProgram = this.getglProgram();
      if (!group.static || group.dirtyId !== glProgram.uniformGroups[group.id]) {
        glProgram.uniformGroups[group.id] = group.dirtyId;
        this.syncUniforms(group, glProgram, syncData);
      }
    };
    ShaderSystem3.prototype.syncUniforms = function(group, glProgram, syncData) {
      var syncFunc = group.syncUniforms[this.shader.program.id] || this.createSyncGroups(group);
      syncFunc(glProgram.uniformData, group.uniforms, this.renderer, syncData);
    };
    ShaderSystem3.prototype.createSyncGroups = function(group) {
      var id = this.getSignature(group, this.shader.program.uniformData);
      if (!this.cache[id]) {
        this.cache[id] = generateUniformsSync(group, this.shader.program.uniformData);
      }
      group.syncUniforms[this.shader.program.id] = this.cache[id];
      return group.syncUniforms[this.shader.program.id];
    };
    ShaderSystem3.prototype.getSignature = function(group, uniformData) {
      var uniforms = group.uniforms;
      var strings = [];
      for (var i in uniforms) {
        strings.push(i);
        if (uniformData[i]) {
          strings.push(uniformData[i].type);
        }
      }
      return strings.join("-");
    };
    ShaderSystem3.prototype.getglProgram = function() {
      if (this.shader) {
        return this.shader.program.glPrograms[this.renderer.CONTEXT_UID];
      }
      return null;
    };
    ShaderSystem3.prototype.generateShader = function(shader) {
      var gl = this.gl;
      var program = shader.program;
      var attribMap = {};
      for (var i in program.attributeData) {
        attribMap[i] = program.attributeData[i].location;
      }
      var shaderProgram = compileProgram(gl, program.vertexSrc, program.fragmentSrc, attribMap);
      var uniformData = {};
      for (var i in program.uniformData) {
        var data = program.uniformData[i];
        uniformData[i] = {
          location: gl.getUniformLocation(shaderProgram, i),
          value: defaultValue(data.type, data.size)
        };
      }
      var glProgram = new GLProgram(shaderProgram, uniformData);
      program.glPrograms[this.renderer.CONTEXT_UID] = glProgram;
      return glProgram;
    };
    ShaderSystem3.prototype.reset = function() {
      this.program = null;
      this.shader = null;
    };
    ShaderSystem3.prototype.destroy = function() {
      this.destroyed = true;
    };
    return ShaderSystem3;
  }(System)
);
function mapWebGLBlendModesToPixi(gl, array) {
  if (array === void 0) {
    array = [];
  }
  array[BLEND_MODES.NORMAL] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.ADD] = [gl.ONE, gl.ONE];
  array[BLEND_MODES.MULTIPLY] = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.SCREEN] = [gl.ONE, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.OVERLAY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.DARKEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.LIGHTEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.COLOR_DODGE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.COLOR_BURN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.HARD_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.SOFT_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.DIFFERENCE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.EXCLUSION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.HUE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.SATURATION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.COLOR] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.LUMINOSITY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.NONE] = [0, 0];
  array[BLEND_MODES.NORMAL_NPM] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.ADD_NPM] = [gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE];
  array[BLEND_MODES.SCREEN_NPM] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.SRC_IN] = [gl.DST_ALPHA, gl.ZERO];
  array[BLEND_MODES.SRC_OUT] = [gl.ONE_MINUS_DST_ALPHA, gl.ZERO];
  array[BLEND_MODES.SRC_ATOP] = [gl.DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.DST_OVER] = [gl.ONE_MINUS_DST_ALPHA, gl.ONE];
  array[BLEND_MODES.DST_IN] = [gl.ZERO, gl.SRC_ALPHA];
  array[BLEND_MODES.DST_OUT] = [gl.ZERO, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.DST_ATOP] = [gl.ONE_MINUS_DST_ALPHA, gl.SRC_ALPHA];
  array[BLEND_MODES.XOR] = [gl.ONE_MINUS_DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.SUBTRACT] = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, gl.FUNC_REVERSE_SUBTRACT, gl.FUNC_ADD];
  return array;
}
var BLEND$1 = 0;
var OFFSET$1 = 1;
var CULLING$1 = 2;
var DEPTH_TEST$1 = 3;
var WINDING$1 = 4;
var StateSystem = (
  /** @class */
  function(_super) {
    __extends(StateSystem3, _super);
    function StateSystem3(renderer) {
      var _this = _super.call(this, renderer) || this;
      _this.gl = null;
      _this.stateId = 0;
      _this.polygonOffset = 0;
      _this.blendMode = BLEND_MODES.NONE;
      _this._blendEq = false;
      _this.map = [];
      _this.map[BLEND$1] = _this.setBlend;
      _this.map[OFFSET$1] = _this.setOffset;
      _this.map[CULLING$1] = _this.setCullFace;
      _this.map[DEPTH_TEST$1] = _this.setDepthTest;
      _this.map[WINDING$1] = _this.setFrontFace;
      _this.checks = [];
      _this.defaultState = new State();
      _this.defaultState.blend = true;
      return _this;
    }
    StateSystem3.prototype.contextChange = function(gl) {
      this.gl = gl;
      this.blendModes = mapWebGLBlendModesToPixi(gl);
      this.set(this.defaultState);
      this.reset();
    };
    StateSystem3.prototype.set = function(state) {
      state = state || this.defaultState;
      if (this.stateId !== state.data) {
        var diff = this.stateId ^ state.data;
        var i = 0;
        while (diff) {
          if (diff & 1) {
            this.map[i].call(this, !!(state.data & 1 << i));
          }
          diff = diff >> 1;
          i++;
        }
        this.stateId = state.data;
      }
      for (var i = 0; i < this.checks.length; i++) {
        this.checks[i](this, state);
      }
    };
    StateSystem3.prototype.forceState = function(state) {
      state = state || this.defaultState;
      for (var i = 0; i < this.map.length; i++) {
        this.map[i].call(this, !!(state.data & 1 << i));
      }
      for (var i = 0; i < this.checks.length; i++) {
        this.checks[i](this, state);
      }
      this.stateId = state.data;
    };
    StateSystem3.prototype.setBlend = function(value) {
      this.updateCheck(StateSystem3.checkBlendMode, value);
      this.gl[value ? "enable" : "disable"](this.gl.BLEND);
    };
    StateSystem3.prototype.setOffset = function(value) {
      this.updateCheck(StateSystem3.checkPolygonOffset, value);
      this.gl[value ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL);
    };
    StateSystem3.prototype.setDepthTest = function(value) {
      this.gl[value ? "enable" : "disable"](this.gl.DEPTH_TEST);
    };
    StateSystem3.prototype.setCullFace = function(value) {
      this.gl[value ? "enable" : "disable"](this.gl.CULL_FACE);
    };
    StateSystem3.prototype.setFrontFace = function(value) {
      this.gl.frontFace(this.gl[value ? "CW" : "CCW"]);
    };
    StateSystem3.prototype.setBlendMode = function(value) {
      if (value === this.blendMode) {
        return;
      }
      this.blendMode = value;
      var mode = this.blendModes[value];
      var gl = this.gl;
      if (mode.length === 2) {
        gl.blendFunc(mode[0], mode[1]);
      } else {
        gl.blendFuncSeparate(mode[0], mode[1], mode[2], mode[3]);
      }
      if (mode.length === 6) {
        this._blendEq = true;
        gl.blendEquationSeparate(mode[4], mode[5]);
      } else if (this._blendEq) {
        this._blendEq = false;
        gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
      }
    };
    StateSystem3.prototype.setPolygonOffset = function(value, scale) {
      this.gl.polygonOffset(value, scale);
    };
    StateSystem3.prototype.reset = function() {
      this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false);
      this.forceState(this.defaultState);
      this._blendEq = true;
      this.blendMode = -1;
      this.setBlendMode(0);
    };
    StateSystem3.prototype.updateCheck = function(func, value) {
      var index2 = this.checks.indexOf(func);
      if (value && index2 === -1) {
        this.checks.push(func);
      } else if (!value && index2 !== -1) {
        this.checks.splice(index2, 1);
      }
    };
    StateSystem3.checkBlendMode = function(system, state) {
      system.setBlendMode(state.blendMode);
    };
    StateSystem3.checkPolygonOffset = function(system, state) {
      system.setPolygonOffset(1, state.polygonOffset);
    };
    return StateSystem3;
  }(System)
);
var TextureGCSystem = (
  /** @class */
  function(_super) {
    __extends(TextureGCSystem3, _super);
    function TextureGCSystem3(renderer) {
      var _this = _super.call(this, renderer) || this;
      _this.count = 0;
      _this.checkCount = 0;
      _this.maxIdle = settings.GC_MAX_IDLE;
      _this.checkCountMax = settings.GC_MAX_CHECK_COUNT;
      _this.mode = settings.GC_MODE;
      return _this;
    }
    TextureGCSystem3.prototype.postrender = function() {
      if (!this.renderer.renderingToScreen) {
        return;
      }
      this.count++;
      if (this.mode === GC_MODES.MANUAL) {
        return;
      }
      this.checkCount++;
      if (this.checkCount > this.checkCountMax) {
        this.checkCount = 0;
        this.run();
      }
    };
    TextureGCSystem3.prototype.run = function() {
      var tm = this.renderer.texture;
      var managedTextures = tm.managedTextures;
      var wasRemoved = false;
      for (var i = 0; i < managedTextures.length; i++) {
        var texture = managedTextures[i];
        if (!texture.framebuffer && this.count - texture.touched > this.maxIdle) {
          tm.destroyTexture(texture, true);
          managedTextures[i] = null;
          wasRemoved = true;
        }
      }
      if (wasRemoved) {
        var j2 = 0;
        for (var i = 0; i < managedTextures.length; i++) {
          if (managedTextures[i] !== null) {
            managedTextures[j2++] = managedTextures[i];
          }
        }
        managedTextures.length = j2;
      }
    };
    TextureGCSystem3.prototype.unload = function(displayObject) {
      var tm = this.renderer.texture;
      var texture = displayObject._texture;
      if (texture && !texture.framebuffer) {
        tm.destroyTexture(texture);
      }
      for (var i = displayObject.children.length - 1; i >= 0; i--) {
        this.unload(displayObject.children[i]);
      }
    };
    return TextureGCSystem3;
  }(System)
);
var GLTexture = (
  /** @class */
  /* @__PURE__ */ function() {
    function GLTexture3(texture) {
      this.texture = texture;
      this.width = -1;
      this.height = -1;
      this.dirtyId = -1;
      this.dirtyStyleId = -1;
      this.mipmap = false;
      this.wrapMode = 33071;
      this.type = 6408;
      this.internalFormat = 5121;
    }
    return GLTexture3;
  }()
);
var TextureSystem = (
  /** @class */
  function(_super) {
    __extends(TextureSystem3, _super);
    function TextureSystem3(renderer) {
      var _this = _super.call(this, renderer) || this;
      _this.boundTextures = [];
      _this.currentLocation = -1;
      _this.managedTextures = [];
      _this._unknownBoundTextures = false;
      _this.unknownTexture = new BaseTexture();
      return _this;
    }
    TextureSystem3.prototype.contextChange = function() {
      var gl = this.gl = this.renderer.gl;
      this.CONTEXT_UID = this.renderer.CONTEXT_UID;
      this.webGLVersion = this.renderer.context.webGLVersion;
      var maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
      this.boundTextures.length = maxTextures;
      for (var i = 0; i < maxTextures; i++) {
        this.boundTextures[i] = null;
      }
      this.emptyTextures = {};
      var emptyTexture2D = new GLTexture(gl.createTexture());
      gl.bindTexture(gl.TEXTURE_2D, emptyTexture2D.texture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(4));
      this.emptyTextures[gl.TEXTURE_2D] = emptyTexture2D;
      this.emptyTextures[gl.TEXTURE_CUBE_MAP] = new GLTexture(gl.createTexture());
      gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.emptyTextures[gl.TEXTURE_CUBE_MAP].texture);
      for (var i = 0; i < 6; i++) {
        gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
      }
      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      for (var i = 0; i < this.boundTextures.length; i++) {
        this.bind(null, i);
      }
    };
    TextureSystem3.prototype.bind = function(texture, location) {
      if (location === void 0) {
        location = 0;
      }
      var gl = this.gl;
      if (texture) {
        texture = texture.castToBaseTexture();
        if (texture.parentTextureArray) {
          return;
        }
        if (texture.valid) {
          texture.touched = this.renderer.textureGC.count;
          var glTexture = texture._glTextures[this.CONTEXT_UID] || this.initTexture(texture);
          if (this.boundTextures[location] !== texture) {
            if (this.currentLocation !== location) {
              this.currentLocation = location;
              gl.activeTexture(gl.TEXTURE0 + location);
            }
            gl.bindTexture(texture.target, glTexture.texture);
          }
          if (glTexture.dirtyId !== texture.dirtyId) {
            if (this.currentLocation !== location) {
              this.currentLocation = location;
              gl.activeTexture(gl.TEXTURE0 + location);
            }
            this.updateTexture(texture);
          }
          this.boundTextures[location] = texture;
        }
      } else {
        if (this.currentLocation !== location) {
          this.currentLocation = location;
          gl.activeTexture(gl.TEXTURE0 + location);
        }
        gl.bindTexture(gl.TEXTURE_2D, this.emptyTextures[gl.TEXTURE_2D].texture);
        this.boundTextures[location] = null;
      }
    };
    TextureSystem3.prototype.reset = function() {
      this._unknownBoundTextures = true;
      this.currentLocation = -1;
      for (var i = 0; i < this.boundTextures.length; i++) {
        this.boundTextures[i] = this.unknownTexture;
      }
    };
    TextureSystem3.prototype.unbind = function(texture) {
      var _a = this, gl = _a.gl, boundTextures = _a.boundTextures;
      if (this._unknownBoundTextures) {
        this._unknownBoundTextures = false;
        for (var i = 0; i < boundTextures.length; i++) {
          if (boundTextures[i] === this.unknownTexture) {
            this.bind(null, i);
          }
        }
      }
      for (var i = 0; i < boundTextures.length; i++) {
        if (boundTextures[i] === texture) {
          if (this.currentLocation !== i) {
            gl.activeTexture(gl.TEXTURE0 + i);
            this.currentLocation = i;
          }
          gl.bindTexture(texture.target, this.emptyTextures[texture.target].texture);
          boundTextures[i] = null;
        }
      }
    };
    TextureSystem3.prototype.initTexture = function(texture) {
      var glTexture = new GLTexture(this.gl.createTexture());
      glTexture.dirtyId = -1;
      texture._glTextures[this.CONTEXT_UID] = glTexture;
      this.managedTextures.push(texture);
      texture.on("dispose", this.destroyTexture, this);
      return glTexture;
    };
    TextureSystem3.prototype.initTextureType = function(texture, glTexture) {
      glTexture.internalFormat = texture.format;
      glTexture.type = texture.type;
      if (this.webGLVersion !== 2) {
        return;
      }
      var gl = this.renderer.gl;
      if (texture.type === gl.FLOAT && texture.format === gl.RGBA) {
        glTexture.internalFormat = gl.RGBA32F;
      }
      if (texture.type === TYPES.HALF_FLOAT) {
        glTexture.type = gl.HALF_FLOAT;
      }
      if (glTexture.type === gl.HALF_FLOAT && texture.format === gl.RGBA) {
        glTexture.internalFormat = gl.RGBA16F;
      }
    };
    TextureSystem3.prototype.updateTexture = function(texture) {
      var glTexture = texture._glTextures[this.CONTEXT_UID];
      if (!glTexture) {
        return;
      }
      var renderer = this.renderer;
      this.initTextureType(texture, glTexture);
      if (texture.resource && texture.resource.upload(renderer, texture, glTexture)) ;
      else {
        var width = texture.realWidth;
        var height = texture.realHeight;
        var gl = renderer.gl;
        if (glTexture.width !== width || glTexture.height !== height || glTexture.dirtyId < 0) {
          glTexture.width = width;
          glTexture.height = height;
          gl.texImage2D(texture.target, 0, glTexture.internalFormat, width, height, 0, texture.format, glTexture.type, null);
        }
      }
      if (texture.dirtyStyleId !== glTexture.dirtyStyleId) {
        this.updateTextureStyle(texture);
      }
      glTexture.dirtyId = texture.dirtyId;
    };
    TextureSystem3.prototype.destroyTexture = function(texture, skipRemove) {
      var gl = this.gl;
      texture = texture.castToBaseTexture();
      if (texture._glTextures[this.CONTEXT_UID]) {
        this.unbind(texture);
        gl.deleteTexture(texture._glTextures[this.CONTEXT_UID].texture);
        texture.off("dispose", this.destroyTexture, this);
        delete texture._glTextures[this.CONTEXT_UID];
        if (!skipRemove) {
          var i = this.managedTextures.indexOf(texture);
          if (i !== -1) {
            removeItems(this.managedTextures, i, 1);
          }
        }
      }
    };
    TextureSystem3.prototype.updateTextureStyle = function(texture) {
      var glTexture = texture._glTextures[this.CONTEXT_UID];
      if (!glTexture) {
        return;
      }
      if ((texture.mipmap === MIPMAP_MODES.POW2 || this.webGLVersion !== 2) && !texture.isPowerOfTwo) {
        glTexture.mipmap = false;
      } else {
        glTexture.mipmap = texture.mipmap >= 1;
      }
      if (this.webGLVersion !== 2 && !texture.isPowerOfTwo) {
        glTexture.wrapMode = WRAP_MODES.CLAMP;
      } else {
        glTexture.wrapMode = texture.wrapMode;
      }
      if (texture.resource && texture.resource.style(this.renderer, texture, glTexture)) ;
      else {
        this.setStyle(texture, glTexture);
      }
      glTexture.dirtyStyleId = texture.dirtyStyleId;
    };
    TextureSystem3.prototype.setStyle = function(texture, glTexture) {
      var gl = this.gl;
      if (glTexture.mipmap) {
        gl.generateMipmap(texture.target);
      }
      gl.texParameteri(texture.target, gl.TEXTURE_WRAP_S, glTexture.wrapMode);
      gl.texParameteri(texture.target, gl.TEXTURE_WRAP_T, glTexture.wrapMode);
      if (glTexture.mipmap) {
        gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode === SCALE_MODES.LINEAR ? gl.LINEAR_MIPMAP_LINEAR : gl.NEAREST_MIPMAP_NEAREST);
        var anisotropicExt = this.renderer.context.extensions.anisotropicFiltering;
        if (anisotropicExt && texture.anisotropicLevel > 0 && texture.scaleMode === SCALE_MODES.LINEAR) {
          var level = Math.min(texture.anisotropicLevel, gl.getParameter(anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
          gl.texParameterf(texture.target, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, level);
        }
      } else {
        gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode === SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);
      }
      gl.texParameteri(texture.target, gl.TEXTURE_MAG_FILTER, texture.scaleMode === SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);
    };
    return TextureSystem3;
  }(System)
);
var tempMatrix = new Matrix();
var AbstractRenderer = (
  /** @class */
  function(_super) {
    __extends(AbstractRenderer3, _super);
    function AbstractRenderer3(type, options) {
      if (type === void 0) {
        type = RENDERER_TYPE.UNKNOWN;
      }
      var _this = _super.call(this) || this;
      options = Object.assign({}, settings.RENDER_OPTIONS, options);
      if (options.roundPixels) {
        settings.ROUND_PIXELS = options.roundPixels;
        deprecation("5.0.0", "Renderer roundPixels option is deprecated, please use PIXI.settings.ROUND_PIXELS", 2);
      }
      _this.options = options;
      _this.type = type;
      _this.screen = new Rectangle(0, 0, options.width, options.height);
      _this.view = options.view || document.createElement("canvas");
      _this.resolution = options.resolution || settings.RESOLUTION;
      _this.transparent = options.transparent;
      _this.autoDensity = options.autoDensity || options.autoResize || false;
      _this.preserveDrawingBuffer = options.preserveDrawingBuffer;
      _this.clearBeforeRender = options.clearBeforeRender;
      _this._backgroundColor = 0;
      _this._backgroundColorRgba = [0, 0, 0, 0];
      _this._backgroundColorString = "#000000";
      _this.backgroundColor = options.backgroundColor || _this._backgroundColor;
      _this._lastObjectRendered = null;
      _this.plugins = {};
      return _this;
    }
    AbstractRenderer3.prototype.initPlugins = function(staticMap) {
      for (var o in staticMap) {
        this.plugins[o] = new staticMap[o](this);
      }
    };
    Object.defineProperty(AbstractRenderer3.prototype, "width", {
      /**
       * Same as view.width, actual number of pixels in the canvas by horizontal.
       *
       * @member {number}
       * @readonly
       * @default 800
       */
      get: function() {
        return this.view.width;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(AbstractRenderer3.prototype, "height", {
      /**
       * Same as view.height, actual number of pixels in the canvas by vertical.
       *
       * @member {number}
       * @readonly
       * @default 600
       */
      get: function() {
        return this.view.height;
      },
      enumerable: false,
      configurable: true
    });
    AbstractRenderer3.prototype.resize = function(screenWidth, screenHeight) {
      this.screen.width = screenWidth;
      this.screen.height = screenHeight;
      this.view.width = screenWidth * this.resolution;
      this.view.height = screenHeight * this.resolution;
      if (this.autoDensity) {
        this.view.style.width = screenWidth + "px";
        this.view.style.height = screenHeight + "px";
      }
      this.emit("resize", screenWidth, screenHeight);
    };
    AbstractRenderer3.prototype.generateTexture = function(displayObject, scaleMode, resolution, region) {
      region = region || displayObject.getLocalBounds(null, true);
      if (region.width === 0) {
        region.width = 1;
      }
      if (region.height === 0) {
        region.height = 1;
      }
      var renderTexture = RenderTexture.create({
        width: region.width | 0,
        height: region.height | 0,
        scaleMode,
        resolution
      });
      tempMatrix.tx = -region.x;
      tempMatrix.ty = -region.y;
      this.render(displayObject, renderTexture, false, tempMatrix, !!displayObject.parent);
      return renderTexture;
    };
    AbstractRenderer3.prototype.destroy = function(removeView) {
      for (var o in this.plugins) {
        this.plugins[o].destroy();
        this.plugins[o] = null;
      }
      if (removeView && this.view.parentNode) {
        this.view.parentNode.removeChild(this.view);
      }
      var thisAny = this;
      thisAny.plugins = null;
      thisAny.type = RENDERER_TYPE.UNKNOWN;
      thisAny.view = null;
      thisAny.screen = null;
      thisAny._tempDisplayObjectParent = null;
      thisAny.options = null;
      this._backgroundColorRgba = null;
      this._backgroundColorString = null;
      this._lastObjectRendered = null;
    };
    Object.defineProperty(AbstractRenderer3.prototype, "backgroundColor", {
      /**
       * The background color to fill if not transparent
       *
       * @member {number}
       */
      get: function() {
        return this._backgroundColor;
      },
      set: function(value) {
        this._backgroundColor = value;
        this._backgroundColorString = hex2string(value);
        hex2rgb(value, this._backgroundColorRgba);
      },
      enumerable: false,
      configurable: true
    });
    return AbstractRenderer3;
  }(import_eventemitter3.default)
);
var Renderer = (
  /** @class */
  function(_super) {
    __extends(Renderer3, _super);
    function Renderer3(options) {
      var _this = _super.call(this, RENDERER_TYPE.WEBGL, options) || this;
      options = _this.options;
      _this.gl = null;
      _this.CONTEXT_UID = 0;
      _this.runners = {
        destroy: new Runner("destroy"),
        contextChange: new Runner("contextChange"),
        reset: new Runner("reset"),
        update: new Runner("update"),
        postrender: new Runner("postrender"),
        prerender: new Runner("prerender"),
        resize: new Runner("resize")
      };
      _this.globalUniforms = new UniformGroup({
        projectionMatrix: new Matrix()
      }, true);
      _this.addSystem(MaskSystem, "mask").addSystem(ContextSystem, "context").addSystem(StateSystem, "state").addSystem(ShaderSystem, "shader").addSystem(TextureSystem, "texture").addSystem(GeometrySystem, "geometry").addSystem(FramebufferSystem, "framebuffer").addSystem(ScissorSystem, "scissor").addSystem(StencilSystem, "stencil").addSystem(ProjectionSystem, "projection").addSystem(TextureGCSystem, "textureGC").addSystem(FilterSystem, "filter").addSystem(RenderTextureSystem, "renderTexture").addSystem(BatchSystem, "batch");
      _this.initPlugins(Renderer3.__plugins);
      if (options.context) {
        _this.context.initFromContext(options.context);
      } else {
        _this.context.initFromOptions({
          alpha: !!_this.transparent,
          antialias: options.antialias,
          premultipliedAlpha: _this.transparent && _this.transparent !== "notMultiplied",
          stencil: true,
          preserveDrawingBuffer: options.preserveDrawingBuffer,
          powerPreference: _this.options.powerPreference
        });
      }
      _this.renderingToScreen = true;
      sayHello(_this.context.webGLVersion === 2 ? "WebGL 2" : "WebGL 1");
      _this.resize(_this.options.width, _this.options.height);
      return _this;
    }
    Renderer3.create = function(options) {
      if (isWebGLSupported()) {
        return new Renderer3(options);
      }
      throw new Error('WebGL unsupported in this browser, use "pixi.js-legacy" for fallback canvas2d support.');
    };
    Renderer3.prototype.addSystem = function(ClassRef, name) {
      if (!name) {
        name = ClassRef.name;
      }
      var system = new ClassRef(this);
      if (this[name]) {
        throw new Error('Whoops! The name "' + name + '" is already in use');
      }
      this[name] = system;
      for (var i in this.runners) {
        this.runners[i].add(system);
      }
      return this;
    };
    Renderer3.prototype.render = function(displayObject, renderTexture, clear, transform, skipUpdateTransform) {
      this.renderingToScreen = !renderTexture;
      this.runners.prerender.emit();
      this.emit("prerender");
      this.projection.transform = transform;
      if (this.context.isLost) {
        return;
      }
      if (!renderTexture) {
        this._lastObjectRendered = displayObject;
      }
      if (!skipUpdateTransform) {
        var cacheParent = displayObject.enableTempParent();
        displayObject.updateTransform();
        displayObject.disableTempParent(cacheParent);
      }
      this.renderTexture.bind(renderTexture);
      this.batch.currentRenderer.start();
      if (clear !== void 0 ? clear : this.clearBeforeRender) {
        this.renderTexture.clear();
      }
      displayObject.render(this);
      this.batch.currentRenderer.flush();
      if (renderTexture) {
        renderTexture.baseTexture.update();
      }
      this.runners.postrender.emit();
      this.projection.transform = null;
      this.emit("postrender");
    };
    Renderer3.prototype.resize = function(screenWidth, screenHeight) {
      _super.prototype.resize.call(this, screenWidth, screenHeight);
      this.runners.resize.emit(screenWidth, screenHeight);
    };
    Renderer3.prototype.reset = function() {
      this.runners.reset.emit();
      return this;
    };
    Renderer3.prototype.clear = function() {
      this.renderTexture.bind();
      this.renderTexture.clear();
    };
    Renderer3.prototype.destroy = function(removeView) {
      this.runners.destroy.emit();
      for (var r2 in this.runners) {
        this.runners[r2].destroy();
      }
      _super.prototype.destroy.call(this, removeView);
      this.gl = null;
    };
    Renderer3.registerPlugin = function(pluginName, ctor) {
      Renderer3.__plugins = Renderer3.__plugins || {};
      Renderer3.__plugins[pluginName] = ctor;
    };
    return Renderer3;
  }(AbstractRenderer)
);
var BatchDrawCall = (
  /** @class */
  /* @__PURE__ */ function() {
    function BatchDrawCall3() {
      this.texArray = null;
      this.blend = 0;
      this.type = DRAW_MODES.TRIANGLES;
      this.start = 0;
      this.size = 0;
      this.data = null;
    }
    return BatchDrawCall3;
  }()
);
var BatchTextureArray = (
  /** @class */
  function() {
    function BatchTextureArray3() {
      this.elements = [];
      this.ids = [];
      this.count = 0;
    }
    BatchTextureArray3.prototype.clear = function() {
      for (var i = 0; i < this.count; i++) {
        this.elements[i] = null;
      }
      this.count = 0;
    };
    return BatchTextureArray3;
  }()
);
var ViewableBuffer = (
  /** @class */
  function() {
    function ViewableBuffer3(size) {
      this.rawBinaryData = new ArrayBuffer(size);
      this.uint32View = new Uint32Array(this.rawBinaryData);
      this.float32View = new Float32Array(this.rawBinaryData);
    }
    Object.defineProperty(ViewableBuffer3.prototype, "int8View", {
      /**
       * View on the raw binary data as a `Int8Array`.
       *
       * @member {Int8Array}
       */
      get: function() {
        if (!this._int8View) {
          this._int8View = new Int8Array(this.rawBinaryData);
        }
        return this._int8View;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ViewableBuffer3.prototype, "uint8View", {
      /**
       * View on the raw binary data as a `Uint8Array`.
       *
       * @member {Uint8Array}
       */
      get: function() {
        if (!this._uint8View) {
          this._uint8View = new Uint8Array(this.rawBinaryData);
        }
        return this._uint8View;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ViewableBuffer3.prototype, "int16View", {
      /**
       * View on the raw binary data as a `Int16Array`.
       *
       * @member {Int16Array}
       */
      get: function() {
        if (!this._int16View) {
          this._int16View = new Int16Array(this.rawBinaryData);
        }
        return this._int16View;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ViewableBuffer3.prototype, "uint16View", {
      /**
       * View on the raw binary data as a `Uint16Array`.
       *
       * @member {Uint16Array}
       */
      get: function() {
        if (!this._uint16View) {
          this._uint16View = new Uint16Array(this.rawBinaryData);
        }
        return this._uint16View;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ViewableBuffer3.prototype, "int32View", {
      /**
       * View on the raw binary data as a `Int32Array`.
       *
       * @member {Int32Array}
       */
      get: function() {
        if (!this._int32View) {
          this._int32View = new Int32Array(this.rawBinaryData);
        }
        return this._int32View;
      },
      enumerable: false,
      configurable: true
    });
    ViewableBuffer3.prototype.view = function(type) {
      return this[type + "View"];
    };
    ViewableBuffer3.prototype.destroy = function() {
      this.rawBinaryData = null;
      this._int8View = null;
      this._uint8View = null;
      this._int16View = null;
      this._uint16View = null;
      this._int32View = null;
      this.uint32View = null;
      this.float32View = null;
    };
    ViewableBuffer3.sizeOf = function(type) {
      switch (type) {
        case "int8":
        case "uint8":
          return 1;
        case "int16":
        case "uint16":
          return 2;
        case "int32":
        case "uint32":
        case "float32":
          return 4;
        default:
          throw new Error(type + " isn't a valid view type");
      }
    };
    return ViewableBuffer3;
  }()
);
var AbstractBatchRenderer = (
  /** @class */
  function(_super) {
    __extends(AbstractBatchRenderer3, _super);
    function AbstractBatchRenderer3(renderer) {
      var _this = _super.call(this, renderer) || this;
      _this.shaderGenerator = null;
      _this.geometryClass = null;
      _this.vertexSize = null;
      _this.state = State.for2d();
      _this.size = settings.SPRITE_BATCH_SIZE * 4;
      _this._vertexCount = 0;
      _this._indexCount = 0;
      _this._bufferedElements = [];
      _this._bufferedTextures = [];
      _this._bufferSize = 0;
      _this._shader = null;
      _this._packedGeometries = [];
      _this._packedGeometryPoolSize = 2;
      _this._flushId = 0;
      _this._aBuffers = {};
      _this._iBuffers = {};
      _this.MAX_TEXTURES = 1;
      _this.renderer.on("prerender", _this.onPrerender, _this);
      renderer.runners.contextChange.add(_this);
      _this._dcIndex = 0;
      _this._aIndex = 0;
      _this._iIndex = 0;
      _this._attributeBuffer = null;
      _this._indexBuffer = null;
      _this._tempBoundTextures = [];
      return _this;
    }
    AbstractBatchRenderer3.prototype.contextChange = function() {
      var gl = this.renderer.gl;
      if (settings.PREFER_ENV === ENV.WEBGL_LEGACY) {
        this.MAX_TEXTURES = 1;
      } else {
        this.MAX_TEXTURES = Math.min(gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS), settings.SPRITE_MAX_TEXTURES);
        this.MAX_TEXTURES = checkMaxIfStatementsInShader(this.MAX_TEXTURES, gl);
      }
      this._shader = this.shaderGenerator.generateShader(this.MAX_TEXTURES);
      for (var i = 0; i < this._packedGeometryPoolSize; i++) {
        this._packedGeometries[i] = new this.geometryClass();
      }
      this.initFlushBuffers();
    };
    AbstractBatchRenderer3.prototype.initFlushBuffers = function() {
      var _drawCallPool = AbstractBatchRenderer3._drawCallPool, _textureArrayPool = AbstractBatchRenderer3._textureArrayPool;
      var MAX_SPRITES = this.size / 4;
      var MAX_TA = Math.floor(MAX_SPRITES / this.MAX_TEXTURES) + 1;
      while (_drawCallPool.length < MAX_SPRITES) {
        _drawCallPool.push(new BatchDrawCall());
      }
      while (_textureArrayPool.length < MAX_TA) {
        _textureArrayPool.push(new BatchTextureArray());
      }
      for (var i = 0; i < this.MAX_TEXTURES; i++) {
        this._tempBoundTextures[i] = null;
      }
    };
    AbstractBatchRenderer3.prototype.onPrerender = function() {
      this._flushId = 0;
    };
    AbstractBatchRenderer3.prototype.render = function(element) {
      if (!element._texture.valid) {
        return;
      }
      if (this._vertexCount + element.vertexData.length / 2 > this.size) {
        this.flush();
      }
      this._vertexCount += element.vertexData.length / 2;
      this._indexCount += element.indices.length;
      this._bufferedTextures[this._bufferSize] = element._texture.baseTexture;
      this._bufferedElements[this._bufferSize++] = element;
    };
    AbstractBatchRenderer3.prototype.buildTexturesAndDrawCalls = function() {
      var _a = this, textures = _a._bufferedTextures, MAX_TEXTURES = _a.MAX_TEXTURES;
      var textureArrays = AbstractBatchRenderer3._textureArrayPool;
      var batch = this.renderer.batch;
      var boundTextures = this._tempBoundTextures;
      var touch = this.renderer.textureGC.count;
      var TICK = ++BaseTexture._globalBatch;
      var countTexArrays = 0;
      var texArray = textureArrays[0];
      var start = 0;
      batch.copyBoundTextures(boundTextures, MAX_TEXTURES);
      for (var i = 0; i < this._bufferSize; ++i) {
        var tex = textures[i];
        textures[i] = null;
        if (tex._batchEnabled === TICK) {
          continue;
        }
        if (texArray.count >= MAX_TEXTURES) {
          batch.boundArray(texArray, boundTextures, TICK, MAX_TEXTURES);
          this.buildDrawCalls(texArray, start, i);
          start = i;
          texArray = textureArrays[++countTexArrays];
          ++TICK;
        }
        tex._batchEnabled = TICK;
        tex.touched = touch;
        texArray.elements[texArray.count++] = tex;
      }
      if (texArray.count > 0) {
        batch.boundArray(texArray, boundTextures, TICK, MAX_TEXTURES);
        this.buildDrawCalls(texArray, start, this._bufferSize);
        ++countTexArrays;
        ++TICK;
      }
      for (var i = 0; i < boundTextures.length; i++) {
        boundTextures[i] = null;
      }
      BaseTexture._globalBatch = TICK;
    };
    AbstractBatchRenderer3.prototype.buildDrawCalls = function(texArray, start, finish) {
      var _a = this, elements = _a._bufferedElements, _attributeBuffer = _a._attributeBuffer, _indexBuffer = _a._indexBuffer, vertexSize = _a.vertexSize;
      var drawCalls = AbstractBatchRenderer3._drawCallPool;
      var dcIndex = this._dcIndex;
      var aIndex = this._aIndex;
      var iIndex = this._iIndex;
      var drawCall = drawCalls[dcIndex];
      drawCall.start = this._iIndex;
      drawCall.texArray = texArray;
      for (var i = start; i < finish; ++i) {
        var sprite = elements[i];
        var tex = sprite._texture.baseTexture;
        var spriteBlendMode = premultiplyBlendMode[tex.alphaMode ? 1 : 0][sprite.blendMode];
        elements[i] = null;
        if (start < i && drawCall.blend !== spriteBlendMode) {
          drawCall.size = iIndex - drawCall.start;
          start = i;
          drawCall = drawCalls[++dcIndex];
          drawCall.texArray = texArray;
          drawCall.start = iIndex;
        }
        this.packInterleavedGeometry(sprite, _attributeBuffer, _indexBuffer, aIndex, iIndex);
        aIndex += sprite.vertexData.length / 2 * vertexSize;
        iIndex += sprite.indices.length;
        drawCall.blend = spriteBlendMode;
      }
      if (start < finish) {
        drawCall.size = iIndex - drawCall.start;
        ++dcIndex;
      }
      this._dcIndex = dcIndex;
      this._aIndex = aIndex;
      this._iIndex = iIndex;
    };
    AbstractBatchRenderer3.prototype.bindAndClearTexArray = function(texArray) {
      var textureSystem = this.renderer.texture;
      for (var j2 = 0; j2 < texArray.count; j2++) {
        textureSystem.bind(texArray.elements[j2], texArray.ids[j2]);
        texArray.elements[j2] = null;
      }
      texArray.count = 0;
    };
    AbstractBatchRenderer3.prototype.updateGeometry = function() {
      var _a = this, packedGeometries = _a._packedGeometries, attributeBuffer = _a._attributeBuffer, indexBuffer = _a._indexBuffer;
      if (!settings.CAN_UPLOAD_SAME_BUFFER) {
        if (this._packedGeometryPoolSize <= this._flushId) {
          this._packedGeometryPoolSize++;
          packedGeometries[this._flushId] = new this.geometryClass();
        }
        packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData);
        packedGeometries[this._flushId]._indexBuffer.update(indexBuffer);
        this.renderer.geometry.bind(packedGeometries[this._flushId]);
        this.renderer.geometry.updateBuffers();
        this._flushId++;
      } else {
        packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData);
        packedGeometries[this._flushId]._indexBuffer.update(indexBuffer);
        this.renderer.geometry.updateBuffers();
      }
    };
    AbstractBatchRenderer3.prototype.drawBatches = function() {
      var dcCount = this._dcIndex;
      var _a = this.renderer, gl = _a.gl, stateSystem = _a.state;
      var drawCalls = AbstractBatchRenderer3._drawCallPool;
      var curTexArray = null;
      for (var i = 0; i < dcCount; i++) {
        var _b = drawCalls[i], texArray = _b.texArray, type = _b.type, size = _b.size, start = _b.start, blend = _b.blend;
        if (curTexArray !== texArray) {
          curTexArray = texArray;
          this.bindAndClearTexArray(texArray);
        }
        this.state.blendMode = blend;
        stateSystem.set(this.state);
        gl.drawElements(type, size, gl.UNSIGNED_SHORT, start * 2);
      }
    };
    AbstractBatchRenderer3.prototype.flush = function() {
      if (this._vertexCount === 0) {
        return;
      }
      this._attributeBuffer = this.getAttributeBuffer(this._vertexCount);
      this._indexBuffer = this.getIndexBuffer(this._indexCount);
      this._aIndex = 0;
      this._iIndex = 0;
      this._dcIndex = 0;
      this.buildTexturesAndDrawCalls();
      this.updateGeometry();
      this.drawBatches();
      this._bufferSize = 0;
      this._vertexCount = 0;
      this._indexCount = 0;
    };
    AbstractBatchRenderer3.prototype.start = function() {
      this.renderer.state.set(this.state);
      this.renderer.shader.bind(this._shader);
      if (settings.CAN_UPLOAD_SAME_BUFFER) {
        this.renderer.geometry.bind(this._packedGeometries[this._flushId]);
      }
    };
    AbstractBatchRenderer3.prototype.stop = function() {
      this.flush();
    };
    AbstractBatchRenderer3.prototype.destroy = function() {
      for (var i = 0; i < this._packedGeometryPoolSize; i++) {
        if (this._packedGeometries[i]) {
          this._packedGeometries[i].destroy();
        }
      }
      this.renderer.off("prerender", this.onPrerender, this);
      this._aBuffers = null;
      this._iBuffers = null;
      this._packedGeometries = null;
      this._attributeBuffer = null;
      this._indexBuffer = null;
      if (this._shader) {
        this._shader.destroy();
        this._shader = null;
      }
      _super.prototype.destroy.call(this);
    };
    AbstractBatchRenderer3.prototype.getAttributeBuffer = function(size) {
      var roundedP2 = nextPow2(Math.ceil(size / 8));
      var roundedSizeIndex = log2(roundedP2);
      var roundedSize = roundedP2 * 8;
      if (this._aBuffers.length <= roundedSizeIndex) {
        this._iBuffers.length = roundedSizeIndex + 1;
      }
      var buffer = this._aBuffers[roundedSize];
      if (!buffer) {
        this._aBuffers[roundedSize] = buffer = new ViewableBuffer(roundedSize * this.vertexSize * 4);
      }
      return buffer;
    };
    AbstractBatchRenderer3.prototype.getIndexBuffer = function(size) {
      var roundedP2 = nextPow2(Math.ceil(size / 12));
      var roundedSizeIndex = log2(roundedP2);
      var roundedSize = roundedP2 * 12;
      if (this._iBuffers.length <= roundedSizeIndex) {
        this._iBuffers.length = roundedSizeIndex + 1;
      }
      var buffer = this._iBuffers[roundedSizeIndex];
      if (!buffer) {
        this._iBuffers[roundedSizeIndex] = buffer = new Uint16Array(roundedSize);
      }
      return buffer;
    };
    AbstractBatchRenderer3.prototype.packInterleavedGeometry = function(element, attributeBuffer, indexBuffer, aIndex, iIndex) {
      var uint32View = attributeBuffer.uint32View, float32View = attributeBuffer.float32View;
      var packedVertices = aIndex / this.vertexSize;
      var uvs = element.uvs;
      var indicies = element.indices;
      var vertexData = element.vertexData;
      var textureId = element._texture.baseTexture._batchLocation;
      var alpha = Math.min(element.worldAlpha, 1);
      var argb = alpha < 1 && element._texture.baseTexture.alphaMode ? premultiplyTint(element._tintRGB, alpha) : element._tintRGB + (alpha * 255 << 24);
      for (var i = 0; i < vertexData.length; i += 2) {
        float32View[aIndex++] = vertexData[i];
        float32View[aIndex++] = vertexData[i + 1];
        float32View[aIndex++] = uvs[i];
        float32View[aIndex++] = uvs[i + 1];
        uint32View[aIndex++] = argb;
        float32View[aIndex++] = textureId;
      }
      for (var i = 0; i < indicies.length; i++) {
        indexBuffer[iIndex++] = packedVertices + indicies[i];
      }
    };
    AbstractBatchRenderer3._drawCallPool = [];
    AbstractBatchRenderer3._textureArrayPool = [];
    return AbstractBatchRenderer3;
  }(ObjectRenderer)
);
var BatchShaderGenerator = (
  /** @class */
  function() {
    function BatchShaderGenerator3(vertexSrc, fragTemplate3) {
      this.vertexSrc = vertexSrc;
      this.fragTemplate = fragTemplate3;
      this.programCache = {};
      this.defaultGroupCache = {};
      if (fragTemplate3.indexOf("%count%") < 0) {
        throw new Error('Fragment template must contain "%count%".');
      }
      if (fragTemplate3.indexOf("%forloop%") < 0) {
        throw new Error('Fragment template must contain "%forloop%".');
      }
    }
    BatchShaderGenerator3.prototype.generateShader = function(maxTextures) {
      if (!this.programCache[maxTextures]) {
        var sampleValues = new Int32Array(maxTextures);
        for (var i = 0; i < maxTextures; i++) {
          sampleValues[i] = i;
        }
        this.defaultGroupCache[maxTextures] = UniformGroup.from({ uSamplers: sampleValues }, true);
        var fragmentSrc = this.fragTemplate;
        fragmentSrc = fragmentSrc.replace(/%count%/gi, "" + maxTextures);
        fragmentSrc = fragmentSrc.replace(/%forloop%/gi, this.generateSampleSrc(maxTextures));
        this.programCache[maxTextures] = new Program(this.vertexSrc, fragmentSrc);
      }
      var uniforms = {
        tint: new Float32Array([1, 1, 1, 1]),
        translationMatrix: new Matrix(),
        default: this.defaultGroupCache[maxTextures]
      };
      return new Shader(this.programCache[maxTextures], uniforms);
    };
    BatchShaderGenerator3.prototype.generateSampleSrc = function(maxTextures) {
      var src = "";
      src += "\n";
      src += "\n";
      for (var i = 0; i < maxTextures; i++) {
        if (i > 0) {
          src += "\nelse ";
        }
        if (i < maxTextures - 1) {
          src += "if(vTextureId < " + i + ".5)";
        }
        src += "\n{";
        src += "\n	color = texture2D(uSamplers[" + i + "], vTextureCoord);";
        src += "\n}";
      }
      src += "\n";
      src += "\n";
      return src;
    };
    return BatchShaderGenerator3;
  }()
);
var BatchGeometry = (
  /** @class */
  function(_super) {
    __extends(BatchGeometry3, _super);
    function BatchGeometry3(_static) {
      if (_static === void 0) {
        _static = false;
      }
      var _this = _super.call(this) || this;
      _this._buffer = new Buffer(null, _static, false);
      _this._indexBuffer = new Buffer(null, _static, true);
      _this.addAttribute("aVertexPosition", _this._buffer, 2, false, TYPES.FLOAT).addAttribute("aTextureCoord", _this._buffer, 2, false, TYPES.FLOAT).addAttribute("aColor", _this._buffer, 4, true, TYPES.UNSIGNED_BYTE).addAttribute("aTextureId", _this._buffer, 1, true, TYPES.FLOAT).addIndex(_this._indexBuffer);
      return _this;
    }
    return BatchGeometry3;
  }(Geometry)
);
var defaultVertex$2 = "precision highp float;\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\nattribute float aTextureId;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform vec4 tint;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\n\nvoid main(void){\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vTextureId = aTextureId;\n    vColor = aColor * tint;\n}\n";
var defaultFragment$2 = "varying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\nuniform sampler2D uSamplers[%count%];\n\nvoid main(void){\n    vec4 color;\n    %forloop%\n    gl_FragColor = color * vColor;\n}\n";
var BatchPluginFactory = (
  /** @class */
  function() {
    function BatchPluginFactory3() {
    }
    BatchPluginFactory3.create = function(options) {
      var _a = Object.assign({
        vertex: defaultVertex$2,
        fragment: defaultFragment$2,
        geometryClass: BatchGeometry,
        vertexSize: 6
      }, options), vertex3 = _a.vertex, fragment3 = _a.fragment, vertexSize = _a.vertexSize, geometryClass = _a.geometryClass;
      return (
        /** @class */
        function(_super) {
          __extends(BatchPlugin, _super);
          function BatchPlugin(renderer) {
            var _this = _super.call(this, renderer) || this;
            _this.shaderGenerator = new BatchShaderGenerator(vertex3, fragment3);
            _this.geometryClass = geometryClass;
            _this.vertexSize = vertexSize;
            return _this;
          }
          return BatchPlugin;
        }(AbstractBatchRenderer)
      );
    };
    Object.defineProperty(BatchPluginFactory3, "defaultVertexSrc", {
      /**
       * The default vertex shader source
       *
       * @static
       * @type {string}
       * @constant
       */
      get: function() {
        return defaultVertex$2;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BatchPluginFactory3, "defaultFragmentTemplate", {
      /**
       * The default fragment shader source
       *
       * @static
       * @type {string}
       * @constant
       */
      get: function() {
        return defaultFragment$2;
      },
      enumerable: false,
      configurable: true
    });
    return BatchPluginFactory3;
  }()
);
var BatchRenderer = BatchPluginFactory.create();

// node_modules/@pixi/loaders/lib/loaders.es.js
var LoaderResource = Resource;
var extendStatics2 = function(d2, b2) {
  extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3) {
      if (b3.hasOwnProperty(p2)) {
        d3[p2] = b3[p2];
      }
    }
  };
  return extendStatics2(d2, b2);
};
function __extends2(d2, b2) {
  extendStatics2(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var TextureLoader = (
  /** @class */
  function() {
    function TextureLoader2() {
    }
    TextureLoader2.use = function(resource, next) {
      if (resource.data && resource.type === Resource.TYPE.IMAGE) {
        resource.texture = Texture.fromLoader(resource.data, resource.url, resource.name);
      }
      next();
    };
    return TextureLoader2;
  }()
);
var Loader2 = (
  /** @class */
  function(_super) {
    __extends2(Loader3, _super);
    function Loader3(baseUrl, concurrency) {
      var _this = _super.call(this, baseUrl, concurrency) || this;
      for (var i = 0; i < Loader3._plugins.length; ++i) {
        var plugin = Loader3._plugins[i];
        var pre = plugin.pre, use = plugin.use;
        if (pre) {
          _this.pre(pre);
        }
        if (use) {
          _this.use(use);
        }
      }
      _this._protected = false;
      return _this;
    }
    Loader3.prototype.destroy = function() {
      if (!this._protected) {
        this.reset();
      }
    };
    Object.defineProperty(Loader3, "shared", {
      /**
       * A premade instance of the loader that can be used to load resources.
       * @name shared
       * @type {PIXI.Loader}
       * @static
       * @memberof PIXI.Loader
       */
      get: function() {
        var shared = Loader3._shared;
        if (!shared) {
          shared = new Loader3();
          shared._protected = true;
          Loader3._shared = shared;
        }
        return shared;
      },
      enumerable: false,
      configurable: true
    });
    Loader3.registerPlugin = function(plugin) {
      Loader3._plugins.push(plugin);
      if (plugin.add) {
        plugin.add();
      }
      return Loader3;
    };
    Loader3._plugins = [];
    return Loader3;
  }(Loader)
);
Loader2.registerPlugin({ use: index.parsing });
Loader2.registerPlugin(TextureLoader);
var AppLoaderPlugin = (
  /** @class */
  function() {
    function AppLoaderPlugin2() {
    }
    AppLoaderPlugin2.init = function(options) {
      options = Object.assign({
        sharedLoader: false
      }, options);
      this.loader = options.sharedLoader ? Loader2.shared : new Loader2();
    };
    AppLoaderPlugin2.destroy = function() {
      if (this.loader) {
        this.loader.destroy();
        this.loader = null;
      }
    };
    return AppLoaderPlugin2;
  }()
);

// node_modules/pixi-sound/node_modules/@pixi/settings/lib/settings.es.js
var isMobile3 = isMobile(window.navigator);
function maxRecommendedTextures2(max) {
  var allowMax = true;
  if (isMobile3.tablet || isMobile3.phone) {
    if (isMobile3.apple.device) {
      var match = navigator.userAgent.match(/OS (\d+)_(\d+)?/);
      if (match) {
        var majorVersion = parseInt(match[1], 10);
        if (majorVersion < 11) {
          allowMax = false;
        }
      }
    }
    if (isMobile3.android.device) {
      var match = navigator.userAgent.match(/Android\s([0-9.]*)/);
      if (match) {
        var majorVersion = parseInt(match[1], 10);
        if (majorVersion < 7) {
          allowMax = false;
        }
      }
    }
  }
  return allowMax ? max : 4;
}
function canUploadSameBuffer2() {
  return !isMobile3.apple.device;
}
var settings2 = {
  /**
   * If set to true WebGL will attempt make textures mimpaped by default.
   * Mipmapping will only succeed if the base texture uploaded has power of two dimensions.
   *
   * @static
   * @name MIPMAP_TEXTURES
   * @memberof PIXI.settings
   * @type {PIXI.MIPMAP_MODES}
   * @default PIXI.MIPMAP_MODES.POW2
   */
  MIPMAP_TEXTURES: 1,
  /**
   * Default anisotropic filtering level of textures.
   * Usually from 0 to 16
   *
   * @static
   * @name ANISOTROPIC_LEVEL
   * @memberof PIXI.settings
   * @type {number}
   * @default 0
   */
  ANISOTROPIC_LEVEL: 0,
  /**
   * Default resolution / device pixel ratio of the renderer.
   *
   * @static
   * @name RESOLUTION
   * @memberof PIXI.settings
   * @type {number}
   * @default 1
   */
  RESOLUTION: 1,
  /**
   * Default filter resolution.
   *
   * @static
   * @name FILTER_RESOLUTION
   * @memberof PIXI.settings
   * @type {number}
   * @default 1
   */
  FILTER_RESOLUTION: 1,
  /**
   * The maximum textures that this device supports.
   *
   * @static
   * @name SPRITE_MAX_TEXTURES
   * @memberof PIXI.settings
   * @type {number}
   * @default 32
   */
  SPRITE_MAX_TEXTURES: maxRecommendedTextures2(32),
  // TODO: maybe change to SPRITE.BATCH_SIZE: 2000
  // TODO: maybe add PARTICLE.BATCH_SIZE: 15000
  /**
   * The default sprite batch size.
   *
   * The default aims to balance desktop and mobile devices.
   *
   * @static
   * @name SPRITE_BATCH_SIZE
   * @memberof PIXI.settings
   * @type {number}
   * @default 4096
   */
  SPRITE_BATCH_SIZE: 4096,
  /**
   * The default render options if none are supplied to {@link PIXI.Renderer}
   * or {@link PIXI.CanvasRenderer}.
   *
   * @static
   * @name RENDER_OPTIONS
   * @memberof PIXI.settings
   * @type {object}
   * @property {HTMLCanvasElement} view=null
   * @property {number} resolution=1
   * @property {boolean} antialias=false
   * @property {boolean} autoDensity=false
   * @property {boolean} transparent=false
   * @property {number} backgroundColor=0x000000
   * @property {boolean} clearBeforeRender=true
   * @property {boolean} preserveDrawingBuffer=false
   * @property {number} width=800
   * @property {number} height=600
   * @property {boolean} legacy=false
   */
  RENDER_OPTIONS: {
    view: null,
    antialias: false,
    autoDensity: false,
    transparent: false,
    backgroundColor: 0,
    clearBeforeRender: true,
    preserveDrawingBuffer: false,
    width: 800,
    height: 600,
    legacy: false
  },
  /**
   * Default Garbage Collection mode.
   *
   * @static
   * @name GC_MODE
   * @memberof PIXI.settings
   * @type {PIXI.GC_MODES}
   * @default PIXI.GC_MODES.AUTO
   */
  GC_MODE: 0,
  /**
   * Default Garbage Collection max idle.
   *
   * @static
   * @name GC_MAX_IDLE
   * @memberof PIXI.settings
   * @type {number}
   * @default 3600
   */
  GC_MAX_IDLE: 60 * 60,
  /**
   * Default Garbage Collection maximum check count.
   *
   * @static
   * @name GC_MAX_CHECK_COUNT
   * @memberof PIXI.settings
   * @type {number}
   * @default 600
   */
  GC_MAX_CHECK_COUNT: 60 * 10,
  /**
   * Default wrap modes that are supported by pixi.
   *
   * @static
   * @name WRAP_MODE
   * @memberof PIXI.settings
   * @type {PIXI.WRAP_MODES}
   * @default PIXI.WRAP_MODES.CLAMP
   */
  WRAP_MODE: 33071,
  /**
   * Default scale mode for textures.
   *
   * @static
   * @name SCALE_MODE
   * @memberof PIXI.settings
   * @type {PIXI.SCALE_MODES}
   * @default PIXI.SCALE_MODES.LINEAR
   */
  SCALE_MODE: 1,
  /**
   * Default specify float precision in vertex shader.
   *
   * @static
   * @name PRECISION_VERTEX
   * @memberof PIXI.settings
   * @type {PIXI.PRECISION}
   * @default PIXI.PRECISION.HIGH
   */
  PRECISION_VERTEX: "highp",
  /**
   * Default specify float precision in fragment shader.
   * iOS is best set at highp due to https://github.com/pixijs/pixi.js/issues/3742
   *
   * @static
   * @name PRECISION_FRAGMENT
   * @memberof PIXI.settings
   * @type {PIXI.PRECISION}
   * @default PIXI.PRECISION.MEDIUM
   */
  PRECISION_FRAGMENT: isMobile3.apple.device ? "highp" : "mediump",
  /**
   * Can we upload the same buffer in a single frame?
   *
   * @static
   * @name CAN_UPLOAD_SAME_BUFFER
   * @memberof PIXI.settings
   * @type {boolean}
   */
  CAN_UPLOAD_SAME_BUFFER: canUploadSameBuffer2(),
  /**
   * Enables bitmap creation before image load. This feature is experimental.
   *
   * @static
   * @name CREATE_IMAGE_BITMAP
   * @memberof PIXI.settings
   * @type {boolean}
   * @default false
   */
  CREATE_IMAGE_BITMAP: false,
  /**
   * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.
   * Advantages can include sharper image quality (like text) and faster rendering on canvas.
   * The main disadvantage is movement of objects may appear less smooth.
   *
   * @static
   * @constant
   * @memberof PIXI.settings
   * @type {boolean}
   * @default false
   */
  ROUND_PIXELS: false
};

// node_modules/pixi-sound/node_modules/@pixi/ticker/lib/ticker.es.js
settings2.TARGET_FPMS = 0.06;
var UPDATE_PRIORITY2;
(function(UPDATE_PRIORITY3) {
  UPDATE_PRIORITY3[UPDATE_PRIORITY3["INTERACTION"] = 50] = "INTERACTION";
  UPDATE_PRIORITY3[UPDATE_PRIORITY3["HIGH"] = 25] = "HIGH";
  UPDATE_PRIORITY3[UPDATE_PRIORITY3["NORMAL"] = 0] = "NORMAL";
  UPDATE_PRIORITY3[UPDATE_PRIORITY3["LOW"] = -25] = "LOW";
  UPDATE_PRIORITY3[UPDATE_PRIORITY3["UTILITY"] = -50] = "UTILITY";
})(UPDATE_PRIORITY2 || (UPDATE_PRIORITY2 = {}));
var TickerListener2 = (
  /** @class */
  function() {
    function TickerListener3(fn, context3, priority, once) {
      if (context3 === void 0) {
        context3 = null;
      }
      if (priority === void 0) {
        priority = 0;
      }
      if (once === void 0) {
        once = false;
      }
      this.fn = fn;
      this.context = context3;
      this.priority = priority;
      this.once = once;
      this.next = null;
      this.previous = null;
      this._destroyed = false;
    }
    TickerListener3.prototype.match = function(fn, context3) {
      if (context3 === void 0) {
        context3 = null;
      }
      return this.fn === fn && this.context === context3;
    };
    TickerListener3.prototype.emit = function(deltaTime) {
      if (this.fn) {
        if (this.context) {
          this.fn.call(this.context, deltaTime);
        } else {
          this.fn(deltaTime);
        }
      }
      var redirect = this.next;
      if (this.once) {
        this.destroy(true);
      }
      if (this._destroyed) {
        this.next = null;
      }
      return redirect;
    };
    TickerListener3.prototype.connect = function(previous) {
      this.previous = previous;
      if (previous.next) {
        previous.next.previous = this;
      }
      this.next = previous.next;
      previous.next = this;
    };
    TickerListener3.prototype.destroy = function(hard) {
      if (hard === void 0) {
        hard = false;
      }
      this._destroyed = true;
      this.fn = null;
      this.context = null;
      if (this.previous) {
        this.previous.next = this.next;
      }
      if (this.next) {
        this.next.previous = this.previous;
      }
      var redirect = this.next;
      this.next = hard ? null : redirect;
      this.previous = null;
      return redirect;
    };
    return TickerListener3;
  }()
);
var Ticker2 = (
  /** @class */
  function() {
    function Ticker3() {
      var _this = this;
      this._head = new TickerListener2(null, null, Infinity);
      this._requestId = null;
      this._maxElapsedMS = 100;
      this._minElapsedMS = 0;
      this.autoStart = false;
      this.deltaTime = 1;
      this.deltaMS = 1 / settings2.TARGET_FPMS;
      this.elapsedMS = 1 / settings2.TARGET_FPMS;
      this.lastTime = -1;
      this.speed = 1;
      this.started = false;
      this._protected = false;
      this._lastFrame = -1;
      this._tick = function(time) {
        _this._requestId = null;
        if (_this.started) {
          _this.update(time);
          if (_this.started && _this._requestId === null && _this._head.next) {
            _this._requestId = requestAnimationFrame(_this._tick);
          }
        }
      };
    }
    Ticker3.prototype._requestIfNeeded = function() {
      if (this._requestId === null && this._head.next) {
        this.lastTime = performance.now();
        this._lastFrame = this.lastTime;
        this._requestId = requestAnimationFrame(this._tick);
      }
    };
    Ticker3.prototype._cancelIfNeeded = function() {
      if (this._requestId !== null) {
        cancelAnimationFrame(this._requestId);
        this._requestId = null;
      }
    };
    Ticker3.prototype._startIfPossible = function() {
      if (this.started) {
        this._requestIfNeeded();
      } else if (this.autoStart) {
        this.start();
      }
    };
    Ticker3.prototype.add = function(fn, context3, priority) {
      if (priority === void 0) {
        priority = UPDATE_PRIORITY2.NORMAL;
      }
      return this._addListener(new TickerListener2(fn, context3, priority));
    };
    Ticker3.prototype.addOnce = function(fn, context3, priority) {
      if (priority === void 0) {
        priority = UPDATE_PRIORITY2.NORMAL;
      }
      return this._addListener(new TickerListener2(fn, context3, priority, true));
    };
    Ticker3.prototype._addListener = function(listener) {
      var current = this._head.next;
      var previous = this._head;
      if (!current) {
        listener.connect(previous);
      } else {
        while (current) {
          if (listener.priority > current.priority) {
            listener.connect(previous);
            break;
          }
          previous = current;
          current = current.next;
        }
        if (!listener.previous) {
          listener.connect(previous);
        }
      }
      this._startIfPossible();
      return this;
    };
    Ticker3.prototype.remove = function(fn, context3) {
      var listener = this._head.next;
      while (listener) {
        if (listener.match(fn, context3)) {
          listener = listener.destroy();
        } else {
          listener = listener.next;
        }
      }
      if (!this._head.next) {
        this._cancelIfNeeded();
      }
      return this;
    };
    Object.defineProperty(Ticker3.prototype, "count", {
      /**
       * The number of listeners on this ticker, calculated by walking through linked list
       *
       * @readonly
       * @member {number}
       */
      get: function() {
        if (!this._head) {
          return 0;
        }
        var count = 0;
        var current = this._head;
        while (current = current.next) {
          count++;
        }
        return count;
      },
      enumerable: false,
      configurable: true
    });
    Ticker3.prototype.start = function() {
      if (!this.started) {
        this.started = true;
        this._requestIfNeeded();
      }
    };
    Ticker3.prototype.stop = function() {
      if (this.started) {
        this.started = false;
        this._cancelIfNeeded();
      }
    };
    Ticker3.prototype.destroy = function() {
      if (!this._protected) {
        this.stop();
        var listener = this._head.next;
        while (listener) {
          listener = listener.destroy(true);
        }
        this._head.destroy();
        this._head = null;
      }
    };
    Ticker3.prototype.update = function(currentTime) {
      if (currentTime === void 0) {
        currentTime = performance.now();
      }
      var elapsedMS;
      if (currentTime > this.lastTime) {
        elapsedMS = this.elapsedMS = currentTime - this.lastTime;
        if (elapsedMS > this._maxElapsedMS) {
          elapsedMS = this._maxElapsedMS;
        }
        elapsedMS *= this.speed;
        if (this._minElapsedMS) {
          var delta = currentTime - this._lastFrame | 0;
          if (delta < this._minElapsedMS) {
            return;
          }
          this._lastFrame = currentTime - delta % this._minElapsedMS;
        }
        this.deltaMS = elapsedMS;
        this.deltaTime = this.deltaMS * settings2.TARGET_FPMS;
        var head = this._head;
        var listener = head.next;
        while (listener) {
          listener = listener.emit(this.deltaTime);
        }
        if (!head.next) {
          this._cancelIfNeeded();
        }
      } else {
        this.deltaTime = this.deltaMS = this.elapsedMS = 0;
      }
      this.lastTime = currentTime;
    };
    Object.defineProperty(Ticker3.prototype, "FPS", {
      /**
       * The frames per second at which this ticker is running.
       * The default is approximately 60 in most modern browsers.
       * **Note:** This does not factor in the value of
       * {@link PIXI.Ticker#speed}, which is specific
       * to scaling {@link PIXI.Ticker#deltaTime}.
       *
       * @member {number}
       * @readonly
       */
      get: function() {
        return 1e3 / this.elapsedMS;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Ticker3.prototype, "minFPS", {
      /**
       * Manages the maximum amount of milliseconds allowed to
       * elapse between invoking {@link PIXI.Ticker#update}.
       * This value is used to cap {@link PIXI.Ticker#deltaTime},
       * but does not effect the measured value of {@link PIXI.Ticker#FPS}.
       * When setting this property it is clamped to a value between
       * `0` and `PIXI.settings.TARGET_FPMS * 1000`.
       *
       * @member {number}
       * @default 10
       */
      get: function() {
        return 1e3 / this._maxElapsedMS;
      },
      set: function(fps) {
        var minFPS = Math.min(this.maxFPS, fps);
        var minFPMS = Math.min(Math.max(0, minFPS) / 1e3, settings2.TARGET_FPMS);
        this._maxElapsedMS = 1 / minFPMS;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Ticker3.prototype, "maxFPS", {
      /**
       * Manages the minimum amount of milliseconds required to
       * elapse between invoking {@link PIXI.Ticker#update}.
       * This will effect the measured value of {@link PIXI.Ticker#FPS}.
       * If it is set to `0`, then there is no limit; PixiJS will render as many frames as it can.
       * Otherwise it will be at least `minFPS`
       *
       * @member {number}
       * @default 0
       */
      get: function() {
        if (this._minElapsedMS) {
          return Math.round(1e3 / this._minElapsedMS);
        }
        return 0;
      },
      set: function(fps) {
        if (fps === 0) {
          this._minElapsedMS = 0;
        } else {
          var maxFPS = Math.max(this.minFPS, fps);
          this._minElapsedMS = 1 / (maxFPS / 1e3);
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Ticker3, "shared", {
      /**
       * The shared ticker instance used by {@link PIXI.AnimatedSprite} and by
       * {@link PIXI.VideoResource} to update animation frames / video textures.
       *
       * It may also be used by {@link PIXI.Application} if created with the `sharedTicker` option property set to true.
       *
       * The property {@link PIXI.Ticker#autoStart} is set to `true` for this instance.
       * Please follow the examples for usage, including how to opt-out of auto-starting the shared ticker.
       *
       * @example
       * let ticker = PIXI.Ticker.shared;
       * // Set this to prevent starting this ticker when listeners are added.
       * // By default this is true only for the PIXI.Ticker.shared instance.
       * ticker.autoStart = false;
       * // FYI, call this to ensure the ticker is stopped. It should be stopped
       * // if you have not attempted to render anything yet.
       * ticker.stop();
       * // Call this when you are ready for a running shared ticker.
       * ticker.start();
       *
       * @example
       * // You may use the shared ticker to render...
       * let renderer = PIXI.autoDetectRenderer();
       * let stage = new PIXI.Container();
       * document.body.appendChild(renderer.view);
       * ticker.add(function (time) {
       *     renderer.render(stage);
       * });
       *
       * @example
       * // Or you can just update it manually.
       * ticker.autoStart = false;
       * ticker.stop();
       * function animate(time) {
       *     ticker.update(time);
       *     renderer.render(stage);
       *     requestAnimationFrame(animate);
       * }
       * animate(performance.now());
       *
       * @member {PIXI.Ticker}
       * @static
       */
      get: function() {
        if (!Ticker3._shared) {
          var shared = Ticker3._shared = new Ticker3();
          shared.autoStart = true;
          shared._protected = true;
        }
        return Ticker3._shared;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Ticker3, "system", {
      /**
       * The system ticker instance used by {@link PIXI.InteractionManager} and by
       * {@link PIXI.BasePrepare} for core timing functionality that shouldn't usually need to be paused,
       * unlike the `shared` ticker which drives visual animations and rendering which may want to be paused.
       *
       * The property {@link PIXI.Ticker#autoStart} is set to `true` for this instance.
       *
       * @member {PIXI.Ticker}
       * @static
       */
      get: function() {
        if (!Ticker3._system) {
          var system = Ticker3._system = new Ticker3();
          system.autoStart = true;
          system._protected = true;
        }
        return Ticker3._system;
      },
      enumerable: false,
      configurable: true
    });
    return Ticker3;
  }()
);
var TickerPlugin2 = (
  /** @class */
  function() {
    function TickerPlugin3() {
    }
    TickerPlugin3.init = function(options) {
      var _this = this;
      options = Object.assign({
        autoStart: true,
        sharedTicker: false
      }, options);
      Object.defineProperty(this, "ticker", {
        set: function(ticker) {
          if (this._ticker) {
            this._ticker.remove(this.render, this);
          }
          this._ticker = ticker;
          if (ticker) {
            ticker.add(this.render, this, UPDATE_PRIORITY2.LOW);
          }
        },
        get: function() {
          return this._ticker;
        }
      });
      this.stop = function() {
        _this._ticker.stop();
      };
      this.start = function() {
        _this._ticker.start();
      };
      this._ticker = null;
      this.ticker = options.sharedTicker ? Ticker2.shared : new Ticker2();
      if (options.autoStart) {
        this.start();
      }
    };
    TickerPlugin3.destroy = function() {
      if (this._ticker) {
        var oldTicker = this._ticker;
        this.ticker = null;
        oldTicker.destroy();
      }
    };
    return TickerPlugin3;
  }()
);

// node_modules/pixi-sound/node_modules/@pixi/utils/lib/utils.es.js
var import_eventemitter32 = __toESM(require_eventemitter3());
var import_earcut2 = __toESM(require_earcut());
var import_url3 = __toESM(require_url());
var import_url4 = __toESM(require_url());

// node_modules/pixi-sound/node_modules/@pixi/constants/lib/constants.es.js
var ENV2;
(function(ENV3) {
  ENV3[ENV3["WEBGL_LEGACY"] = 0] = "WEBGL_LEGACY";
  ENV3[ENV3["WEBGL"] = 1] = "WEBGL";
  ENV3[ENV3["WEBGL2"] = 2] = "WEBGL2";
})(ENV2 || (ENV2 = {}));
var RENDERER_TYPE2;
(function(RENDERER_TYPE3) {
  RENDERER_TYPE3[RENDERER_TYPE3["UNKNOWN"] = 0] = "UNKNOWN";
  RENDERER_TYPE3[RENDERER_TYPE3["WEBGL"] = 1] = "WEBGL";
  RENDERER_TYPE3[RENDERER_TYPE3["CANVAS"] = 2] = "CANVAS";
})(RENDERER_TYPE2 || (RENDERER_TYPE2 = {}));
var BUFFER_BITS2;
(function(BUFFER_BITS3) {
  BUFFER_BITS3[BUFFER_BITS3["COLOR"] = 16384] = "COLOR";
  BUFFER_BITS3[BUFFER_BITS3["DEPTH"] = 256] = "DEPTH";
  BUFFER_BITS3[BUFFER_BITS3["STENCIL"] = 1024] = "STENCIL";
})(BUFFER_BITS2 || (BUFFER_BITS2 = {}));
var BLEND_MODES2;
(function(BLEND_MODES3) {
  BLEND_MODES3[BLEND_MODES3["NORMAL"] = 0] = "NORMAL";
  BLEND_MODES3[BLEND_MODES3["ADD"] = 1] = "ADD";
  BLEND_MODES3[BLEND_MODES3["MULTIPLY"] = 2] = "MULTIPLY";
  BLEND_MODES3[BLEND_MODES3["SCREEN"] = 3] = "SCREEN";
  BLEND_MODES3[BLEND_MODES3["OVERLAY"] = 4] = "OVERLAY";
  BLEND_MODES3[BLEND_MODES3["DARKEN"] = 5] = "DARKEN";
  BLEND_MODES3[BLEND_MODES3["LIGHTEN"] = 6] = "LIGHTEN";
  BLEND_MODES3[BLEND_MODES3["COLOR_DODGE"] = 7] = "COLOR_DODGE";
  BLEND_MODES3[BLEND_MODES3["COLOR_BURN"] = 8] = "COLOR_BURN";
  BLEND_MODES3[BLEND_MODES3["HARD_LIGHT"] = 9] = "HARD_LIGHT";
  BLEND_MODES3[BLEND_MODES3["SOFT_LIGHT"] = 10] = "SOFT_LIGHT";
  BLEND_MODES3[BLEND_MODES3["DIFFERENCE"] = 11] = "DIFFERENCE";
  BLEND_MODES3[BLEND_MODES3["EXCLUSION"] = 12] = "EXCLUSION";
  BLEND_MODES3[BLEND_MODES3["HUE"] = 13] = "HUE";
  BLEND_MODES3[BLEND_MODES3["SATURATION"] = 14] = "SATURATION";
  BLEND_MODES3[BLEND_MODES3["COLOR"] = 15] = "COLOR";
  BLEND_MODES3[BLEND_MODES3["LUMINOSITY"] = 16] = "LUMINOSITY";
  BLEND_MODES3[BLEND_MODES3["NORMAL_NPM"] = 17] = "NORMAL_NPM";
  BLEND_MODES3[BLEND_MODES3["ADD_NPM"] = 18] = "ADD_NPM";
  BLEND_MODES3[BLEND_MODES3["SCREEN_NPM"] = 19] = "SCREEN_NPM";
  BLEND_MODES3[BLEND_MODES3["NONE"] = 20] = "NONE";
  BLEND_MODES3[BLEND_MODES3["SRC_OVER"] = 0] = "SRC_OVER";
  BLEND_MODES3[BLEND_MODES3["SRC_IN"] = 21] = "SRC_IN";
  BLEND_MODES3[BLEND_MODES3["SRC_OUT"] = 22] = "SRC_OUT";
  BLEND_MODES3[BLEND_MODES3["SRC_ATOP"] = 23] = "SRC_ATOP";
  BLEND_MODES3[BLEND_MODES3["DST_OVER"] = 24] = "DST_OVER";
  BLEND_MODES3[BLEND_MODES3["DST_IN"] = 25] = "DST_IN";
  BLEND_MODES3[BLEND_MODES3["DST_OUT"] = 26] = "DST_OUT";
  BLEND_MODES3[BLEND_MODES3["DST_ATOP"] = 27] = "DST_ATOP";
  BLEND_MODES3[BLEND_MODES3["ERASE"] = 26] = "ERASE";
  BLEND_MODES3[BLEND_MODES3["SUBTRACT"] = 28] = "SUBTRACT";
  BLEND_MODES3[BLEND_MODES3["XOR"] = 29] = "XOR";
})(BLEND_MODES2 || (BLEND_MODES2 = {}));
var DRAW_MODES2;
(function(DRAW_MODES3) {
  DRAW_MODES3[DRAW_MODES3["POINTS"] = 0] = "POINTS";
  DRAW_MODES3[DRAW_MODES3["LINES"] = 1] = "LINES";
  DRAW_MODES3[DRAW_MODES3["LINE_LOOP"] = 2] = "LINE_LOOP";
  DRAW_MODES3[DRAW_MODES3["LINE_STRIP"] = 3] = "LINE_STRIP";
  DRAW_MODES3[DRAW_MODES3["TRIANGLES"] = 4] = "TRIANGLES";
  DRAW_MODES3[DRAW_MODES3["TRIANGLE_STRIP"] = 5] = "TRIANGLE_STRIP";
  DRAW_MODES3[DRAW_MODES3["TRIANGLE_FAN"] = 6] = "TRIANGLE_FAN";
})(DRAW_MODES2 || (DRAW_MODES2 = {}));
var FORMATS2;
(function(FORMATS3) {
  FORMATS3[FORMATS3["RGBA"] = 6408] = "RGBA";
  FORMATS3[FORMATS3["RGB"] = 6407] = "RGB";
  FORMATS3[FORMATS3["ALPHA"] = 6406] = "ALPHA";
  FORMATS3[FORMATS3["LUMINANCE"] = 6409] = "LUMINANCE";
  FORMATS3[FORMATS3["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
  FORMATS3[FORMATS3["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
  FORMATS3[FORMATS3["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
})(FORMATS2 || (FORMATS2 = {}));
var TARGETS2;
(function(TARGETS3) {
  TARGETS3[TARGETS3["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
  TARGETS3[TARGETS3["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
  TARGETS3[TARGETS3["TEXTURE_2D_ARRAY"] = 35866] = "TEXTURE_2D_ARRAY";
  TARGETS3[TARGETS3["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
  TARGETS3[TARGETS3["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
  TARGETS3[TARGETS3["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
  TARGETS3[TARGETS3["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
  TARGETS3[TARGETS3["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
  TARGETS3[TARGETS3["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
})(TARGETS2 || (TARGETS2 = {}));
var TYPES2;
(function(TYPES3) {
  TYPES3[TYPES3["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
  TYPES3[TYPES3["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
  TYPES3[TYPES3["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
  TYPES3[TYPES3["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
  TYPES3[TYPES3["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
  TYPES3[TYPES3["FLOAT"] = 5126] = "FLOAT";
  TYPES3[TYPES3["HALF_FLOAT"] = 36193] = "HALF_FLOAT";
})(TYPES2 || (TYPES2 = {}));
var SCALE_MODES2;
(function(SCALE_MODES3) {
  SCALE_MODES3[SCALE_MODES3["NEAREST"] = 0] = "NEAREST";
  SCALE_MODES3[SCALE_MODES3["LINEAR"] = 1] = "LINEAR";
})(SCALE_MODES2 || (SCALE_MODES2 = {}));
var WRAP_MODES2;
(function(WRAP_MODES3) {
  WRAP_MODES3[WRAP_MODES3["CLAMP"] = 33071] = "CLAMP";
  WRAP_MODES3[WRAP_MODES3["REPEAT"] = 10497] = "REPEAT";
  WRAP_MODES3[WRAP_MODES3["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
})(WRAP_MODES2 || (WRAP_MODES2 = {}));
var MIPMAP_MODES2;
(function(MIPMAP_MODES3) {
  MIPMAP_MODES3[MIPMAP_MODES3["OFF"] = 0] = "OFF";
  MIPMAP_MODES3[MIPMAP_MODES3["POW2"] = 1] = "POW2";
  MIPMAP_MODES3[MIPMAP_MODES3["ON"] = 2] = "ON";
})(MIPMAP_MODES2 || (MIPMAP_MODES2 = {}));
var ALPHA_MODES2;
(function(ALPHA_MODES3) {
  ALPHA_MODES3[ALPHA_MODES3["NPM"] = 0] = "NPM";
  ALPHA_MODES3[ALPHA_MODES3["UNPACK"] = 1] = "UNPACK";
  ALPHA_MODES3[ALPHA_MODES3["PMA"] = 2] = "PMA";
  ALPHA_MODES3[ALPHA_MODES3["NO_PREMULTIPLIED_ALPHA"] = 0] = "NO_PREMULTIPLIED_ALPHA";
  ALPHA_MODES3[ALPHA_MODES3["PREMULTIPLY_ON_UPLOAD"] = 1] = "PREMULTIPLY_ON_UPLOAD";
  ALPHA_MODES3[ALPHA_MODES3["PREMULTIPLY_ALPHA"] = 2] = "PREMULTIPLY_ALPHA";
})(ALPHA_MODES2 || (ALPHA_MODES2 = {}));
var CLEAR_MODES2;
(function(CLEAR_MODES3) {
  CLEAR_MODES3[CLEAR_MODES3["NO"] = 0] = "NO";
  CLEAR_MODES3[CLEAR_MODES3["YES"] = 1] = "YES";
  CLEAR_MODES3[CLEAR_MODES3["AUTO"] = 2] = "AUTO";
  CLEAR_MODES3[CLEAR_MODES3["BLEND"] = 0] = "BLEND";
  CLEAR_MODES3[CLEAR_MODES3["CLEAR"] = 1] = "CLEAR";
  CLEAR_MODES3[CLEAR_MODES3["BLIT"] = 2] = "BLIT";
})(CLEAR_MODES2 || (CLEAR_MODES2 = {}));
var GC_MODES2;
(function(GC_MODES3) {
  GC_MODES3[GC_MODES3["AUTO"] = 0] = "AUTO";
  GC_MODES3[GC_MODES3["MANUAL"] = 1] = "MANUAL";
})(GC_MODES2 || (GC_MODES2 = {}));
var PRECISION2;
(function(PRECISION3) {
  PRECISION3["LOW"] = "lowp";
  PRECISION3["MEDIUM"] = "mediump";
  PRECISION3["HIGH"] = "highp";
})(PRECISION2 || (PRECISION2 = {}));
var MASK_TYPES2;
(function(MASK_TYPES3) {
  MASK_TYPES3[MASK_TYPES3["NONE"] = 0] = "NONE";
  MASK_TYPES3[MASK_TYPES3["SCISSOR"] = 1] = "SCISSOR";
  MASK_TYPES3[MASK_TYPES3["STENCIL"] = 2] = "STENCIL";
  MASK_TYPES3[MASK_TYPES3["SPRITE"] = 3] = "SPRITE";
})(MASK_TYPES2 || (MASK_TYPES2 = {}));
var MSAA_QUALITY2;
(function(MSAA_QUALITY3) {
  MSAA_QUALITY3[MSAA_QUALITY3["NONE"] = 0] = "NONE";
  MSAA_QUALITY3[MSAA_QUALITY3["LOW"] = 2] = "LOW";
  MSAA_QUALITY3[MSAA_QUALITY3["MEDIUM"] = 4] = "MEDIUM";
  MSAA_QUALITY3[MSAA_QUALITY3["HIGH"] = 8] = "HIGH";
})(MSAA_QUALITY2 || (MSAA_QUALITY2 = {}));

// node_modules/pixi-sound/node_modules/@pixi/utils/lib/utils.es.js
settings2.RETINA_PREFIX = /@([0-9\.]+)x/;
settings2.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = true;
var saidHello2 = false;
var VERSION2 = "5.3.12";
function sayHello2(type) {
  var _a;
  if (saidHello2) {
    return;
  }
  if (navigator.userAgent.toLowerCase().indexOf("chrome") > -1) {
    var args = [
      "\n %c %c %c PixiJS " + VERSION2 + " - ✰ " + type + " ✰  %c  %c  http://www.pixijs.com/  %c %c ♥%c♥%c♥ \n\n",
      "background: #ff66a5; padding:5px 0;",
      "background: #ff66a5; padding:5px 0;",
      "color: #ff66a5; background: #030307; padding:5px 0;",
      "background: #ff66a5; padding:5px 0;",
      "background: #ffc3dc; padding:5px 0;",
      "background: #ff66a5; padding:5px 0;",
      "color: #ff2424; background: #fff; padding:5px 0;",
      "color: #ff2424; background: #fff; padding:5px 0;",
      "color: #ff2424; background: #fff; padding:5px 0;"
    ];
    (_a = window.console).log.apply(_a, args);
  } else if (window.console) {
    window.console.log("PixiJS " + VERSION2 + " - " + type + " - http://www.pixijs.com/");
  }
  saidHello2 = true;
}
var supported2;
function isWebGLSupported2() {
  if (typeof supported2 === "undefined") {
    supported2 = function supported3() {
      var contextOptions = {
        stencil: true,
        failIfMajorPerformanceCaveat: settings2.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT
      };
      try {
        if (!window.WebGLRenderingContext) {
          return false;
        }
        var canvas = document.createElement("canvas");
        var gl = canvas.getContext("webgl", contextOptions) || canvas.getContext("experimental-webgl", contextOptions);
        var success = !!(gl && gl.getContextAttributes().stencil);
        if (gl) {
          var loseContext = gl.getExtension("WEBGL_lose_context");
          if (loseContext) {
            loseContext.loseContext();
          }
        }
        gl = null;
        return success;
      } catch (e) {
        return false;
      }
    }();
  }
  return supported2;
}
function hex2rgb2(hex, out) {
  if (out === void 0) {
    out = [];
  }
  out[0] = (hex >> 16 & 255) / 255;
  out[1] = (hex >> 8 & 255) / 255;
  out[2] = (hex & 255) / 255;
  return out;
}
function hex2string2(hex) {
  var hexString = hex.toString(16);
  hexString = "000000".substr(0, 6 - hexString.length) + hexString;
  return "#" + hexString;
}
function mapPremultipliedBlendModes2() {
  var pm = [];
  var npm = [];
  for (var i = 0; i < 32; i++) {
    pm[i] = i;
    npm[i] = i;
  }
  pm[BLEND_MODES2.NORMAL_NPM] = BLEND_MODES2.NORMAL;
  pm[BLEND_MODES2.ADD_NPM] = BLEND_MODES2.ADD;
  pm[BLEND_MODES2.SCREEN_NPM] = BLEND_MODES2.SCREEN;
  npm[BLEND_MODES2.NORMAL] = BLEND_MODES2.NORMAL_NPM;
  npm[BLEND_MODES2.ADD] = BLEND_MODES2.ADD_NPM;
  npm[BLEND_MODES2.SCREEN] = BLEND_MODES2.SCREEN_NPM;
  var array = [];
  array.push(npm);
  array.push(pm);
  return array;
}
var premultiplyBlendMode2 = mapPremultipliedBlendModes2();
function premultiplyTint2(tint, alpha) {
  if (alpha === 1) {
    return (alpha * 255 << 24) + tint;
  }
  if (alpha === 0) {
    return 0;
  }
  var R2 = tint >> 16 & 255;
  var G2 = tint >> 8 & 255;
  var B2 = tint & 255;
  R2 = R2 * alpha + 0.5 | 0;
  G2 = G2 * alpha + 0.5 | 0;
  B2 = B2 * alpha + 0.5 | 0;
  return (alpha * 255 << 24) + (R2 << 16) + (G2 << 8) + B2;
}
function nextPow22(v2) {
  v2 += v2 === 0 ? 1 : 0;
  --v2;
  v2 |= v2 >>> 1;
  v2 |= v2 >>> 2;
  v2 |= v2 >>> 4;
  v2 |= v2 >>> 8;
  v2 |= v2 >>> 16;
  return v2 + 1;
}
function isPow22(v2) {
  return !(v2 & v2 - 1) && !!v2;
}
function log22(v2) {
  var r2 = (v2 > 65535 ? 1 : 0) << 4;
  v2 >>>= r2;
  var shift = (v2 > 255 ? 1 : 0) << 3;
  v2 >>>= shift;
  r2 |= shift;
  shift = (v2 > 15 ? 1 : 0) << 2;
  v2 >>>= shift;
  r2 |= shift;
  shift = (v2 > 3 ? 1 : 0) << 1;
  v2 >>>= shift;
  r2 |= shift;
  return r2 | v2 >> 1;
}
function removeItems2(arr, startIdx, removeCount) {
  var length = arr.length;
  var i;
  if (startIdx >= length || removeCount === 0) {
    return;
  }
  removeCount = startIdx + removeCount > length ? length - startIdx : removeCount;
  var len = length - removeCount;
  for (i = startIdx; i < len; ++i) {
    arr[i] = arr[i + removeCount];
  }
  arr.length = len;
}
var nextUid2 = 0;
function uid2() {
  return ++nextUid2;
}
var warnings2 = {};
function deprecation2(version, message, ignoreDepth) {
  if (ignoreDepth === void 0) {
    ignoreDepth = 3;
  }
  if (warnings2[message]) {
    return;
  }
  var stack = new Error().stack;
  if (typeof stack === "undefined") {
    console.warn("PixiJS Deprecation Warning: ", message + "\nDeprecated since v" + version);
  } else {
    stack = stack.split("\n").splice(ignoreDepth).join("\n");
    if (console.groupCollapsed) {
      console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s", "color:#614108;background:#fffbe6", "font-weight:normal;color:#614108;background:#fffbe6", message + "\nDeprecated since v" + version);
      console.warn(stack);
      console.groupEnd();
    } else {
      console.warn("PixiJS Deprecation Warning: ", message + "\nDeprecated since v" + version);
      console.warn(stack);
    }
  }
  warnings2[message] = true;
}
var ProgramCache2 = {};
var TextureCache2 = /* @__PURE__ */ Object.create(null);
var BaseTextureCache2 = /* @__PURE__ */ Object.create(null);
var CanvasRenderTarget2 = (
  /** @class */
  function() {
    function CanvasRenderTarget3(width, height, resolution) {
      this.canvas = document.createElement("canvas");
      this.context = this.canvas.getContext("2d");
      this.resolution = resolution || settings2.RESOLUTION;
      this.resize(width, height);
    }
    CanvasRenderTarget3.prototype.clear = function() {
      this.context.setTransform(1, 0, 0, 1, 0, 0);
      this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    };
    CanvasRenderTarget3.prototype.resize = function(width, height) {
      this.canvas.width = width * this.resolution;
      this.canvas.height = height * this.resolution;
    };
    CanvasRenderTarget3.prototype.destroy = function() {
      this.context = null;
      this.canvas = null;
    };
    Object.defineProperty(CanvasRenderTarget3.prototype, "width", {
      /**
       * The width of the canvas buffer in pixels.
       *
       * @member {number}
       */
      get: function() {
        return this.canvas.width;
      },
      set: function(val) {
        this.canvas.width = val;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(CanvasRenderTarget3.prototype, "height", {
      /**
       * The height of the canvas buffer in pixels.
       *
       * @member {number}
       */
      get: function() {
        return this.canvas.height;
      },
      set: function(val) {
        this.canvas.height = val;
      },
      enumerable: false,
      configurable: true
    });
    return CanvasRenderTarget3;
  }()
);
var tempAnchor3;
function determineCrossOrigin2(url, loc) {
  if (loc === void 0) {
    loc = window.location;
  }
  if (url.indexOf("data:") === 0) {
    return "";
  }
  loc = loc || window.location;
  if (!tempAnchor3) {
    tempAnchor3 = document.createElement("a");
  }
  tempAnchor3.href = url;
  var parsedUrl = (0, import_url3.parse)(tempAnchor3.href);
  var samePort = !parsedUrl.port && loc.port === "" || parsedUrl.port === loc.port;
  if (parsedUrl.hostname !== loc.hostname || !samePort || parsedUrl.protocol !== loc.protocol) {
    return "anonymous";
  }
  return "";
}
function getResolutionOfUrl2(url, defaultValue3) {
  var resolution = settings2.RETINA_PREFIX.exec(url);
  if (resolution) {
    return parseFloat(resolution[1]);
  }
  return defaultValue3 !== void 0 ? defaultValue3 : 1;
}

// node_modules/pixi-sound/node_modules/@pixi/runner/lib/runner.es.js
var Runner2 = (
  /** @class */
  function() {
    function Runner3(name) {
      this.items = [];
      this._name = name;
      this._aliasCount = 0;
    }
    Runner3.prototype.emit = function(a0, a1, a2, a3, a4, a5, a6, a7) {
      if (arguments.length > 8) {
        throw new Error("max arguments reached");
      }
      var _a = this, name = _a.name, items = _a.items;
      this._aliasCount++;
      for (var i = 0, len = items.length; i < len; i++) {
        items[i][name](a0, a1, a2, a3, a4, a5, a6, a7);
      }
      if (items === this.items) {
        this._aliasCount--;
      }
      return this;
    };
    Runner3.prototype.ensureNonAliasedItems = function() {
      if (this._aliasCount > 0 && this.items.length > 1) {
        this._aliasCount = 0;
        this.items = this.items.slice(0);
      }
    };
    Runner3.prototype.add = function(item) {
      if (item[this._name]) {
        this.ensureNonAliasedItems();
        this.remove(item);
        this.items.push(item);
      }
      return this;
    };
    Runner3.prototype.remove = function(item) {
      var index2 = this.items.indexOf(item);
      if (index2 !== -1) {
        this.ensureNonAliasedItems();
        this.items.splice(index2, 1);
      }
      return this;
    };
    Runner3.prototype.contains = function(item) {
      return this.items.indexOf(item) !== -1;
    };
    Runner3.prototype.removeAll = function() {
      this.ensureNonAliasedItems();
      this.items.length = 0;
      return this;
    };
    Runner3.prototype.destroy = function() {
      this.removeAll();
      this.items = null;
      this._name = null;
    };
    Object.defineProperty(Runner3.prototype, "empty", {
      /**
       * `true` if there are no this Runner contains no listeners
       *
       * @member {boolean}
       * @readonly
       */
      get: function() {
        return this.items.length === 0;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Runner3.prototype, "name", {
      /**
       * The name of the runner.
       *
       * @member {string}
       * @readonly
       */
      get: function() {
        return this._name;
      },
      enumerable: false,
      configurable: true
    });
    return Runner3;
  }()
);
Object.defineProperties(Runner2.prototype, {
  /**
   * Alias for `emit`
   * @memberof PIXI.Runner#
   * @method dispatch
   * @see PIXI.Runner#emit
   */
  dispatch: { value: Runner2.prototype.emit },
  /**
   * Alias for `emit`
   * @memberof PIXI.Runner#
   * @method run
   * @see PIXI.Runner#emit
   */
  run: { value: Runner2.prototype.emit }
});

// node_modules/pixi-sound/node_modules/@pixi/math/lib/math.es.js
var PI_22 = Math.PI * 2;
var RAD_TO_DEG2 = 180 / Math.PI;
var DEG_TO_RAD2 = Math.PI / 180;
var SHAPES2;
(function(SHAPES3) {
  SHAPES3[SHAPES3["POLY"] = 0] = "POLY";
  SHAPES3[SHAPES3["RECT"] = 1] = "RECT";
  SHAPES3[SHAPES3["CIRC"] = 2] = "CIRC";
  SHAPES3[SHAPES3["ELIP"] = 3] = "ELIP";
  SHAPES3[SHAPES3["RREC"] = 4] = "RREC";
})(SHAPES2 || (SHAPES2 = {}));
var Rectangle2 = (
  /** @class */
  function() {
    function Rectangle3(x2, y2, width, height) {
      if (x2 === void 0) {
        x2 = 0;
      }
      if (y2 === void 0) {
        y2 = 0;
      }
      if (width === void 0) {
        width = 0;
      }
      if (height === void 0) {
        height = 0;
      }
      this.x = Number(x2);
      this.y = Number(y2);
      this.width = Number(width);
      this.height = Number(height);
      this.type = SHAPES2.RECT;
    }
    Object.defineProperty(Rectangle3.prototype, "left", {
      /**
       * returns the left edge of the rectangle
       *
       * @member {number}
       */
      get: function() {
        return this.x;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Rectangle3.prototype, "right", {
      /**
       * returns the right edge of the rectangle
       *
       * @member {number}
       */
      get: function() {
        return this.x + this.width;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Rectangle3.prototype, "top", {
      /**
       * returns the top edge of the rectangle
       *
       * @member {number}
       */
      get: function() {
        return this.y;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Rectangle3.prototype, "bottom", {
      /**
       * returns the bottom edge of the rectangle
       *
       * @member {number}
       */
      get: function() {
        return this.y + this.height;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Rectangle3, "EMPTY", {
      /**
       * A constant empty rectangle.
       *
       * @static
       * @constant
       * @member {PIXI.Rectangle}
       * @return {PIXI.Rectangle} An empty rectangle
       */
      get: function() {
        return new Rectangle3(0, 0, 0, 0);
      },
      enumerable: false,
      configurable: true
    });
    Rectangle3.prototype.clone = function() {
      return new Rectangle3(this.x, this.y, this.width, this.height);
    };
    Rectangle3.prototype.copyFrom = function(rectangle) {
      this.x = rectangle.x;
      this.y = rectangle.y;
      this.width = rectangle.width;
      this.height = rectangle.height;
      return this;
    };
    Rectangle3.prototype.copyTo = function(rectangle) {
      rectangle.x = this.x;
      rectangle.y = this.y;
      rectangle.width = this.width;
      rectangle.height = this.height;
      return rectangle;
    };
    Rectangle3.prototype.contains = function(x2, y2) {
      if (this.width <= 0 || this.height <= 0) {
        return false;
      }
      if (x2 >= this.x && x2 < this.x + this.width) {
        if (y2 >= this.y && y2 < this.y + this.height) {
          return true;
        }
      }
      return false;
    };
    Rectangle3.prototype.pad = function(paddingX, paddingY) {
      if (paddingX === void 0) {
        paddingX = 0;
      }
      if (paddingY === void 0) {
        paddingY = paddingX;
      }
      this.x -= paddingX;
      this.y -= paddingY;
      this.width += paddingX * 2;
      this.height += paddingY * 2;
      return this;
    };
    Rectangle3.prototype.fit = function(rectangle) {
      var x1 = Math.max(this.x, rectangle.x);
      var x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width);
      var y1 = Math.max(this.y, rectangle.y);
      var y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);
      this.x = x1;
      this.width = Math.max(x2 - x1, 0);
      this.y = y1;
      this.height = Math.max(y2 - y1, 0);
      return this;
    };
    Rectangle3.prototype.ceil = function(resolution, eps) {
      if (resolution === void 0) {
        resolution = 1;
      }
      if (eps === void 0) {
        eps = 1e-3;
      }
      var x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;
      var y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;
      this.x = Math.floor((this.x + eps) * resolution) / resolution;
      this.y = Math.floor((this.y + eps) * resolution) / resolution;
      this.width = x2 - this.x;
      this.height = y2 - this.y;
      return this;
    };
    Rectangle3.prototype.enlarge = function(rectangle) {
      var x1 = Math.min(this.x, rectangle.x);
      var x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);
      var y1 = Math.min(this.y, rectangle.y);
      var y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);
      this.x = x1;
      this.width = x2 - x1;
      this.y = y1;
      this.height = y2 - y1;
      return this;
    };
    return Rectangle3;
  }()
);
var Circle2 = (
  /** @class */
  function() {
    function Circle3(x2, y2, radius) {
      if (x2 === void 0) {
        x2 = 0;
      }
      if (y2 === void 0) {
        y2 = 0;
      }
      if (radius === void 0) {
        radius = 0;
      }
      this.x = x2;
      this.y = y2;
      this.radius = radius;
      this.type = SHAPES2.CIRC;
    }
    Circle3.prototype.clone = function() {
      return new Circle3(this.x, this.y, this.radius);
    };
    Circle3.prototype.contains = function(x2, y2) {
      if (this.radius <= 0) {
        return false;
      }
      var r2 = this.radius * this.radius;
      var dx = this.x - x2;
      var dy = this.y - y2;
      dx *= dx;
      dy *= dy;
      return dx + dy <= r2;
    };
    Circle3.prototype.getBounds = function() {
      return new Rectangle2(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
    };
    return Circle3;
  }()
);
var Ellipse2 = (
  /** @class */
  function() {
    function Ellipse3(x2, y2, halfWidth, halfHeight) {
      if (x2 === void 0) {
        x2 = 0;
      }
      if (y2 === void 0) {
        y2 = 0;
      }
      if (halfWidth === void 0) {
        halfWidth = 0;
      }
      if (halfHeight === void 0) {
        halfHeight = 0;
      }
      this.x = x2;
      this.y = y2;
      this.width = halfWidth;
      this.height = halfHeight;
      this.type = SHAPES2.ELIP;
    }
    Ellipse3.prototype.clone = function() {
      return new Ellipse3(this.x, this.y, this.width, this.height);
    };
    Ellipse3.prototype.contains = function(x2, y2) {
      if (this.width <= 0 || this.height <= 0) {
        return false;
      }
      var normx = (x2 - this.x) / this.width;
      var normy = (y2 - this.y) / this.height;
      normx *= normx;
      normy *= normy;
      return normx + normy <= 1;
    };
    Ellipse3.prototype.getBounds = function() {
      return new Rectangle2(this.x - this.width, this.y - this.height, this.width, this.height);
    };
    return Ellipse3;
  }()
);
var Polygon2 = (
  /** @class */
  function() {
    function Polygon3() {
      var arguments$1 = arguments;
      var points = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        points[_i] = arguments$1[_i];
      }
      var flat = Array.isArray(points[0]) ? points[0] : points;
      if (typeof flat[0] !== "number") {
        var p2 = [];
        for (var i = 0, il = flat.length; i < il; i++) {
          p2.push(flat[i].x, flat[i].y);
        }
        flat = p2;
      }
      this.points = flat;
      this.type = SHAPES2.POLY;
      this.closeStroke = true;
    }
    Polygon3.prototype.clone = function() {
      var points = this.points.slice();
      var polygon = new Polygon3(points);
      polygon.closeStroke = this.closeStroke;
      return polygon;
    };
    Polygon3.prototype.contains = function(x2, y2) {
      var inside = false;
      var length = this.points.length / 2;
      for (var i = 0, j2 = length - 1; i < length; j2 = i++) {
        var xi = this.points[i * 2];
        var yi = this.points[i * 2 + 1];
        var xj = this.points[j2 * 2];
        var yj = this.points[j2 * 2 + 1];
        var intersect = yi > y2 !== yj > y2 && x2 < (xj - xi) * ((y2 - yi) / (yj - yi)) + xi;
        if (intersect) {
          inside = !inside;
        }
      }
      return inside;
    };
    return Polygon3;
  }()
);
var RoundedRectangle2 = (
  /** @class */
  function() {
    function RoundedRectangle3(x2, y2, width, height, radius) {
      if (x2 === void 0) {
        x2 = 0;
      }
      if (y2 === void 0) {
        y2 = 0;
      }
      if (width === void 0) {
        width = 0;
      }
      if (height === void 0) {
        height = 0;
      }
      if (radius === void 0) {
        radius = 20;
      }
      this.x = x2;
      this.y = y2;
      this.width = width;
      this.height = height;
      this.radius = radius;
      this.type = SHAPES2.RREC;
    }
    RoundedRectangle3.prototype.clone = function() {
      return new RoundedRectangle3(this.x, this.y, this.width, this.height, this.radius);
    };
    RoundedRectangle3.prototype.contains = function(x2, y2) {
      if (this.width <= 0 || this.height <= 0) {
        return false;
      }
      if (x2 >= this.x && x2 <= this.x + this.width) {
        if (y2 >= this.y && y2 <= this.y + this.height) {
          if (y2 >= this.y + this.radius && y2 <= this.y + this.height - this.radius || x2 >= this.x + this.radius && x2 <= this.x + this.width - this.radius) {
            return true;
          }
          var dx = x2 - (this.x + this.radius);
          var dy = y2 - (this.y + this.radius);
          var radius2 = this.radius * this.radius;
          if (dx * dx + dy * dy <= radius2) {
            return true;
          }
          dx = x2 - (this.x + this.width - this.radius);
          if (dx * dx + dy * dy <= radius2) {
            return true;
          }
          dy = y2 - (this.y + this.height - this.radius);
          if (dx * dx + dy * dy <= radius2) {
            return true;
          }
          dx = x2 - (this.x + this.radius);
          if (dx * dx + dy * dy <= radius2) {
            return true;
          }
        }
      }
      return false;
    };
    return RoundedRectangle3;
  }()
);
var Point2 = (
  /** @class */
  function() {
    function Point3(x2, y2) {
      if (x2 === void 0) {
        x2 = 0;
      }
      if (y2 === void 0) {
        y2 = 0;
      }
      this.x = x2;
      this.y = y2;
    }
    Point3.prototype.clone = function() {
      return new Point3(this.x, this.y);
    };
    Point3.prototype.copyFrom = function(p2) {
      this.set(p2.x, p2.y);
      return this;
    };
    Point3.prototype.copyTo = function(p2) {
      p2.set(this.x, this.y);
      return p2;
    };
    Point3.prototype.equals = function(p2) {
      return p2.x === this.x && p2.y === this.y;
    };
    Point3.prototype.set = function(x2, y2) {
      if (x2 === void 0) {
        x2 = 0;
      }
      if (y2 === void 0) {
        y2 = x2;
      }
      this.x = x2;
      this.y = y2;
      return this;
    };
    return Point3;
  }()
);
var ObservablePoint2 = (
  /** @class */
  function() {
    function ObservablePoint3(cb, scope, x2, y2) {
      if (x2 === void 0) {
        x2 = 0;
      }
      if (y2 === void 0) {
        y2 = 0;
      }
      this._x = x2;
      this._y = y2;
      this.cb = cb;
      this.scope = scope;
    }
    ObservablePoint3.prototype.clone = function(cb, scope) {
      if (cb === void 0) {
        cb = this.cb;
      }
      if (scope === void 0) {
        scope = this.scope;
      }
      return new ObservablePoint3(cb, scope, this._x, this._y);
    };
    ObservablePoint3.prototype.set = function(x2, y2) {
      if (x2 === void 0) {
        x2 = 0;
      }
      if (y2 === void 0) {
        y2 = x2;
      }
      if (this._x !== x2 || this._y !== y2) {
        this._x = x2;
        this._y = y2;
        this.cb.call(this.scope);
      }
      return this;
    };
    ObservablePoint3.prototype.copyFrom = function(p2) {
      if (this._x !== p2.x || this._y !== p2.y) {
        this._x = p2.x;
        this._y = p2.y;
        this.cb.call(this.scope);
      }
      return this;
    };
    ObservablePoint3.prototype.copyTo = function(p2) {
      p2.set(this._x, this._y);
      return p2;
    };
    ObservablePoint3.prototype.equals = function(p2) {
      return p2.x === this._x && p2.y === this._y;
    };
    Object.defineProperty(ObservablePoint3.prototype, "x", {
      /**
       * The position of the displayObject on the x axis relative to the local coordinates of the parent.
       *
       * @member {number}
       */
      get: function() {
        return this._x;
      },
      set: function(value) {
        if (this._x !== value) {
          this._x = value;
          this.cb.call(this.scope);
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ObservablePoint3.prototype, "y", {
      /**
       * The position of the displayObject on the x axis relative to the local coordinates of the parent.
       *
       * @member {number}
       */
      get: function() {
        return this._y;
      },
      set: function(value) {
        if (this._y !== value) {
          this._y = value;
          this.cb.call(this.scope);
        }
      },
      enumerable: false,
      configurable: true
    });
    return ObservablePoint3;
  }()
);
var Matrix2 = (
  /** @class */
  function() {
    function Matrix3(a2, b2, c2, d2, tx, ty) {
      if (a2 === void 0) {
        a2 = 1;
      }
      if (b2 === void 0) {
        b2 = 0;
      }
      if (c2 === void 0) {
        c2 = 0;
      }
      if (d2 === void 0) {
        d2 = 1;
      }
      if (tx === void 0) {
        tx = 0;
      }
      if (ty === void 0) {
        ty = 0;
      }
      this.array = null;
      this.a = a2;
      this.b = b2;
      this.c = c2;
      this.d = d2;
      this.tx = tx;
      this.ty = ty;
    }
    Matrix3.prototype.fromArray = function(array) {
      this.a = array[0];
      this.b = array[1];
      this.c = array[3];
      this.d = array[4];
      this.tx = array[2];
      this.ty = array[5];
    };
    Matrix3.prototype.set = function(a2, b2, c2, d2, tx, ty) {
      this.a = a2;
      this.b = b2;
      this.c = c2;
      this.d = d2;
      this.tx = tx;
      this.ty = ty;
      return this;
    };
    Matrix3.prototype.toArray = function(transpose, out) {
      if (!this.array) {
        this.array = new Float32Array(9);
      }
      var array = out || this.array;
      if (transpose) {
        array[0] = this.a;
        array[1] = this.b;
        array[2] = 0;
        array[3] = this.c;
        array[4] = this.d;
        array[5] = 0;
        array[6] = this.tx;
        array[7] = this.ty;
        array[8] = 1;
      } else {
        array[0] = this.a;
        array[1] = this.c;
        array[2] = this.tx;
        array[3] = this.b;
        array[4] = this.d;
        array[5] = this.ty;
        array[6] = 0;
        array[7] = 0;
        array[8] = 1;
      }
      return array;
    };
    Matrix3.prototype.apply = function(pos, newPos) {
      newPos = newPos || new Point2();
      var x2 = pos.x;
      var y2 = pos.y;
      newPos.x = this.a * x2 + this.c * y2 + this.tx;
      newPos.y = this.b * x2 + this.d * y2 + this.ty;
      return newPos;
    };
    Matrix3.prototype.applyInverse = function(pos, newPos) {
      newPos = newPos || new Point2();
      var id = 1 / (this.a * this.d + this.c * -this.b);
      var x2 = pos.x;
      var y2 = pos.y;
      newPos.x = this.d * id * x2 + -this.c * id * y2 + (this.ty * this.c - this.tx * this.d) * id;
      newPos.y = this.a * id * y2 + -this.b * id * x2 + (-this.ty * this.a + this.tx * this.b) * id;
      return newPos;
    };
    Matrix3.prototype.translate = function(x2, y2) {
      this.tx += x2;
      this.ty += y2;
      return this;
    };
    Matrix3.prototype.scale = function(x2, y2) {
      this.a *= x2;
      this.d *= y2;
      this.c *= x2;
      this.b *= y2;
      this.tx *= x2;
      this.ty *= y2;
      return this;
    };
    Matrix3.prototype.rotate = function(angle) {
      var cos = Math.cos(angle);
      var sin = Math.sin(angle);
      var a1 = this.a;
      var c1 = this.c;
      var tx1 = this.tx;
      this.a = a1 * cos - this.b * sin;
      this.b = a1 * sin + this.b * cos;
      this.c = c1 * cos - this.d * sin;
      this.d = c1 * sin + this.d * cos;
      this.tx = tx1 * cos - this.ty * sin;
      this.ty = tx1 * sin + this.ty * cos;
      return this;
    };
    Matrix3.prototype.append = function(matrix) {
      var a1 = this.a;
      var b1 = this.b;
      var c1 = this.c;
      var d1 = this.d;
      this.a = matrix.a * a1 + matrix.b * c1;
      this.b = matrix.a * b1 + matrix.b * d1;
      this.c = matrix.c * a1 + matrix.d * c1;
      this.d = matrix.c * b1 + matrix.d * d1;
      this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx;
      this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty;
      return this;
    };
    Matrix3.prototype.setTransform = function(x2, y2, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {
      this.a = Math.cos(rotation + skewY) * scaleX;
      this.b = Math.sin(rotation + skewY) * scaleX;
      this.c = -Math.sin(rotation - skewX) * scaleY;
      this.d = Math.cos(rotation - skewX) * scaleY;
      this.tx = x2 - (pivotX * this.a + pivotY * this.c);
      this.ty = y2 - (pivotX * this.b + pivotY * this.d);
      return this;
    };
    Matrix3.prototype.prepend = function(matrix) {
      var tx1 = this.tx;
      if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {
        var a1 = this.a;
        var c1 = this.c;
        this.a = a1 * matrix.a + this.b * matrix.c;
        this.b = a1 * matrix.b + this.b * matrix.d;
        this.c = c1 * matrix.a + this.d * matrix.c;
        this.d = c1 * matrix.b + this.d * matrix.d;
      }
      this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx;
      this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty;
      return this;
    };
    Matrix3.prototype.decompose = function(transform) {
      var a2 = this.a;
      var b2 = this.b;
      var c2 = this.c;
      var d2 = this.d;
      var skewX = -Math.atan2(-c2, d2);
      var skewY = Math.atan2(b2, a2);
      var delta = Math.abs(skewX + skewY);
      if (delta < 1e-5 || Math.abs(PI_22 - delta) < 1e-5) {
        transform.rotation = skewY;
        transform.skew.x = transform.skew.y = 0;
      } else {
        transform.rotation = 0;
        transform.skew.x = skewX;
        transform.skew.y = skewY;
      }
      transform.scale.x = Math.sqrt(a2 * a2 + b2 * b2);
      transform.scale.y = Math.sqrt(c2 * c2 + d2 * d2);
      transform.position.x = this.tx;
      transform.position.y = this.ty;
      return transform;
    };
    Matrix3.prototype.invert = function() {
      var a1 = this.a;
      var b1 = this.b;
      var c1 = this.c;
      var d1 = this.d;
      var tx1 = this.tx;
      var n = a1 * d1 - b1 * c1;
      this.a = d1 / n;
      this.b = -b1 / n;
      this.c = -c1 / n;
      this.d = a1 / n;
      this.tx = (c1 * this.ty - d1 * tx1) / n;
      this.ty = -(a1 * this.ty - b1 * tx1) / n;
      return this;
    };
    Matrix3.prototype.identity = function() {
      this.a = 1;
      this.b = 0;
      this.c = 0;
      this.d = 1;
      this.tx = 0;
      this.ty = 0;
      return this;
    };
    Matrix3.prototype.clone = function() {
      var matrix = new Matrix3();
      matrix.a = this.a;
      matrix.b = this.b;
      matrix.c = this.c;
      matrix.d = this.d;
      matrix.tx = this.tx;
      matrix.ty = this.ty;
      return matrix;
    };
    Matrix3.prototype.copyTo = function(matrix) {
      matrix.a = this.a;
      matrix.b = this.b;
      matrix.c = this.c;
      matrix.d = this.d;
      matrix.tx = this.tx;
      matrix.ty = this.ty;
      return matrix;
    };
    Matrix3.prototype.copyFrom = function(matrix) {
      this.a = matrix.a;
      this.b = matrix.b;
      this.c = matrix.c;
      this.d = matrix.d;
      this.tx = matrix.tx;
      this.ty = matrix.ty;
      return this;
    };
    Object.defineProperty(Matrix3, "IDENTITY", {
      /**
       * A default (identity) matrix
       *
       * @static
       * @const
       * @member {PIXI.Matrix}
       */
      get: function() {
        return new Matrix3();
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Matrix3, "TEMP_MATRIX", {
      /**
       * A temp matrix
       *
       * @static
       * @const
       * @member {PIXI.Matrix}
       */
      get: function() {
        return new Matrix3();
      },
      enumerable: false,
      configurable: true
    });
    return Matrix3;
  }()
);
var ux2 = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1];
var uy2 = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];
var vx2 = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];
var vy2 = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];
var rotationCayley2 = [];
var rotationMatrices2 = [];
var signum2 = Math.sign;
function init2() {
  for (var i = 0; i < 16; i++) {
    var row = [];
    rotationCayley2.push(row);
    for (var j2 = 0; j2 < 16; j2++) {
      var _ux = signum2(ux2[i] * ux2[j2] + vx2[i] * uy2[j2]);
      var _uy = signum2(uy2[i] * ux2[j2] + vy2[i] * uy2[j2]);
      var _vx = signum2(ux2[i] * vx2[j2] + vx2[i] * vy2[j2]);
      var _vy = signum2(uy2[i] * vx2[j2] + vy2[i] * vy2[j2]);
      for (var k2 = 0; k2 < 16; k2++) {
        if (ux2[k2] === _ux && uy2[k2] === _uy && vx2[k2] === _vx && vy2[k2] === _vy) {
          row.push(k2);
          break;
        }
      }
    }
  }
  for (var i = 0; i < 16; i++) {
    var mat = new Matrix2();
    mat.set(ux2[i], uy2[i], vx2[i], vy2[i], 0, 0);
    rotationMatrices2.push(mat);
  }
}
init2();
var groupD82 = {
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 0°       | East      |
   *
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  E: 0,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 45°↻     | Southeast |
   *
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  SE: 1,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 90°↻     | South     |
   *
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  S: 2,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 135°↻    | Southwest |
   *
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  SW: 3,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 180°     | West      |
   *
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  W: 4,
  /**
   * | Rotation    | Direction    |
   * |-------------|--------------|
   * | -135°/225°↻ | Northwest    |
   *
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  NW: 5,
  /**
   * | Rotation    | Direction    |
   * |-------------|--------------|
   * | -90°/270°↻  | North        |
   *
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  N: 6,
  /**
   * | Rotation    | Direction    |
   * |-------------|--------------|
   * | -45°/315°↻  | Northeast    |
   *
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  NE: 7,
  /**
   * Reflection about Y-axis.
   *
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  MIRROR_VERTICAL: 8,
  /**
   * Reflection about the main diagonal.
   *
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  MAIN_DIAGONAL: 10,
  /**
   * Reflection about X-axis.
   *
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  MIRROR_HORIZONTAL: 12,
  /**
   * Reflection about reverse diagonal.
   *
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  REVERSE_DIAGONAL: 14,
  /**
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
   * @return {PIXI.GD8Symmetry} The X-component of the U-axis
   *    after rotating the axes.
   */
  uX: function(ind) {
    return ux2[ind];
  },
  /**
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
   * @return {PIXI.GD8Symmetry} The Y-component of the U-axis
   *    after rotating the axes.
   */
  uY: function(ind) {
    return uy2[ind];
  },
  /**
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
   * @return {PIXI.GD8Symmetry} The X-component of the V-axis
   *    after rotating the axes.
   */
  vX: function(ind) {
    return vx2[ind];
  },
  /**
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
   * @return {PIXI.GD8Symmetry} The Y-component of the V-axis
   *    after rotating the axes.
   */
  vY: function(ind) {
    return vy2[ind];
  },
  /**
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} rotation - symmetry whose opposite
   *   is needed. Only rotations have opposite symmetries while
   *   reflections don't.
   * @return {PIXI.GD8Symmetry} The opposite symmetry of `rotation`
   */
  inv: function(rotation) {
    if (rotation & 8) {
      return rotation & 15;
    }
    return -rotation & 7;
  },
  /**
   * Composes the two D8 operations.
   *
   * Taking `^` as reflection:
   *
   * |       | E=0 | S=2 | W=4 | N=6 | E^=8 | S^=10 | W^=12 | N^=14 |
   * |-------|-----|-----|-----|-----|------|-------|-------|-------|
   * | E=0   | E   | S   | W   | N   | E^   | S^    | W^    | N^    |
   * | S=2   | S   | W   | N   | E   | S^   | W^    | N^    | E^    |
   * | W=4   | W   | N   | E   | S   | W^   | N^    | E^    | S^    |
   * | N=6   | N   | E   | S   | W   | N^   | E^    | S^    | W^    |
   * | E^=8  | E^  | N^  | W^  | S^  | E    | N     | W     | S     |
   * | S^=10 | S^  | E^  | N^  | W^  | S    | E     | N     | W     |
   * | W^=12 | W^  | S^  | E^  | N^  | W    | S     | E     | N     |
   * | N^=14 | N^  | W^  | S^  | E^  | N    | W     | S     | E     |
   *
   * [This is a Cayley table]{@link https://en.wikipedia.org/wiki/Cayley_table}
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} rotationSecond - Second operation, which
   *   is the row in the above cayley table.
   * @param {PIXI.GD8Symmetry} rotationFirst - First operation, which
   *   is the column in the above cayley table.
   * @return {PIXI.GD8Symmetry} Composed operation
   */
  add: function(rotationSecond, rotationFirst) {
    return rotationCayley2[rotationSecond][rotationFirst];
  },
  /**
   * Reverse of `add`.
   *
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} rotationSecond - Second operation
   * @param {PIXI.GD8Symmetry} rotationFirst - First operation
   * @return {PIXI.GD8Symmetry} Result
   */
  sub: function(rotationSecond, rotationFirst) {
    return rotationCayley2[rotationSecond][groupD82.inv(rotationFirst)];
  },
  /**
   * Adds 180 degrees to rotation, which is a commutative
   * operation.
   *
   * @memberof PIXI.groupD8
   * @param {number} rotation - The number to rotate.
   * @returns {number} Rotated number
   */
  rotate180: function(rotation) {
    return rotation ^ 4;
  },
  /**
   * Checks if the rotation angle is vertical, i.e. south
   * or north. It doesn't work for reflections.
   *
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} rotation - The number to check.
   * @returns {boolean} Whether or not the direction is vertical
   */
  isVertical: function(rotation) {
    return (rotation & 3) === 2;
  },
  /**
   * Approximates the vector `V(dx,dy)` into one of the
   * eight directions provided by `groupD8`.
   *
   * @memberof PIXI.groupD8
   * @param {number} dx - X-component of the vector
   * @param {number} dy - Y-component of the vector
   * @return {PIXI.GD8Symmetry} Approximation of the vector into
   *  one of the eight symmetries.
   */
  byDirection: function(dx, dy) {
    if (Math.abs(dx) * 2 <= Math.abs(dy)) {
      if (dy >= 0) {
        return groupD82.S;
      }
      return groupD82.N;
    } else if (Math.abs(dy) * 2 <= Math.abs(dx)) {
      if (dx > 0) {
        return groupD82.E;
      }
      return groupD82.W;
    } else if (dy > 0) {
      if (dx > 0) {
        return groupD82.SE;
      }
      return groupD82.SW;
    } else if (dx > 0) {
      return groupD82.NE;
    }
    return groupD82.NW;
  },
  /**
   * Helps sprite to compensate texture packer rotation.
   *
   * @memberof PIXI.groupD8
   * @param {PIXI.Matrix} matrix - sprite world matrix
   * @param {PIXI.GD8Symmetry} rotation - The rotation factor to use.
   * @param {number} tx - sprite anchoring
   * @param {number} ty - sprite anchoring
   */
  matrixAppendRotationInv: function(matrix, rotation, tx, ty) {
    if (tx === void 0) {
      tx = 0;
    }
    if (ty === void 0) {
      ty = 0;
    }
    var mat = rotationMatrices2[groupD82.inv(rotation)];
    mat.tx = tx;
    mat.ty = ty;
    matrix.append(mat);
  }
};
var Transform2 = (
  /** @class */
  function() {
    function Transform3() {
      this.worldTransform = new Matrix2();
      this.localTransform = new Matrix2();
      this.position = new ObservablePoint2(this.onChange, this, 0, 0);
      this.scale = new ObservablePoint2(this.onChange, this, 1, 1);
      this.pivot = new ObservablePoint2(this.onChange, this, 0, 0);
      this.skew = new ObservablePoint2(this.updateSkew, this, 0, 0);
      this._rotation = 0;
      this._cx = 1;
      this._sx = 0;
      this._cy = 0;
      this._sy = 1;
      this._localID = 0;
      this._currentLocalID = 0;
      this._worldID = 0;
      this._parentID = 0;
    }
    Transform3.prototype.onChange = function() {
      this._localID++;
    };
    Transform3.prototype.updateSkew = function() {
      this._cx = Math.cos(this._rotation + this.skew.y);
      this._sx = Math.sin(this._rotation + this.skew.y);
      this._cy = -Math.sin(this._rotation - this.skew.x);
      this._sy = Math.cos(this._rotation - this.skew.x);
      this._localID++;
    };
    Transform3.prototype.updateLocalTransform = function() {
      var lt = this.localTransform;
      if (this._localID !== this._currentLocalID) {
        lt.a = this._cx * this.scale.x;
        lt.b = this._sx * this.scale.x;
        lt.c = this._cy * this.scale.y;
        lt.d = this._sy * this.scale.y;
        lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);
        lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d);
        this._currentLocalID = this._localID;
        this._parentID = -1;
      }
    };
    Transform3.prototype.updateTransform = function(parentTransform) {
      var lt = this.localTransform;
      if (this._localID !== this._currentLocalID) {
        lt.a = this._cx * this.scale.x;
        lt.b = this._sx * this.scale.x;
        lt.c = this._cy * this.scale.y;
        lt.d = this._sy * this.scale.y;
        lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);
        lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d);
        this._currentLocalID = this._localID;
        this._parentID = -1;
      }
      if (this._parentID !== parentTransform._worldID) {
        var pt = parentTransform.worldTransform;
        var wt = this.worldTransform;
        wt.a = lt.a * pt.a + lt.b * pt.c;
        wt.b = lt.a * pt.b + lt.b * pt.d;
        wt.c = lt.c * pt.a + lt.d * pt.c;
        wt.d = lt.c * pt.b + lt.d * pt.d;
        wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx;
        wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty;
        this._parentID = parentTransform._worldID;
        this._worldID++;
      }
    };
    Transform3.prototype.setFromMatrix = function(matrix) {
      matrix.decompose(this);
      this._localID++;
    };
    Object.defineProperty(Transform3.prototype, "rotation", {
      /**
       * The rotation of the object in radians.
       *
       * @member {number}
       */
      get: function() {
        return this._rotation;
      },
      set: function(value) {
        if (this._rotation !== value) {
          this._rotation = value;
          this.updateSkew();
        }
      },
      enumerable: false,
      configurable: true
    });
    Transform3.IDENTITY = new Transform3();
    return Transform3;
  }()
);

// node_modules/pixi-sound/node_modules/@pixi/core/lib/core.es.js
settings2.PREFER_ENV = isMobile3.any ? ENV2.WEBGL : ENV2.WEBGL2;
settings2.STRICT_TEXTURE_CACHE = false;
var INSTALLED2 = [];
function autoDetectResource2(source, options) {
  if (!source) {
    return null;
  }
  var extension = "";
  if (typeof source === "string") {
    var result = /\.(\w{3,4})(?:$|\?|#)/i.exec(source);
    if (result) {
      extension = result[1].toLowerCase();
    }
  }
  for (var i = INSTALLED2.length - 1; i >= 0; --i) {
    var ResourcePlugin = INSTALLED2[i];
    if (ResourcePlugin.test && ResourcePlugin.test(source, extension)) {
      return new ResourcePlugin(source, options);
    }
  }
  throw new Error("Unrecognized source type to auto-detect Resource");
}
var extendStatics3 = function(d2, b2) {
  extendStatics3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3) {
      if (b3.hasOwnProperty(p2)) {
        d3[p2] = b3[p2];
      }
    }
  };
  return extendStatics3(d2, b2);
};
function __extends3(d2, b2) {
  extendStatics3(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var Resource3 = (
  /** @class */
  function() {
    function Resource4(width, height) {
      if (width === void 0) {
        width = 0;
      }
      if (height === void 0) {
        height = 0;
      }
      this._width = width;
      this._height = height;
      this.destroyed = false;
      this.internal = false;
      this.onResize = new Runner2("setRealSize");
      this.onUpdate = new Runner2("update");
      this.onError = new Runner2("onError");
    }
    Resource4.prototype.bind = function(baseTexture) {
      this.onResize.add(baseTexture);
      this.onUpdate.add(baseTexture);
      this.onError.add(baseTexture);
      if (this._width || this._height) {
        this.onResize.emit(this._width, this._height);
      }
    };
    Resource4.prototype.unbind = function(baseTexture) {
      this.onResize.remove(baseTexture);
      this.onUpdate.remove(baseTexture);
      this.onError.remove(baseTexture);
    };
    Resource4.prototype.resize = function(width, height) {
      if (width !== this._width || height !== this._height) {
        this._width = width;
        this._height = height;
        this.onResize.emit(width, height);
      }
    };
    Object.defineProperty(Resource4.prototype, "valid", {
      /**
       * Has been validated
       * @readonly
       * @member {boolean}
       */
      get: function() {
        return !!this._width && !!this._height;
      },
      enumerable: false,
      configurable: true
    });
    Resource4.prototype.update = function() {
      if (!this.destroyed) {
        this.onUpdate.emit();
      }
    };
    Resource4.prototype.load = function() {
      return Promise.resolve(this);
    };
    Object.defineProperty(Resource4.prototype, "width", {
      /**
       * The width of the resource.
       *
       * @member {number}
       * @readonly
       */
      get: function() {
        return this._width;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Resource4.prototype, "height", {
      /**
       * The height of the resource.
       *
       * @member {number}
       * @readonly
       */
      get: function() {
        return this._height;
      },
      enumerable: false,
      configurable: true
    });
    Resource4.prototype.style = function(_renderer, _baseTexture, _glTexture) {
      return false;
    };
    Resource4.prototype.dispose = function() {
    };
    Resource4.prototype.destroy = function() {
      if (!this.destroyed) {
        this.destroyed = true;
        this.dispose();
        this.onError.removeAll();
        this.onError = null;
        this.onResize.removeAll();
        this.onResize = null;
        this.onUpdate.removeAll();
        this.onUpdate = null;
      }
    };
    Resource4.test = function(_source, _extension) {
      return false;
    };
    return Resource4;
  }()
);
var BufferResource2 = (
  /** @class */
  function(_super) {
    __extends3(BufferResource3, _super);
    function BufferResource3(source, options) {
      var _this = this;
      var _a = options || {}, width = _a.width, height = _a.height;
      if (!width || !height) {
        throw new Error("BufferResource width or height invalid");
      }
      _this = _super.call(this, width, height) || this;
      _this.data = source;
      return _this;
    }
    BufferResource3.prototype.upload = function(renderer, baseTexture, glTexture) {
      var gl = renderer.gl;
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === ALPHA_MODES2.UNPACK);
      if (glTexture.width === baseTexture.width && glTexture.height === baseTexture.height) {
        gl.texSubImage2D(baseTexture.target, 0, 0, 0, baseTexture.width, baseTexture.height, baseTexture.format, baseTexture.type, this.data);
      } else {
        glTexture.width = baseTexture.width;
        glTexture.height = baseTexture.height;
        gl.texImage2D(baseTexture.target, 0, glTexture.internalFormat, baseTexture.width, baseTexture.height, 0, baseTexture.format, glTexture.type, this.data);
      }
      return true;
    };
    BufferResource3.prototype.dispose = function() {
      this.data = null;
    };
    BufferResource3.test = function(source) {
      return source instanceof Float32Array || source instanceof Uint8Array || source instanceof Uint32Array;
    };
    return BufferResource3;
  }(Resource3)
);
var defaultBufferOptions2 = {
  scaleMode: SCALE_MODES2.NEAREST,
  format: FORMATS2.RGBA,
  alphaMode: ALPHA_MODES2.NPM
};
var BaseTexture2 = (
  /** @class */
  function(_super) {
    __extends3(BaseTexture3, _super);
    function BaseTexture3(resource, options) {
      if (resource === void 0) {
        resource = null;
      }
      if (options === void 0) {
        options = null;
      }
      var _this = _super.call(this) || this;
      options = options || {};
      var alphaMode = options.alphaMode, mipmap = options.mipmap, anisotropicLevel = options.anisotropicLevel, scaleMode = options.scaleMode, width = options.width, height = options.height, wrapMode = options.wrapMode, format = options.format, type = options.type, target = options.target, resolution = options.resolution, resourceOptions = options.resourceOptions;
      if (resource && !(resource instanceof Resource3)) {
        resource = autoDetectResource2(resource, resourceOptions);
        resource.internal = true;
      }
      _this.width = width || 0;
      _this.height = height || 0;
      _this.resolution = resolution || settings2.RESOLUTION;
      _this.mipmap = mipmap !== void 0 ? mipmap : settings2.MIPMAP_TEXTURES;
      _this.anisotropicLevel = anisotropicLevel !== void 0 ? anisotropicLevel : settings2.ANISOTROPIC_LEVEL;
      _this.wrapMode = wrapMode || settings2.WRAP_MODE;
      _this.scaleMode = scaleMode !== void 0 ? scaleMode : settings2.SCALE_MODE;
      _this.format = format || FORMATS2.RGBA;
      _this.type = type || TYPES2.UNSIGNED_BYTE;
      _this.target = target || TARGETS2.TEXTURE_2D;
      _this.alphaMode = alphaMode !== void 0 ? alphaMode : ALPHA_MODES2.UNPACK;
      if (options.premultiplyAlpha !== void 0) {
        _this.premultiplyAlpha = options.premultiplyAlpha;
      }
      _this.uid = uid2();
      _this.touched = 0;
      _this.isPowerOfTwo = false;
      _this._refreshPOT();
      _this._glTextures = {};
      _this.dirtyId = 0;
      _this.dirtyStyleId = 0;
      _this.cacheId = null;
      _this.valid = width > 0 && height > 0;
      _this.textureCacheIds = [];
      _this.destroyed = false;
      _this.resource = null;
      _this._batchEnabled = 0;
      _this._batchLocation = 0;
      _this.parentTextureArray = null;
      _this.setResource(resource);
      return _this;
    }
    Object.defineProperty(BaseTexture3.prototype, "realWidth", {
      /**
       * Pixel width of the source of this texture
       *
       * @readonly
       * @member {number}
       */
      get: function() {
        return Math.ceil(this.width * this.resolution - 1e-4);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BaseTexture3.prototype, "realHeight", {
      /**
       * Pixel height of the source of this texture
       *
       * @readonly
       * @member {number}
       */
      get: function() {
        return Math.ceil(this.height * this.resolution - 1e-4);
      },
      enumerable: false,
      configurable: true
    });
    BaseTexture3.prototype.setStyle = function(scaleMode, mipmap) {
      var dirty;
      if (scaleMode !== void 0 && scaleMode !== this.scaleMode) {
        this.scaleMode = scaleMode;
        dirty = true;
      }
      if (mipmap !== void 0 && mipmap !== this.mipmap) {
        this.mipmap = mipmap;
        dirty = true;
      }
      if (dirty) {
        this.dirtyStyleId++;
      }
      return this;
    };
    BaseTexture3.prototype.setSize = function(width, height, resolution) {
      this.resolution = resolution || this.resolution;
      this.width = width;
      this.height = height;
      this._refreshPOT();
      this.update();
      return this;
    };
    BaseTexture3.prototype.setRealSize = function(realWidth, realHeight, resolution) {
      this.resolution = resolution || this.resolution;
      this.width = realWidth / this.resolution;
      this.height = realHeight / this.resolution;
      this._refreshPOT();
      this.update();
      return this;
    };
    BaseTexture3.prototype._refreshPOT = function() {
      this.isPowerOfTwo = isPow22(this.realWidth) && isPow22(this.realHeight);
    };
    BaseTexture3.prototype.setResolution = function(resolution) {
      var oldResolution = this.resolution;
      if (oldResolution === resolution) {
        return this;
      }
      this.resolution = resolution;
      if (this.valid) {
        this.width = this.width * oldResolution / resolution;
        this.height = this.height * oldResolution / resolution;
        this.emit("update", this);
      }
      this._refreshPOT();
      return this;
    };
    BaseTexture3.prototype.setResource = function(resource) {
      if (this.resource === resource) {
        return this;
      }
      if (this.resource) {
        throw new Error("Resource can be set only once");
      }
      resource.bind(this);
      this.resource = resource;
      return this;
    };
    BaseTexture3.prototype.update = function() {
      if (!this.valid) {
        if (this.width > 0 && this.height > 0) {
          this.valid = true;
          this.emit("loaded", this);
          this.emit("update", this);
        }
      } else {
        this.dirtyId++;
        this.dirtyStyleId++;
        this.emit("update", this);
      }
    };
    BaseTexture3.prototype.onError = function(event) {
      this.emit("error", this, event);
    };
    BaseTexture3.prototype.destroy = function() {
      if (this.resource) {
        this.resource.unbind(this);
        if (this.resource.internal) {
          this.resource.destroy();
        }
        this.resource = null;
      }
      if (this.cacheId) {
        delete BaseTextureCache2[this.cacheId];
        delete TextureCache2[this.cacheId];
        this.cacheId = null;
      }
      this.dispose();
      BaseTexture3.removeFromCache(this);
      this.textureCacheIds = null;
      this.destroyed = true;
    };
    BaseTexture3.prototype.dispose = function() {
      this.emit("dispose", this);
    };
    BaseTexture3.prototype.castToBaseTexture = function() {
      return this;
    };
    BaseTexture3.from = function(source, options, strict) {
      if (strict === void 0) {
        strict = settings2.STRICT_TEXTURE_CACHE;
      }
      var isFrame = typeof source === "string";
      var cacheId = null;
      if (isFrame) {
        cacheId = source;
      } else {
        if (!source._pixiId) {
          source._pixiId = "pixiid_" + uid2();
        }
        cacheId = source._pixiId;
      }
      var baseTexture = BaseTextureCache2[cacheId];
      if (isFrame && strict && !baseTexture) {
        throw new Error('The cacheId "' + cacheId + '" does not exist in BaseTextureCache.');
      }
      if (!baseTexture) {
        baseTexture = new BaseTexture3(source, options);
        baseTexture.cacheId = cacheId;
        BaseTexture3.addToCache(baseTexture, cacheId);
      }
      return baseTexture;
    };
    BaseTexture3.fromBuffer = function(buffer, width, height, options) {
      buffer = buffer || new Float32Array(width * height * 4);
      var resource = new BufferResource2(buffer, { width, height });
      var type = buffer instanceof Float32Array ? TYPES2.FLOAT : TYPES2.UNSIGNED_BYTE;
      return new BaseTexture3(resource, Object.assign(defaultBufferOptions2, options || { width, height, type }));
    };
    BaseTexture3.addToCache = function(baseTexture, id) {
      if (id) {
        if (baseTexture.textureCacheIds.indexOf(id) === -1) {
          baseTexture.textureCacheIds.push(id);
        }
        if (BaseTextureCache2[id]) {
          console.warn("BaseTexture added to the cache with an id [" + id + "] that already had an entry");
        }
        BaseTextureCache2[id] = baseTexture;
      }
    };
    BaseTexture3.removeFromCache = function(baseTexture) {
      if (typeof baseTexture === "string") {
        var baseTextureFromCache = BaseTextureCache2[baseTexture];
        if (baseTextureFromCache) {
          var index2 = baseTextureFromCache.textureCacheIds.indexOf(baseTexture);
          if (index2 > -1) {
            baseTextureFromCache.textureCacheIds.splice(index2, 1);
          }
          delete BaseTextureCache2[baseTexture];
          return baseTextureFromCache;
        }
      } else if (baseTexture && baseTexture.textureCacheIds) {
        for (var i = 0; i < baseTexture.textureCacheIds.length; ++i) {
          delete BaseTextureCache2[baseTexture.textureCacheIds[i]];
        }
        baseTexture.textureCacheIds.length = 0;
        return baseTexture;
      }
      return null;
    };
    BaseTexture3._globalBatch = 0;
    return BaseTexture3;
  }(import_eventemitter32.default)
);
var AbstractMultiResource2 = (
  /** @class */
  function(_super) {
    __extends3(AbstractMultiResource3, _super);
    function AbstractMultiResource3(length, options) {
      var _this = this;
      var _a = options || {}, width = _a.width, height = _a.height;
      _this = _super.call(this, width, height) || this;
      _this.items = [];
      _this.itemDirtyIds = [];
      for (var i = 0; i < length; i++) {
        var partTexture = new BaseTexture2();
        _this.items.push(partTexture);
        _this.itemDirtyIds.push(-2);
      }
      _this.length = length;
      _this._load = null;
      _this.baseTexture = null;
      return _this;
    }
    AbstractMultiResource3.prototype.initFromArray = function(resources, options) {
      for (var i = 0; i < this.length; i++) {
        if (!resources[i]) {
          continue;
        }
        if (resources[i].castToBaseTexture) {
          this.addBaseTextureAt(resources[i].castToBaseTexture(), i);
        } else if (resources[i] instanceof Resource3) {
          this.addResourceAt(resources[i], i);
        } else {
          this.addResourceAt(autoDetectResource2(resources[i], options), i);
        }
      }
    };
    AbstractMultiResource3.prototype.dispose = function() {
      for (var i = 0, len = this.length; i < len; i++) {
        this.items[i].destroy();
      }
      this.items = null;
      this.itemDirtyIds = null;
      this._load = null;
    };
    AbstractMultiResource3.prototype.addResourceAt = function(resource, index2) {
      if (!this.items[index2]) {
        throw new Error("Index " + index2 + " is out of bounds");
      }
      if (resource.valid && !this.valid) {
        this.resize(resource.width, resource.height);
      }
      this.items[index2].setResource(resource);
      return this;
    };
    AbstractMultiResource3.prototype.bind = function(baseTexture) {
      if (this.baseTexture !== null) {
        throw new Error("Only one base texture per TextureArray is allowed");
      }
      _super.prototype.bind.call(this, baseTexture);
      for (var i = 0; i < this.length; i++) {
        this.items[i].parentTextureArray = baseTexture;
        this.items[i].on("update", baseTexture.update, baseTexture);
      }
    };
    AbstractMultiResource3.prototype.unbind = function(baseTexture) {
      _super.prototype.unbind.call(this, baseTexture);
      for (var i = 0; i < this.length; i++) {
        this.items[i].parentTextureArray = null;
        this.items[i].off("update", baseTexture.update, baseTexture);
      }
    };
    AbstractMultiResource3.prototype.load = function() {
      var _this = this;
      if (this._load) {
        return this._load;
      }
      var resources = this.items.map(function(item) {
        return item.resource;
      }).filter(function(item) {
        return item;
      });
      var promises = resources.map(function(item) {
        return item.load();
      });
      this._load = Promise.all(promises).then(function() {
        var _a = _this.items[0], realWidth = _a.realWidth, realHeight = _a.realHeight;
        _this.resize(realWidth, realHeight);
        return Promise.resolve(_this);
      });
      return this._load;
    };
    return AbstractMultiResource3;
  }(Resource3)
);
var ArrayResource2 = (
  /** @class */
  function(_super) {
    __extends3(ArrayResource3, _super);
    function ArrayResource3(source, options) {
      var _this = this;
      var _a = options || {}, width = _a.width, height = _a.height;
      var urls;
      var length;
      if (Array.isArray(source)) {
        urls = source;
        length = source.length;
      } else {
        length = source;
      }
      _this = _super.call(this, length, { width, height }) || this;
      if (urls) {
        _this.initFromArray(urls, options);
      }
      return _this;
    }
    ArrayResource3.prototype.addBaseTextureAt = function(baseTexture, index2) {
      if (baseTexture.resource) {
        this.addResourceAt(baseTexture.resource, index2);
      } else {
        throw new Error("ArrayResource does not support RenderTexture");
      }
      return this;
    };
    ArrayResource3.prototype.bind = function(baseTexture) {
      _super.prototype.bind.call(this, baseTexture);
      baseTexture.target = TARGETS2.TEXTURE_2D_ARRAY;
    };
    ArrayResource3.prototype.upload = function(renderer, texture, glTexture) {
      var _a = this, length = _a.length, itemDirtyIds = _a.itemDirtyIds, items = _a.items;
      var gl = renderer.gl;
      if (glTexture.dirtyId < 0) {
        gl.texImage3D(gl.TEXTURE_2D_ARRAY, 0, texture.format, this._width, this._height, length, 0, texture.format, texture.type, null);
      }
      for (var i = 0; i < length; i++) {
        var item = items[i];
        if (itemDirtyIds[i] < item.dirtyId) {
          itemDirtyIds[i] = item.dirtyId;
          if (item.valid) {
            gl.texSubImage3D(
              gl.TEXTURE_2D_ARRAY,
              0,
              0,
              // xoffset
              0,
              // yoffset
              i,
              // zoffset
              item.resource.width,
              item.resource.height,
              1,
              texture.format,
              texture.type,
              item.resource.source
            );
          }
        }
      }
      return true;
    };
    return ArrayResource3;
  }(AbstractMultiResource2)
);
var BaseImageResource2 = (
  /** @class */
  function(_super) {
    __extends3(BaseImageResource3, _super);
    function BaseImageResource3(source) {
      var _this = this;
      var sourceAny = source;
      var width = sourceAny.naturalWidth || sourceAny.videoWidth || sourceAny.width;
      var height = sourceAny.naturalHeight || sourceAny.videoHeight || sourceAny.height;
      _this = _super.call(this, width, height) || this;
      _this.source = source;
      _this.noSubImage = false;
      return _this;
    }
    BaseImageResource3.crossOrigin = function(element, url, crossorigin) {
      if (crossorigin === void 0 && url.indexOf("data:") !== 0) {
        element.crossOrigin = determineCrossOrigin2(url);
      } else if (crossorigin !== false) {
        element.crossOrigin = typeof crossorigin === "string" ? crossorigin : "anonymous";
      }
    };
    BaseImageResource3.prototype.upload = function(renderer, baseTexture, glTexture, source) {
      var gl = renderer.gl;
      var width = baseTexture.realWidth;
      var height = baseTexture.realHeight;
      source = source || this.source;
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === ALPHA_MODES2.UNPACK);
      if (!this.noSubImage && baseTexture.target === gl.TEXTURE_2D && glTexture.width === width && glTexture.height === height) {
        gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, baseTexture.format, baseTexture.type, source);
      } else {
        glTexture.width = width;
        glTexture.height = height;
        gl.texImage2D(baseTexture.target, 0, baseTexture.format, baseTexture.format, baseTexture.type, source);
      }
      return true;
    };
    BaseImageResource3.prototype.update = function() {
      if (this.destroyed) {
        return;
      }
      var source = this.source;
      var width = source.naturalWidth || source.videoWidth || source.width;
      var height = source.naturalHeight || source.videoHeight || source.height;
      this.resize(width, height);
      _super.prototype.update.call(this);
    };
    BaseImageResource3.prototype.dispose = function() {
      this.source = null;
    };
    return BaseImageResource3;
  }(Resource3)
);
var CanvasResource2 = (
  /** @class */
  function(_super) {
    __extends3(CanvasResource3, _super);
    function CanvasResource3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    CanvasResource3.test = function(source) {
      var OffscreenCanvas = window.OffscreenCanvas;
      if (OffscreenCanvas && source instanceof OffscreenCanvas) {
        return true;
      }
      return source instanceof HTMLCanvasElement;
    };
    return CanvasResource3;
  }(BaseImageResource2)
);
var CubeResource2 = (
  /** @class */
  function(_super) {
    __extends3(CubeResource3, _super);
    function CubeResource3(source, options) {
      var _this = this;
      var _a = options || {}, width = _a.width, height = _a.height, autoLoad = _a.autoLoad, linkBaseTexture = _a.linkBaseTexture;
      if (source && source.length !== CubeResource3.SIDES) {
        throw new Error("Invalid length. Got " + source.length + ", expected 6");
      }
      _this = _super.call(this, 6, { width, height }) || this;
      for (var i = 0; i < CubeResource3.SIDES; i++) {
        _this.items[i].target = TARGETS2.TEXTURE_CUBE_MAP_POSITIVE_X + i;
      }
      _this.linkBaseTexture = linkBaseTexture !== false;
      if (source) {
        _this.initFromArray(source, options);
      }
      if (autoLoad !== false) {
        _this.load();
      }
      return _this;
    }
    CubeResource3.prototype.bind = function(baseTexture) {
      _super.prototype.bind.call(this, baseTexture);
      baseTexture.target = TARGETS2.TEXTURE_CUBE_MAP;
    };
    CubeResource3.prototype.addBaseTextureAt = function(baseTexture, index2, linkBaseTexture) {
      if (linkBaseTexture === void 0) {
        linkBaseTexture = this.linkBaseTexture;
      }
      if (!this.items[index2]) {
        throw new Error("Index " + index2 + " is out of bounds");
      }
      if (!this.linkBaseTexture || baseTexture.parentTextureArray || Object.keys(baseTexture._glTextures).length > 0) {
        if (baseTexture.resource) {
          this.addResourceAt(baseTexture.resource, index2);
        } else {
          throw new Error("CubeResource does not support copying of renderTexture.");
        }
      } else {
        baseTexture.target = TARGETS2.TEXTURE_CUBE_MAP_POSITIVE_X + index2;
        baseTexture.parentTextureArray = this.baseTexture;
        this.items[index2] = baseTexture;
      }
      if (baseTexture.valid && !this.valid) {
        this.resize(baseTexture.realWidth, baseTexture.realHeight);
      }
      this.items[index2] = baseTexture;
      return this;
    };
    CubeResource3.prototype.upload = function(renderer, _baseTexture, glTexture) {
      var dirty = this.itemDirtyIds;
      for (var i = 0; i < CubeResource3.SIDES; i++) {
        var side = this.items[i];
        if (dirty[i] < side.dirtyId) {
          if (side.valid && side.resource) {
            side.resource.upload(renderer, side, glTexture);
            dirty[i] = side.dirtyId;
          } else if (dirty[i] < -1) {
            renderer.gl.texImage2D(side.target, 0, glTexture.internalFormat, _baseTexture.realWidth, _baseTexture.realHeight, 0, _baseTexture.format, glTexture.type, null);
            dirty[i] = -1;
          }
        }
      }
      return true;
    };
    CubeResource3.test = function(source) {
      return Array.isArray(source) && source.length === CubeResource3.SIDES;
    };
    CubeResource3.SIDES = 6;
    return CubeResource3;
  }(AbstractMultiResource2)
);
var ImageResource2 = (
  /** @class */
  function(_super) {
    __extends3(ImageResource3, _super);
    function ImageResource3(source, options) {
      var _this = this;
      options = options || {};
      if (!(source instanceof HTMLImageElement)) {
        var imageElement = new Image();
        BaseImageResource2.crossOrigin(imageElement, source, options.crossorigin);
        imageElement.src = source;
        source = imageElement;
      }
      _this = _super.call(this, source) || this;
      if (!source.complete && !!_this._width && !!_this._height) {
        _this._width = 0;
        _this._height = 0;
      }
      _this.url = source.src;
      _this._process = null;
      _this.preserveBitmap = false;
      _this.createBitmap = (options.createBitmap !== void 0 ? options.createBitmap : settings2.CREATE_IMAGE_BITMAP) && !!window.createImageBitmap;
      _this.alphaMode = typeof options.alphaMode === "number" ? options.alphaMode : null;
      if (options.premultiplyAlpha !== void 0) {
        _this.premultiplyAlpha = options.premultiplyAlpha;
      }
      _this.bitmap = null;
      _this._load = null;
      if (options.autoLoad !== false) {
        _this.load();
      }
      return _this;
    }
    ImageResource3.prototype.load = function(createBitmap) {
      var _this = this;
      if (this._load) {
        return this._load;
      }
      if (createBitmap !== void 0) {
        this.createBitmap = createBitmap;
      }
      this._load = new Promise(function(resolve, reject) {
        var source = _this.source;
        _this.url = source.src;
        var completed = function() {
          if (_this.destroyed) {
            return;
          }
          source.onload = null;
          source.onerror = null;
          _this.resize(source.width, source.height);
          _this._load = null;
          if (_this.createBitmap) {
            resolve(_this.process());
          } else {
            resolve(_this);
          }
        };
        if (source.complete && source.src) {
          completed();
        } else {
          source.onload = completed;
          source.onerror = function(event) {
            reject(event);
            _this.onError.emit(event);
          };
        }
      });
      return this._load;
    };
    ImageResource3.prototype.process = function() {
      var _this = this;
      var source = this.source;
      if (this._process !== null) {
        return this._process;
      }
      if (this.bitmap !== null || !window.createImageBitmap) {
        return Promise.resolve(this);
      }
      this._process = window.createImageBitmap(source, 0, 0, source.width, source.height, {
        premultiplyAlpha: this.alphaMode === ALPHA_MODES2.UNPACK ? "premultiply" : "none"
      }).then(function(bitmap) {
        if (_this.destroyed) {
          return Promise.reject();
        }
        _this.bitmap = bitmap;
        _this.update();
        _this._process = null;
        return Promise.resolve(_this);
      });
      return this._process;
    };
    ImageResource3.prototype.upload = function(renderer, baseTexture, glTexture) {
      if (typeof this.alphaMode === "number") {
        baseTexture.alphaMode = this.alphaMode;
      }
      if (!this.createBitmap) {
        return _super.prototype.upload.call(this, renderer, baseTexture, glTexture);
      }
      if (!this.bitmap) {
        this.process();
        if (!this.bitmap) {
          return false;
        }
      }
      _super.prototype.upload.call(this, renderer, baseTexture, glTexture, this.bitmap);
      if (!this.preserveBitmap) {
        var flag = true;
        var glTextures = baseTexture._glTextures;
        for (var key in glTextures) {
          var otherTex = glTextures[key];
          if (otherTex !== glTexture && otherTex.dirtyId !== baseTexture.dirtyId) {
            flag = false;
            break;
          }
        }
        if (flag) {
          if (this.bitmap.close) {
            this.bitmap.close();
          }
          this.bitmap = null;
        }
      }
      return true;
    };
    ImageResource3.prototype.dispose = function() {
      this.source.onload = null;
      this.source.onerror = null;
      _super.prototype.dispose.call(this);
      if (this.bitmap) {
        this.bitmap.close();
        this.bitmap = null;
      }
      this._process = null;
      this._load = null;
    };
    ImageResource3.test = function(source) {
      return typeof source === "string" || source instanceof HTMLImageElement;
    };
    return ImageResource3;
  }(BaseImageResource2)
);
var SVGResource2 = (
  /** @class */
  function(_super) {
    __extends3(SVGResource3, _super);
    function SVGResource3(sourceBase64, options) {
      var _this = this;
      options = options || {};
      _this = _super.call(this, document.createElement("canvas")) || this;
      _this._width = 0;
      _this._height = 0;
      _this.svg = sourceBase64;
      _this.scale = options.scale || 1;
      _this._overrideWidth = options.width;
      _this._overrideHeight = options.height;
      _this._resolve = null;
      _this._crossorigin = options.crossorigin;
      _this._load = null;
      if (options.autoLoad !== false) {
        _this.load();
      }
      return _this;
    }
    SVGResource3.prototype.load = function() {
      var _this = this;
      if (this._load) {
        return this._load;
      }
      this._load = new Promise(function(resolve) {
        _this._resolve = function() {
          _this.resize(_this.source.width, _this.source.height);
          resolve(_this);
        };
        if (/^\<svg/.test(_this.svg.trim())) {
          if (!btoa) {
            throw new Error("Your browser doesn't support base64 conversions.");
          }
          _this.svg = "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(_this.svg)));
        }
        _this._loadSvg();
      });
      return this._load;
    };
    SVGResource3.prototype._loadSvg = function() {
      var _this = this;
      var tempImage = new Image();
      BaseImageResource2.crossOrigin(tempImage, this.svg, this._crossorigin);
      tempImage.src = this.svg;
      tempImage.onerror = function(event) {
        if (!_this._resolve) {
          return;
        }
        tempImage.onerror = null;
        _this.onError.emit(event);
      };
      tempImage.onload = function() {
        if (!_this._resolve) {
          return;
        }
        var svgWidth = tempImage.width;
        var svgHeight = tempImage.height;
        if (!svgWidth || !svgHeight) {
          throw new Error("The SVG image must have width and height defined (in pixels), canvas API needs them.");
        }
        var width = svgWidth * _this.scale;
        var height = svgHeight * _this.scale;
        if (_this._overrideWidth || _this._overrideHeight) {
          width = _this._overrideWidth || _this._overrideHeight / svgHeight * svgWidth;
          height = _this._overrideHeight || _this._overrideWidth / svgWidth * svgHeight;
        }
        width = Math.round(width);
        height = Math.round(height);
        var canvas = _this.source;
        canvas.width = width;
        canvas.height = height;
        canvas._pixiId = "canvas_" + uid2();
        canvas.getContext("2d").drawImage(tempImage, 0, 0, svgWidth, svgHeight, 0, 0, width, height);
        _this._resolve();
        _this._resolve = null;
      };
    };
    SVGResource3.getSize = function(svgString) {
      var sizeMatch = SVGResource3.SVG_SIZE.exec(svgString);
      var size = {};
      if (sizeMatch) {
        size[sizeMatch[1]] = Math.round(parseFloat(sizeMatch[3]));
        size[sizeMatch[5]] = Math.round(parseFloat(sizeMatch[7]));
      }
      return size;
    };
    SVGResource3.prototype.dispose = function() {
      _super.prototype.dispose.call(this);
      this._resolve = null;
      this._crossorigin = null;
    };
    SVGResource3.test = function(source, extension) {
      return extension === "svg" || typeof source === "string" && /^data:image\/svg\+xml(;(charset=utf8|utf8))?;base64/.test(source) || typeof source === "string" && source.indexOf("<svg") === 0;
    };
    SVGResource3.SVG_SIZE = /<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i;
    return SVGResource3;
  }(BaseImageResource2)
);
var VideoResource2 = (
  /** @class */
  function(_super) {
    __extends3(VideoResource3, _super);
    function VideoResource3(source, options) {
      var _this = this;
      options = options || {};
      if (!(source instanceof HTMLVideoElement)) {
        var videoElement = document.createElement("video");
        videoElement.setAttribute("preload", "auto");
        videoElement.setAttribute("webkit-playsinline", "");
        videoElement.setAttribute("playsinline", "");
        if (typeof source === "string") {
          source = [source];
        }
        var firstSrc = source[0].src || source[0];
        BaseImageResource2.crossOrigin(videoElement, firstSrc, options.crossorigin);
        for (var i = 0; i < source.length; ++i) {
          var sourceElement = document.createElement("source");
          var _a = source[i], src = _a.src, mime = _a.mime;
          src = src || source[i];
          var baseSrc = src.split("?").shift().toLowerCase();
          var ext = baseSrc.substr(baseSrc.lastIndexOf(".") + 1);
          mime = mime || VideoResource3.MIME_TYPES[ext] || "video/" + ext;
          sourceElement.src = src;
          sourceElement.type = mime;
          videoElement.appendChild(sourceElement);
        }
        source = videoElement;
      }
      _this = _super.call(this, source) || this;
      _this.noSubImage = true;
      _this._autoUpdate = true;
      _this._isConnectedToTicker = false;
      _this._updateFPS = options.updateFPS || 0;
      _this._msToNextUpdate = 0;
      _this.autoPlay = options.autoPlay !== false;
      _this._load = null;
      _this._resolve = null;
      _this._onCanPlay = _this._onCanPlay.bind(_this);
      _this._onError = _this._onError.bind(_this);
      if (options.autoLoad !== false) {
        _this.load();
      }
      return _this;
    }
    VideoResource3.prototype.update = function(_deltaTime) {
      if (_deltaTime === void 0) {
        _deltaTime = 0;
      }
      if (!this.destroyed) {
        var elapsedMS = Ticker2.shared.elapsedMS * this.source.playbackRate;
        this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);
        if (!this._updateFPS || this._msToNextUpdate <= 0) {
          _super.prototype.update.call(this);
          this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0;
        }
      }
    };
    VideoResource3.prototype.load = function() {
      var _this = this;
      if (this._load) {
        return this._load;
      }
      var source = this.source;
      if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA) && source.width && source.height) {
        source.complete = true;
      }
      source.addEventListener("play", this._onPlayStart.bind(this));
      source.addEventListener("pause", this._onPlayStop.bind(this));
      if (!this._isSourceReady()) {
        source.addEventListener("canplay", this._onCanPlay);
        source.addEventListener("canplaythrough", this._onCanPlay);
        source.addEventListener("error", this._onError, true);
      } else {
        this._onCanPlay();
      }
      this._load = new Promise(function(resolve) {
        if (_this.valid) {
          resolve(_this);
        } else {
          _this._resolve = resolve;
          source.load();
        }
      });
      return this._load;
    };
    VideoResource3.prototype._onError = function(event) {
      this.source.removeEventListener("error", this._onError, true);
      this.onError.emit(event);
    };
    VideoResource3.prototype._isSourcePlaying = function() {
      var source = this.source;
      return source.currentTime > 0 && source.paused === false && source.ended === false && source.readyState > 2;
    };
    VideoResource3.prototype._isSourceReady = function() {
      var source = this.source;
      return source.readyState === 3 || source.readyState === 4;
    };
    VideoResource3.prototype._onPlayStart = function() {
      if (!this.valid) {
        this._onCanPlay();
      }
      if (this.autoUpdate && !this._isConnectedToTicker) {
        Ticker2.shared.add(this.update, this);
        this._isConnectedToTicker = true;
      }
    };
    VideoResource3.prototype._onPlayStop = function() {
      if (this._isConnectedToTicker) {
        Ticker2.shared.remove(this.update, this);
        this._isConnectedToTicker = false;
      }
    };
    VideoResource3.prototype._onCanPlay = function() {
      var source = this.source;
      source.removeEventListener("canplay", this._onCanPlay);
      source.removeEventListener("canplaythrough", this._onCanPlay);
      var valid = this.valid;
      this.resize(source.videoWidth, source.videoHeight);
      if (!valid && this._resolve) {
        this._resolve(this);
        this._resolve = null;
      }
      if (this._isSourcePlaying()) {
        this._onPlayStart();
      } else if (this.autoPlay) {
        source.play();
      }
    };
    VideoResource3.prototype.dispose = function() {
      if (this._isConnectedToTicker) {
        Ticker2.shared.remove(this.update, this);
      }
      var source = this.source;
      if (source) {
        source.removeEventListener("error", this._onError, true);
        source.pause();
        source.src = "";
        source.load();
      }
      _super.prototype.dispose.call(this);
    };
    Object.defineProperty(VideoResource3.prototype, "autoUpdate", {
      /**
       * Should the base texture automatically update itself, set to true by default
       *
       * @member {boolean}
       */
      get: function() {
        return this._autoUpdate;
      },
      set: function(value) {
        if (value !== this._autoUpdate) {
          this._autoUpdate = value;
          if (!this._autoUpdate && this._isConnectedToTicker) {
            Ticker2.shared.remove(this.update, this);
            this._isConnectedToTicker = false;
          } else if (this._autoUpdate && !this._isConnectedToTicker && this._isSourcePlaying()) {
            Ticker2.shared.add(this.update, this);
            this._isConnectedToTicker = true;
          }
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(VideoResource3.prototype, "updateFPS", {
      /**
       * How many times a second to update the texture from the video. Leave at 0 to update at every render.
       * A lower fps can help performance, as updating the texture at 60fps on a 30ps video may not be efficient.
       *
       * @member {number}
       */
      get: function() {
        return this._updateFPS;
      },
      set: function(value) {
        if (value !== this._updateFPS) {
          this._updateFPS = value;
        }
      },
      enumerable: false,
      configurable: true
    });
    VideoResource3.test = function(source, extension) {
      return source instanceof HTMLVideoElement || VideoResource3.TYPES.indexOf(extension) > -1;
    };
    VideoResource3.TYPES = ["mp4", "m4v", "webm", "ogg", "ogv", "h264", "avi", "mov"];
    VideoResource3.MIME_TYPES = {
      ogv: "video/ogg",
      mov: "video/quicktime",
      m4v: "video/mp4"
    };
    return VideoResource3;
  }(BaseImageResource2)
);
var ImageBitmapResource2 = (
  /** @class */
  function(_super) {
    __extends3(ImageBitmapResource3, _super);
    function ImageBitmapResource3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    ImageBitmapResource3.test = function(source) {
      return !!window.createImageBitmap && source instanceof ImageBitmap;
    };
    return ImageBitmapResource3;
  }(BaseImageResource2)
);
INSTALLED2.push(ImageResource2, ImageBitmapResource2, CanvasResource2, VideoResource2, SVGResource2, BufferResource2, CubeResource2, ArrayResource2);
var System2 = (
  /** @class */
  function() {
    function System3(renderer) {
      this.renderer = renderer;
    }
    System3.prototype.destroy = function() {
      this.renderer = null;
    };
    return System3;
  }()
);
var DepthResource2 = (
  /** @class */
  function(_super) {
    __extends3(DepthResource3, _super);
    function DepthResource3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    DepthResource3.prototype.upload = function(renderer, baseTexture, glTexture) {
      var gl = renderer.gl;
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === ALPHA_MODES2.UNPACK);
      if (glTexture.width === baseTexture.width && glTexture.height === baseTexture.height) {
        gl.texSubImage2D(baseTexture.target, 0, 0, 0, baseTexture.width, baseTexture.height, baseTexture.format, baseTexture.type, this.data);
      } else {
        glTexture.width = baseTexture.width;
        glTexture.height = baseTexture.height;
        gl.texImage2D(
          baseTexture.target,
          0,
          //  gl.DEPTH_COMPONENT16 Needed for depth to render properly in webgl2.0
          renderer.context.webGLVersion === 1 ? gl.DEPTH_COMPONENT : gl.DEPTH_COMPONENT16,
          baseTexture.width,
          baseTexture.height,
          0,
          baseTexture.format,
          baseTexture.type,
          this.data
        );
      }
      return true;
    };
    return DepthResource3;
  }(BufferResource2)
);
var Framebuffer2 = (
  /** @class */
  function() {
    function Framebuffer3(width, height) {
      this.width = Math.ceil(width || 100);
      this.height = Math.ceil(height || 100);
      this.stencil = false;
      this.depth = false;
      this.dirtyId = 0;
      this.dirtyFormat = 0;
      this.dirtySize = 0;
      this.depthTexture = null;
      this.colorTextures = [];
      this.glFramebuffers = {};
      this.disposeRunner = new Runner2("disposeFramebuffer");
      this.multisample = MSAA_QUALITY2.NONE;
    }
    Object.defineProperty(Framebuffer3.prototype, "colorTexture", {
      /**
       * Reference to the colorTexture.
       *
       * @member {PIXI.BaseTexture[]}
       * @readonly
       */
      get: function() {
        return this.colorTextures[0];
      },
      enumerable: false,
      configurable: true
    });
    Framebuffer3.prototype.addColorTexture = function(index2, texture) {
      if (index2 === void 0) {
        index2 = 0;
      }
      this.colorTextures[index2] = texture || new BaseTexture2(null, {
        scaleMode: SCALE_MODES2.NEAREST,
        resolution: 1,
        mipmap: MIPMAP_MODES2.OFF,
        width: this.width,
        height: this.height
      });
      this.dirtyId++;
      this.dirtyFormat++;
      return this;
    };
    Framebuffer3.prototype.addDepthTexture = function(texture) {
      this.depthTexture = texture || new BaseTexture2(new DepthResource2(null, { width: this.width, height: this.height }), {
        scaleMode: SCALE_MODES2.NEAREST,
        resolution: 1,
        width: this.width,
        height: this.height,
        mipmap: MIPMAP_MODES2.OFF,
        format: FORMATS2.DEPTH_COMPONENT,
        type: TYPES2.UNSIGNED_SHORT
      });
      this.dirtyId++;
      this.dirtyFormat++;
      return this;
    };
    Framebuffer3.prototype.enableDepth = function() {
      this.depth = true;
      this.dirtyId++;
      this.dirtyFormat++;
      return this;
    };
    Framebuffer3.prototype.enableStencil = function() {
      this.stencil = true;
      this.dirtyId++;
      this.dirtyFormat++;
      return this;
    };
    Framebuffer3.prototype.resize = function(width, height) {
      width = Math.ceil(width);
      height = Math.ceil(height);
      if (width === this.width && height === this.height) {
        return;
      }
      this.width = width;
      this.height = height;
      this.dirtyId++;
      this.dirtySize++;
      for (var i = 0; i < this.colorTextures.length; i++) {
        var texture = this.colorTextures[i];
        var resolution = texture.resolution;
        texture.setSize(width / resolution, height / resolution);
      }
      if (this.depthTexture) {
        var resolution = this.depthTexture.resolution;
        this.depthTexture.setSize(width / resolution, height / resolution);
      }
    };
    Framebuffer3.prototype.dispose = function() {
      this.disposeRunner.emit(this, false);
    };
    Framebuffer3.prototype.destroyDepthTexture = function() {
      if (this.depthTexture) {
        this.depthTexture.destroy();
        this.depthTexture = null;
        ++this.dirtyId;
        ++this.dirtyFormat;
      }
    };
    return Framebuffer3;
  }()
);
var BaseRenderTexture2 = (
  /** @class */
  function(_super) {
    __extends3(BaseRenderTexture3, _super);
    function BaseRenderTexture3(options) {
      var _this = this;
      if (typeof options === "number") {
        var width_1 = arguments[0];
        var height_1 = arguments[1];
        var scaleMode = arguments[2];
        var resolution = arguments[3];
        options = { width: width_1, height: height_1, scaleMode, resolution };
      }
      _this = _super.call(this, null, options) || this;
      var _a = options || {}, width = _a.width, height = _a.height;
      _this.mipmap = 0;
      _this.width = Math.ceil(width) || 100;
      _this.height = Math.ceil(height) || 100;
      _this.valid = true;
      _this.clearColor = [0, 0, 0, 0];
      _this.framebuffer = new Framebuffer2(_this.width * _this.resolution, _this.height * _this.resolution).addColorTexture(0, _this);
      _this.maskStack = [];
      _this.filterStack = [{}];
      return _this;
    }
    BaseRenderTexture3.prototype.resize = function(width, height) {
      width = Math.ceil(width);
      height = Math.ceil(height);
      this.framebuffer.resize(width * this.resolution, height * this.resolution);
    };
    BaseRenderTexture3.prototype.dispose = function() {
      this.framebuffer.dispose();
      _super.prototype.dispose.call(this);
    };
    BaseRenderTexture3.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      this.framebuffer.destroyDepthTexture();
      this.framebuffer = null;
    };
    return BaseRenderTexture3;
  }(BaseTexture2)
);
var TextureUvs2 = (
  /** @class */
  function() {
    function TextureUvs3() {
      this.x0 = 0;
      this.y0 = 0;
      this.x1 = 1;
      this.y1 = 0;
      this.x2 = 1;
      this.y2 = 1;
      this.x3 = 0;
      this.y3 = 1;
      this.uvsFloat32 = new Float32Array(8);
    }
    TextureUvs3.prototype.set = function(frame, baseFrame, rotate) {
      var tw = baseFrame.width;
      var th = baseFrame.height;
      if (rotate) {
        var w2 = frame.width / 2 / tw;
        var h2 = frame.height / 2 / th;
        var cX = frame.x / tw + w2;
        var cY = frame.y / th + h2;
        rotate = groupD82.add(rotate, groupD82.NW);
        this.x0 = cX + w2 * groupD82.uX(rotate);
        this.y0 = cY + h2 * groupD82.uY(rotate);
        rotate = groupD82.add(rotate, 2);
        this.x1 = cX + w2 * groupD82.uX(rotate);
        this.y1 = cY + h2 * groupD82.uY(rotate);
        rotate = groupD82.add(rotate, 2);
        this.x2 = cX + w2 * groupD82.uX(rotate);
        this.y2 = cY + h2 * groupD82.uY(rotate);
        rotate = groupD82.add(rotate, 2);
        this.x3 = cX + w2 * groupD82.uX(rotate);
        this.y3 = cY + h2 * groupD82.uY(rotate);
      } else {
        this.x0 = frame.x / tw;
        this.y0 = frame.y / th;
        this.x1 = (frame.x + frame.width) / tw;
        this.y1 = frame.y / th;
        this.x2 = (frame.x + frame.width) / tw;
        this.y2 = (frame.y + frame.height) / th;
        this.x3 = frame.x / tw;
        this.y3 = (frame.y + frame.height) / th;
      }
      this.uvsFloat32[0] = this.x0;
      this.uvsFloat32[1] = this.y0;
      this.uvsFloat32[2] = this.x1;
      this.uvsFloat32[3] = this.y1;
      this.uvsFloat32[4] = this.x2;
      this.uvsFloat32[5] = this.y2;
      this.uvsFloat32[6] = this.x3;
      this.uvsFloat32[7] = this.y3;
    };
    return TextureUvs3;
  }()
);
var DEFAULT_UVS2 = new TextureUvs2();
var Texture2 = (
  /** @class */
  function(_super) {
    __extends3(Texture3, _super);
    function Texture3(baseTexture, frame, orig, trim, rotate, anchor) {
      var _this = _super.call(this) || this;
      _this.noFrame = false;
      if (!frame) {
        _this.noFrame = true;
        frame = new Rectangle2(0, 0, 1, 1);
      }
      if (baseTexture instanceof Texture3) {
        baseTexture = baseTexture.baseTexture;
      }
      _this.baseTexture = baseTexture;
      _this._frame = frame;
      _this.trim = trim;
      _this.valid = false;
      _this._uvs = DEFAULT_UVS2;
      _this.uvMatrix = null;
      _this.orig = orig || frame;
      _this._rotate = Number(rotate || 0);
      if (rotate === true) {
        _this._rotate = 2;
      } else if (_this._rotate % 2 !== 0) {
        throw new Error("attempt to use diamond-shaped UVs. If you are sure, set rotation manually");
      }
      _this.defaultAnchor = anchor ? new Point2(anchor.x, anchor.y) : new Point2(0, 0);
      _this._updateID = 0;
      _this.textureCacheIds = [];
      if (!baseTexture.valid) {
        baseTexture.once("loaded", _this.onBaseTextureUpdated, _this);
      } else if (_this.noFrame) {
        if (baseTexture.valid) {
          _this.onBaseTextureUpdated(baseTexture);
        }
      } else {
        _this.frame = frame;
      }
      if (_this.noFrame) {
        baseTexture.on("update", _this.onBaseTextureUpdated, _this);
      }
      return _this;
    }
    Texture3.prototype.update = function() {
      if (this.baseTexture.resource) {
        this.baseTexture.resource.update();
      }
    };
    Texture3.prototype.onBaseTextureUpdated = function(baseTexture) {
      if (this.noFrame) {
        if (!this.baseTexture.valid) {
          return;
        }
        this._frame.width = baseTexture.width;
        this._frame.height = baseTexture.height;
        this.valid = true;
        this.updateUvs();
      } else {
        this.frame = this._frame;
      }
      this.emit("update", this);
    };
    Texture3.prototype.destroy = function(destroyBase) {
      if (this.baseTexture) {
        if (destroyBase) {
          var resource = this.baseTexture;
          if (resource && resource.url && TextureCache2[resource.url]) {
            Texture3.removeFromCache(resource.url);
          }
          this.baseTexture.destroy();
        }
        this.baseTexture.off("loaded", this.onBaseTextureUpdated, this);
        this.baseTexture.off("update", this.onBaseTextureUpdated, this);
        this.baseTexture = null;
      }
      this._frame = null;
      this._uvs = null;
      this.trim = null;
      this.orig = null;
      this.valid = false;
      Texture3.removeFromCache(this);
      this.textureCacheIds = null;
    };
    Texture3.prototype.clone = function() {
      return new Texture3(this.baseTexture, this.frame.clone(), this.orig.clone(), this.trim && this.trim.clone(), this.rotate, this.defaultAnchor);
    };
    Texture3.prototype.updateUvs = function() {
      if (this._uvs === DEFAULT_UVS2) {
        this._uvs = new TextureUvs2();
      }
      this._uvs.set(this._frame, this.baseTexture, this.rotate);
      this._updateID++;
    };
    Texture3.from = function(source, options, strict) {
      if (options === void 0) {
        options = {};
      }
      if (strict === void 0) {
        strict = settings2.STRICT_TEXTURE_CACHE;
      }
      var isFrame = typeof source === "string";
      var cacheId = null;
      if (isFrame) {
        cacheId = source;
      } else {
        if (!source._pixiId) {
          source._pixiId = "pixiid_" + uid2();
        }
        cacheId = source._pixiId;
      }
      var texture = TextureCache2[cacheId];
      if (isFrame && strict && !texture) {
        throw new Error('The cacheId "' + cacheId + '" does not exist in TextureCache.');
      }
      if (!texture) {
        if (!options.resolution) {
          options.resolution = getResolutionOfUrl2(source);
        }
        texture = new Texture3(new BaseTexture2(source, options));
        texture.baseTexture.cacheId = cacheId;
        BaseTexture2.addToCache(texture.baseTexture, cacheId);
        Texture3.addToCache(texture, cacheId);
      }
      return texture;
    };
    Texture3.fromURL = function(url, options) {
      var resourceOptions = Object.assign({ autoLoad: false }, options === null || options === void 0 ? void 0 : options.resourceOptions);
      var texture = Texture3.from(url, Object.assign({ resourceOptions }, options), false);
      var resource = texture.baseTexture.resource;
      if (texture.baseTexture.valid) {
        return Promise.resolve(texture);
      }
      return resource.load().then(function() {
        return Promise.resolve(texture);
      });
    };
    Texture3.fromBuffer = function(buffer, width, height, options) {
      return new Texture3(BaseTexture2.fromBuffer(buffer, width, height, options));
    };
    Texture3.fromLoader = function(source, imageUrl, name) {
      var resource = new ImageResource2(source);
      resource.url = imageUrl;
      var baseTexture = new BaseTexture2(resource, {
        scaleMode: settings2.SCALE_MODE,
        resolution: getResolutionOfUrl2(imageUrl)
      });
      var texture = new Texture3(baseTexture);
      if (!name) {
        name = imageUrl;
      }
      BaseTexture2.addToCache(texture.baseTexture, name);
      Texture3.addToCache(texture, name);
      if (name !== imageUrl) {
        BaseTexture2.addToCache(texture.baseTexture, imageUrl);
        Texture3.addToCache(texture, imageUrl);
      }
      return texture;
    };
    Texture3.addToCache = function(texture, id) {
      if (id) {
        if (texture.textureCacheIds.indexOf(id) === -1) {
          texture.textureCacheIds.push(id);
        }
        if (TextureCache2[id]) {
          console.warn("Texture added to the cache with an id [" + id + "] that already had an entry");
        }
        TextureCache2[id] = texture;
      }
    };
    Texture3.removeFromCache = function(texture) {
      if (typeof texture === "string") {
        var textureFromCache = TextureCache2[texture];
        if (textureFromCache) {
          var index2 = textureFromCache.textureCacheIds.indexOf(texture);
          if (index2 > -1) {
            textureFromCache.textureCacheIds.splice(index2, 1);
          }
          delete TextureCache2[texture];
          return textureFromCache;
        }
      } else if (texture && texture.textureCacheIds) {
        for (var i = 0; i < texture.textureCacheIds.length; ++i) {
          if (TextureCache2[texture.textureCacheIds[i]] === texture) {
            delete TextureCache2[texture.textureCacheIds[i]];
          }
        }
        texture.textureCacheIds.length = 0;
        return texture;
      }
      return null;
    };
    Object.defineProperty(Texture3.prototype, "resolution", {
      /**
       * Returns resolution of baseTexture
       *
       * @member {number}
       * @readonly
       */
      get: function() {
        return this.baseTexture.resolution;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Texture3.prototype, "frame", {
      /**
       * The frame specifies the region of the base texture that this texture uses.
       * Please call `updateUvs()` after you change coordinates of `frame` manually.
       *
       * @member {PIXI.Rectangle}
       */
      get: function() {
        return this._frame;
      },
      set: function(frame) {
        this._frame = frame;
        this.noFrame = false;
        var x2 = frame.x, y2 = frame.y, width = frame.width, height = frame.height;
        var xNotFit = x2 + width > this.baseTexture.width;
        var yNotFit = y2 + height > this.baseTexture.height;
        if (xNotFit || yNotFit) {
          var relationship = xNotFit && yNotFit ? "and" : "or";
          var errorX = "X: " + x2 + " + " + width + " = " + (x2 + width) + " > " + this.baseTexture.width;
          var errorY = "Y: " + y2 + " + " + height + " = " + (y2 + height) + " > " + this.baseTexture.height;
          throw new Error("Texture Error: frame does not fit inside the base Texture dimensions: " + (errorX + " " + relationship + " " + errorY));
        }
        this.valid = width && height && this.baseTexture.valid;
        if (!this.trim && !this.rotate) {
          this.orig = frame;
        }
        if (this.valid) {
          this.updateUvs();
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Texture3.prototype, "rotate", {
      /**
       * Indicates whether the texture is rotated inside the atlas
       * set to 2 to compensate for texture packer rotation
       * set to 6 to compensate for spine packer rotation
       * can be used to rotate or mirror sprites
       * See {@link PIXI.groupD8} for explanation
       *
       * @member {number}
       */
      get: function() {
        return this._rotate;
      },
      set: function(rotate) {
        this._rotate = rotate;
        if (this.valid) {
          this.updateUvs();
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Texture3.prototype, "width", {
      /**
       * The width of the Texture in pixels.
       *
       * @member {number}
       */
      get: function() {
        return this.orig.width;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Texture3.prototype, "height", {
      /**
       * The height of the Texture in pixels.
       *
       * @member {number}
       */
      get: function() {
        return this.orig.height;
      },
      enumerable: false,
      configurable: true
    });
    Texture3.prototype.castToBaseTexture = function() {
      return this.baseTexture;
    };
    return Texture3;
  }(import_eventemitter32.default)
);
function createWhiteTexture2() {
  var canvas = document.createElement("canvas");
  canvas.width = 16;
  canvas.height = 16;
  var context3 = canvas.getContext("2d");
  context3.fillStyle = "white";
  context3.fillRect(0, 0, 16, 16);
  return new Texture2(new BaseTexture2(new CanvasResource2(canvas)));
}
function removeAllHandlers2(tex) {
  tex.destroy = function _emptyDestroy() {
  };
  tex.on = function _emptyOn() {
  };
  tex.once = function _emptyOnce() {
  };
  tex.emit = function _emptyEmit() {
  };
}
Texture2.EMPTY = new Texture2(new BaseTexture2());
removeAllHandlers2(Texture2.EMPTY);
removeAllHandlers2(Texture2.EMPTY.baseTexture);
Texture2.WHITE = createWhiteTexture2();
removeAllHandlers2(Texture2.WHITE);
removeAllHandlers2(Texture2.WHITE.baseTexture);
var RenderTexture2 = (
  /** @class */
  function(_super) {
    __extends3(RenderTexture3, _super);
    function RenderTexture3(baseRenderTexture, frame) {
      var _this = this;
      var _legacyRenderer = null;
      if (!(baseRenderTexture instanceof BaseRenderTexture2)) {
        var width = arguments[1];
        var height = arguments[2];
        var scaleMode = arguments[3];
        var resolution = arguments[4];
        console.warn("Please use RenderTexture.create(" + width + ", " + height + ") instead of the ctor directly.");
        _legacyRenderer = arguments[0];
        frame = null;
        baseRenderTexture = new BaseRenderTexture2({
          width,
          height,
          scaleMode,
          resolution
        });
      }
      _this = _super.call(this, baseRenderTexture, frame) || this;
      _this.legacyRenderer = _legacyRenderer;
      _this.valid = true;
      _this.filterFrame = null;
      _this.filterPoolKey = null;
      _this.updateUvs();
      return _this;
    }
    Object.defineProperty(RenderTexture3.prototype, "framebuffer", {
      /**
       * Shortcut to `this.baseTexture.framebuffer`, saves baseTexture cast.
       * @member {PIXI.Framebuffer}
       * @readonly
       */
      get: function() {
        return this.baseTexture.framebuffer;
      },
      enumerable: false,
      configurable: true
    });
    RenderTexture3.prototype.resize = function(width, height, resizeBaseTexture) {
      if (resizeBaseTexture === void 0) {
        resizeBaseTexture = true;
      }
      width = Math.ceil(width);
      height = Math.ceil(height);
      this.valid = width > 0 && height > 0;
      this._frame.width = this.orig.width = width;
      this._frame.height = this.orig.height = height;
      if (resizeBaseTexture) {
        this.baseTexture.resize(width, height);
      }
      this.updateUvs();
    };
    RenderTexture3.prototype.setResolution = function(resolution) {
      var baseTexture = this.baseTexture;
      if (baseTexture.resolution === resolution) {
        return;
      }
      baseTexture.setResolution(resolution);
      this.resize(baseTexture.width, baseTexture.height, false);
    };
    RenderTexture3.create = function(options) {
      if (typeof options === "number") {
        options = {
          width: options,
          height: arguments[1],
          scaleMode: arguments[2],
          resolution: arguments[3]
        };
      }
      return new RenderTexture3(new BaseRenderTexture2(options));
    };
    return RenderTexture3;
  }(Texture2)
);
var RenderTexturePool2 = (
  /** @class */
  function() {
    function RenderTexturePool3(textureOptions) {
      this.texturePool = {};
      this.textureOptions = textureOptions || {};
      this.enableFullScreen = false;
      this._pixelsWidth = 0;
      this._pixelsHeight = 0;
    }
    RenderTexturePool3.prototype.createTexture = function(realWidth, realHeight) {
      var baseRenderTexture = new BaseRenderTexture2(Object.assign({
        width: realWidth,
        height: realHeight,
        resolution: 1
      }, this.textureOptions));
      return new RenderTexture2(baseRenderTexture);
    };
    RenderTexturePool3.prototype.getOptimalTexture = function(minWidth, minHeight, resolution) {
      if (resolution === void 0) {
        resolution = 1;
      }
      var key = RenderTexturePool3.SCREEN_KEY;
      minWidth *= resolution;
      minHeight *= resolution;
      if (!this.enableFullScreen || minWidth !== this._pixelsWidth || minHeight !== this._pixelsHeight) {
        minWidth = nextPow22(minWidth);
        minHeight = nextPow22(minHeight);
        key = (minWidth & 65535) << 16 | minHeight & 65535;
      }
      if (!this.texturePool[key]) {
        this.texturePool[key] = [];
      }
      var renderTexture = this.texturePool[key].pop();
      if (!renderTexture) {
        renderTexture = this.createTexture(minWidth, minHeight);
      }
      renderTexture.filterPoolKey = key;
      renderTexture.setResolution(resolution);
      return renderTexture;
    };
    RenderTexturePool3.prototype.getFilterTexture = function(input, resolution) {
      var filterTexture = this.getOptimalTexture(input.width, input.height, resolution || input.resolution);
      filterTexture.filterFrame = input.filterFrame;
      return filterTexture;
    };
    RenderTexturePool3.prototype.returnTexture = function(renderTexture) {
      var key = renderTexture.filterPoolKey;
      renderTexture.filterFrame = null;
      this.texturePool[key].push(renderTexture);
    };
    RenderTexturePool3.prototype.returnFilterTexture = function(renderTexture) {
      this.returnTexture(renderTexture);
    };
    RenderTexturePool3.prototype.clear = function(destroyTextures) {
      destroyTextures = destroyTextures !== false;
      if (destroyTextures) {
        for (var i in this.texturePool) {
          var textures = this.texturePool[i];
          if (textures) {
            for (var j2 = 0; j2 < textures.length; j2++) {
              textures[j2].destroy(true);
            }
          }
        }
      }
      this.texturePool = {};
    };
    RenderTexturePool3.prototype.setScreenSize = function(size) {
      if (size.width === this._pixelsWidth && size.height === this._pixelsHeight) {
        return;
      }
      var screenKey = RenderTexturePool3.SCREEN_KEY;
      var textures = this.texturePool[screenKey];
      this.enableFullScreen = size.width > 0 && size.height > 0;
      if (textures) {
        for (var j2 = 0; j2 < textures.length; j2++) {
          textures[j2].destroy(true);
        }
      }
      this.texturePool[screenKey] = [];
      this._pixelsWidth = size.width;
      this._pixelsHeight = size.height;
    };
    RenderTexturePool3.SCREEN_KEY = "screen";
    return RenderTexturePool3;
  }()
);
var Attribute2 = (
  /** @class */
  function() {
    function Attribute3(buffer, size, normalized, type, stride, start, instance) {
      if (size === void 0) {
        size = 0;
      }
      if (normalized === void 0) {
        normalized = false;
      }
      if (type === void 0) {
        type = 5126;
      }
      this.buffer = buffer;
      this.size = size;
      this.normalized = normalized;
      this.type = type;
      this.stride = stride;
      this.start = start;
      this.instance = instance;
    }
    Attribute3.prototype.destroy = function() {
      this.buffer = null;
    };
    Attribute3.from = function(buffer, size, normalized, type, stride) {
      return new Attribute3(buffer, size, normalized, type, stride);
    };
    return Attribute3;
  }()
);
var UID2 = 0;
var Buffer2 = (
  /** @class */
  function() {
    function Buffer3(data, _static, index2) {
      if (_static === void 0) {
        _static = true;
      }
      if (index2 === void 0) {
        index2 = false;
      }
      this.data = data || new Float32Array(1);
      this._glBuffers = {};
      this._updateID = 0;
      this.index = index2;
      this.static = _static;
      this.id = UID2++;
      this.disposeRunner = new Runner2("disposeBuffer");
    }
    Buffer3.prototype.update = function(data) {
      this.data = data || this.data;
      this._updateID++;
    };
    Buffer3.prototype.dispose = function() {
      this.disposeRunner.emit(this, false);
    };
    Buffer3.prototype.destroy = function() {
      this.dispose();
      this.data = null;
    };
    Buffer3.from = function(data) {
      if (data instanceof Array) {
        data = new Float32Array(data);
      }
      return new Buffer3(data);
    };
    return Buffer3;
  }()
);
function getBufferType2(array) {
  if (array.BYTES_PER_ELEMENT === 4) {
    if (array instanceof Float32Array) {
      return "Float32Array";
    } else if (array instanceof Uint32Array) {
      return "Uint32Array";
    }
    return "Int32Array";
  } else if (array.BYTES_PER_ELEMENT === 2) {
    if (array instanceof Uint16Array) {
      return "Uint16Array";
    }
  } else if (array.BYTES_PER_ELEMENT === 1) {
    if (array instanceof Uint8Array) {
      return "Uint8Array";
    }
  }
  return null;
}
var map2 = {
  Float32Array,
  Uint32Array,
  Int32Array,
  Uint8Array
};
function interleaveTypedArrays2(arrays, sizes) {
  var outSize = 0;
  var stride = 0;
  var views = {};
  for (var i = 0; i < arrays.length; i++) {
    stride += sizes[i];
    outSize += arrays[i].length;
  }
  var buffer = new ArrayBuffer(outSize * 4);
  var out = null;
  var littleOffset = 0;
  for (var i = 0; i < arrays.length; i++) {
    var size = sizes[i];
    var array = arrays[i];
    var type = getBufferType2(array);
    if (!views[type]) {
      views[type] = new map2[type](buffer);
    }
    out = views[type];
    for (var j2 = 0; j2 < array.length; j2++) {
      var indexStart = (j2 / size | 0) * stride + littleOffset;
      var index2 = j2 % size;
      out[indexStart + index2] = array[j2];
    }
    littleOffset += size;
  }
  return new Float32Array(buffer);
}
var byteSizeMap2 = { 5126: 4, 5123: 2, 5121: 1 };
var UID$12 = 0;
var map$12 = {
  Float32Array,
  Uint32Array,
  Int32Array,
  Uint8Array,
  Uint16Array
};
var Geometry2 = (
  /** @class */
  function() {
    function Geometry3(buffers, attributes) {
      if (buffers === void 0) {
        buffers = [];
      }
      if (attributes === void 0) {
        attributes = {};
      }
      this.buffers = buffers;
      this.indexBuffer = null;
      this.attributes = attributes;
      this.glVertexArrayObjects = {};
      this.id = UID$12++;
      this.instanced = false;
      this.instanceCount = 1;
      this.disposeRunner = new Runner2("disposeGeometry");
      this.refCount = 0;
    }
    Geometry3.prototype.addAttribute = function(id, buffer, size, normalized, type, stride, start, instance) {
      if (size === void 0) {
        size = 0;
      }
      if (normalized === void 0) {
        normalized = false;
      }
      if (instance === void 0) {
        instance = false;
      }
      if (!buffer) {
        throw new Error("You must pass a buffer when creating an attribute");
      }
      if (!(buffer instanceof Buffer2)) {
        if (buffer instanceof Array) {
          buffer = new Float32Array(buffer);
        }
        buffer = new Buffer2(buffer);
      }
      var ids = id.split("|");
      if (ids.length > 1) {
        for (var i = 0; i < ids.length; i++) {
          this.addAttribute(ids[i], buffer, size, normalized, type);
        }
        return this;
      }
      var bufferIndex = this.buffers.indexOf(buffer);
      if (bufferIndex === -1) {
        this.buffers.push(buffer);
        bufferIndex = this.buffers.length - 1;
      }
      this.attributes[id] = new Attribute2(bufferIndex, size, normalized, type, stride, start, instance);
      this.instanced = this.instanced || instance;
      return this;
    };
    Geometry3.prototype.getAttribute = function(id) {
      return this.attributes[id];
    };
    Geometry3.prototype.getBuffer = function(id) {
      return this.buffers[this.getAttribute(id).buffer];
    };
    Geometry3.prototype.addIndex = function(buffer) {
      if (!(buffer instanceof Buffer2)) {
        if (buffer instanceof Array) {
          buffer = new Uint16Array(buffer);
        }
        buffer = new Buffer2(buffer);
      }
      buffer.index = true;
      this.indexBuffer = buffer;
      if (this.buffers.indexOf(buffer) === -1) {
        this.buffers.push(buffer);
      }
      return this;
    };
    Geometry3.prototype.getIndex = function() {
      return this.indexBuffer;
    };
    Geometry3.prototype.interleave = function() {
      if (this.buffers.length === 1 || this.buffers.length === 2 && this.indexBuffer) {
        return this;
      }
      var arrays = [];
      var sizes = [];
      var interleavedBuffer = new Buffer2();
      var i;
      for (i in this.attributes) {
        var attribute = this.attributes[i];
        var buffer = this.buffers[attribute.buffer];
        arrays.push(buffer.data);
        sizes.push(attribute.size * byteSizeMap2[attribute.type] / 4);
        attribute.buffer = 0;
      }
      interleavedBuffer.data = interleaveTypedArrays2(arrays, sizes);
      for (i = 0; i < this.buffers.length; i++) {
        if (this.buffers[i] !== this.indexBuffer) {
          this.buffers[i].destroy();
        }
      }
      this.buffers = [interleavedBuffer];
      if (this.indexBuffer) {
        this.buffers.push(this.indexBuffer);
      }
      return this;
    };
    Geometry3.prototype.getSize = function() {
      for (var i in this.attributes) {
        var attribute = this.attributes[i];
        var buffer = this.buffers[attribute.buffer];
        return buffer.data.length / (attribute.stride / 4 || attribute.size);
      }
      return 0;
    };
    Geometry3.prototype.dispose = function() {
      this.disposeRunner.emit(this, false);
    };
    Geometry3.prototype.destroy = function() {
      this.dispose();
      this.buffers = null;
      this.indexBuffer = null;
      this.attributes = null;
    };
    Geometry3.prototype.clone = function() {
      var geometry = new Geometry3();
      for (var i = 0; i < this.buffers.length; i++) {
        geometry.buffers[i] = new Buffer2(this.buffers[i].data.slice(0));
      }
      for (var i in this.attributes) {
        var attrib = this.attributes[i];
        geometry.attributes[i] = new Attribute2(attrib.buffer, attrib.size, attrib.normalized, attrib.type, attrib.stride, attrib.start, attrib.instance);
      }
      if (this.indexBuffer) {
        geometry.indexBuffer = geometry.buffers[this.buffers.indexOf(this.indexBuffer)];
        geometry.indexBuffer.index = true;
      }
      return geometry;
    };
    Geometry3.merge = function(geometries) {
      var geometryOut = new Geometry3();
      var arrays = [];
      var sizes = [];
      var offsets = [];
      var geometry;
      for (var i = 0; i < geometries.length; i++) {
        geometry = geometries[i];
        for (var j2 = 0; j2 < geometry.buffers.length; j2++) {
          sizes[j2] = sizes[j2] || 0;
          sizes[j2] += geometry.buffers[j2].data.length;
          offsets[j2] = 0;
        }
      }
      for (var i = 0; i < geometry.buffers.length; i++) {
        arrays[i] = new map$12[getBufferType2(geometry.buffers[i].data)](sizes[i]);
        geometryOut.buffers[i] = new Buffer2(arrays[i]);
      }
      for (var i = 0; i < geometries.length; i++) {
        geometry = geometries[i];
        for (var j2 = 0; j2 < geometry.buffers.length; j2++) {
          arrays[j2].set(geometry.buffers[j2].data, offsets[j2]);
          offsets[j2] += geometry.buffers[j2].data.length;
        }
      }
      geometryOut.attributes = geometry.attributes;
      if (geometry.indexBuffer) {
        geometryOut.indexBuffer = geometryOut.buffers[geometry.buffers.indexOf(geometry.indexBuffer)];
        geometryOut.indexBuffer.index = true;
        var offset = 0;
        var stride = 0;
        var offset2 = 0;
        var bufferIndexToCount = 0;
        for (var i = 0; i < geometry.buffers.length; i++) {
          if (geometry.buffers[i] !== geometry.indexBuffer) {
            bufferIndexToCount = i;
            break;
          }
        }
        for (var i in geometry.attributes) {
          var attribute = geometry.attributes[i];
          if ((attribute.buffer | 0) === bufferIndexToCount) {
            stride += attribute.size * byteSizeMap2[attribute.type] / 4;
          }
        }
        for (var i = 0; i < geometries.length; i++) {
          var indexBufferData = geometries[i].indexBuffer.data;
          for (var j2 = 0; j2 < indexBufferData.length; j2++) {
            geometryOut.indexBuffer.data[j2 + offset2] += offset;
          }
          offset += geometry.buffers[bufferIndexToCount].data.length / stride;
          offset2 += indexBufferData.length;
        }
      }
      return geometryOut;
    };
    return Geometry3;
  }()
);
var Quad2 = (
  /** @class */
  function(_super) {
    __extends3(Quad3, _super);
    function Quad3() {
      var _this = _super.call(this) || this;
      _this.addAttribute("aVertexPosition", new Float32Array([
        0,
        0,
        1,
        0,
        1,
        1,
        0,
        1
      ])).addIndex([0, 1, 3, 2]);
      return _this;
    }
    return Quad3;
  }(Geometry2)
);
var QuadUv2 = (
  /** @class */
  function(_super) {
    __extends3(QuadUv3, _super);
    function QuadUv3() {
      var _this = _super.call(this) || this;
      _this.vertices = new Float32Array([
        -1,
        -1,
        1,
        -1,
        1,
        1,
        -1,
        1
      ]);
      _this.uvs = new Float32Array([
        0,
        0,
        1,
        0,
        1,
        1,
        0,
        1
      ]);
      _this.vertexBuffer = new Buffer2(_this.vertices);
      _this.uvBuffer = new Buffer2(_this.uvs);
      _this.addAttribute("aVertexPosition", _this.vertexBuffer).addAttribute("aTextureCoord", _this.uvBuffer).addIndex([0, 1, 2, 0, 2, 3]);
      return _this;
    }
    QuadUv3.prototype.map = function(targetTextureFrame, destinationFrame) {
      var x2 = 0;
      var y2 = 0;
      this.uvs[0] = x2;
      this.uvs[1] = y2;
      this.uvs[2] = x2 + destinationFrame.width / targetTextureFrame.width;
      this.uvs[3] = y2;
      this.uvs[4] = x2 + destinationFrame.width / targetTextureFrame.width;
      this.uvs[5] = y2 + destinationFrame.height / targetTextureFrame.height;
      this.uvs[6] = x2;
      this.uvs[7] = y2 + destinationFrame.height / targetTextureFrame.height;
      x2 = destinationFrame.x;
      y2 = destinationFrame.y;
      this.vertices[0] = x2;
      this.vertices[1] = y2;
      this.vertices[2] = x2 + destinationFrame.width;
      this.vertices[3] = y2;
      this.vertices[4] = x2 + destinationFrame.width;
      this.vertices[5] = y2 + destinationFrame.height;
      this.vertices[6] = x2;
      this.vertices[7] = y2 + destinationFrame.height;
      this.invalidate();
      return this;
    };
    QuadUv3.prototype.invalidate = function() {
      this.vertexBuffer._updateID++;
      this.uvBuffer._updateID++;
      return this;
    };
    return QuadUv3;
  }(Geometry2)
);
var UID$22 = 0;
var UniformGroup2 = (
  /** @class */
  function() {
    function UniformGroup3(uniforms, _static) {
      this.uniforms = uniforms;
      this.group = true;
      this.syncUniforms = {};
      this.dirtyId = 0;
      this.id = UID$22++;
      this.static = !!_static;
    }
    UniformGroup3.prototype.update = function() {
      this.dirtyId++;
    };
    UniformGroup3.prototype.add = function(name, uniforms, _static) {
      this.uniforms[name] = new UniformGroup3(uniforms, _static);
    };
    UniformGroup3.from = function(uniforms, _static) {
      return new UniformGroup3(uniforms, _static);
    };
    return UniformGroup3;
  }()
);
var FilterState2 = (
  /** @class */
  function() {
    function FilterState3() {
      this.renderTexture = null;
      this.target = null;
      this.legacy = false;
      this.resolution = 1;
      this.sourceFrame = new Rectangle2();
      this.destinationFrame = new Rectangle2();
      this.filters = [];
    }
    FilterState3.prototype.clear = function() {
      this.target = null;
      this.filters = null;
      this.renderTexture = null;
    };
    return FilterState3;
  }()
);
var FilterSystem2 = (
  /** @class */
  function(_super) {
    __extends3(FilterSystem3, _super);
    function FilterSystem3(renderer) {
      var _this = _super.call(this, renderer) || this;
      _this.defaultFilterStack = [{}];
      _this.texturePool = new RenderTexturePool2();
      _this.texturePool.setScreenSize(renderer.view);
      _this.statePool = [];
      _this.quad = new Quad2();
      _this.quadUv = new QuadUv2();
      _this.tempRect = new Rectangle2();
      _this.activeState = {};
      _this.globalUniforms = new UniformGroup2({
        outputFrame: _this.tempRect,
        inputSize: new Float32Array(4),
        inputPixel: new Float32Array(4),
        inputClamp: new Float32Array(4),
        resolution: 1,
        // legacy variables
        filterArea: new Float32Array(4),
        filterClamp: new Float32Array(4)
      }, true);
      _this.forceClear = false;
      _this.useMaxPadding = false;
      return _this;
    }
    FilterSystem3.prototype.push = function(target, filters) {
      var renderer = this.renderer;
      var filterStack = this.defaultFilterStack;
      var state = this.statePool.pop() || new FilterState2();
      var resolution = filters[0].resolution;
      var padding = filters[0].padding;
      var autoFit = filters[0].autoFit;
      var legacy = filters[0].legacy;
      for (var i = 1; i < filters.length; i++) {
        var filter = filters[i];
        resolution = Math.min(resolution, filter.resolution);
        padding = this.useMaxPadding ? Math.max(padding, filter.padding) : padding + filter.padding;
        autoFit = autoFit && filter.autoFit;
        legacy = legacy || filter.legacy;
      }
      if (filterStack.length === 1) {
        this.defaultFilterStack[0].renderTexture = renderer.renderTexture.current;
      }
      filterStack.push(state);
      state.resolution = resolution;
      state.legacy = legacy;
      state.target = target;
      state.sourceFrame.copyFrom(target.filterArea || target.getBounds(true));
      state.sourceFrame.pad(padding);
      if (autoFit) {
        state.sourceFrame.fit(this.renderer.renderTexture.sourceFrame);
      }
      state.sourceFrame.ceil(resolution);
      state.renderTexture = this.getOptimalFilterTexture(state.sourceFrame.width, state.sourceFrame.height, resolution);
      state.filters = filters;
      state.destinationFrame.width = state.renderTexture.width;
      state.destinationFrame.height = state.renderTexture.height;
      var destinationFrame = this.tempRect;
      destinationFrame.width = state.sourceFrame.width;
      destinationFrame.height = state.sourceFrame.height;
      state.renderTexture.filterFrame = state.sourceFrame;
      renderer.renderTexture.bind(state.renderTexture, state.sourceFrame, destinationFrame);
      renderer.renderTexture.clear();
    };
    FilterSystem3.prototype.pop = function() {
      var filterStack = this.defaultFilterStack;
      var state = filterStack.pop();
      var filters = state.filters;
      this.activeState = state;
      var globalUniforms = this.globalUniforms.uniforms;
      globalUniforms.outputFrame = state.sourceFrame;
      globalUniforms.resolution = state.resolution;
      var inputSize = globalUniforms.inputSize;
      var inputPixel = globalUniforms.inputPixel;
      var inputClamp = globalUniforms.inputClamp;
      inputSize[0] = state.destinationFrame.width;
      inputSize[1] = state.destinationFrame.height;
      inputSize[2] = 1 / inputSize[0];
      inputSize[3] = 1 / inputSize[1];
      inputPixel[0] = inputSize[0] * state.resolution;
      inputPixel[1] = inputSize[1] * state.resolution;
      inputPixel[2] = 1 / inputPixel[0];
      inputPixel[3] = 1 / inputPixel[1];
      inputClamp[0] = 0.5 * inputPixel[2];
      inputClamp[1] = 0.5 * inputPixel[3];
      inputClamp[2] = state.sourceFrame.width * inputSize[2] - 0.5 * inputPixel[2];
      inputClamp[3] = state.sourceFrame.height * inputSize[3] - 0.5 * inputPixel[3];
      if (state.legacy) {
        var filterArea = globalUniforms.filterArea;
        filterArea[0] = state.destinationFrame.width;
        filterArea[1] = state.destinationFrame.height;
        filterArea[2] = state.sourceFrame.x;
        filterArea[3] = state.sourceFrame.y;
        globalUniforms.filterClamp = globalUniforms.inputClamp;
      }
      this.globalUniforms.update();
      var lastState = filterStack[filterStack.length - 1];
      if (state.renderTexture.framebuffer.multisample > 1) {
        this.renderer.framebuffer.blit();
      }
      if (filters.length === 1) {
        filters[0].apply(this, state.renderTexture, lastState.renderTexture, CLEAR_MODES2.BLEND, state);
        this.returnFilterTexture(state.renderTexture);
      } else {
        var flip = state.renderTexture;
        var flop = this.getOptimalFilterTexture(flip.width, flip.height, state.resolution);
        flop.filterFrame = flip.filterFrame;
        var i = 0;
        for (i = 0; i < filters.length - 1; ++i) {
          filters[i].apply(this, flip, flop, CLEAR_MODES2.CLEAR, state);
          var t = flip;
          flip = flop;
          flop = t;
        }
        filters[i].apply(this, flip, lastState.renderTexture, CLEAR_MODES2.BLEND, state);
        this.returnFilterTexture(flip);
        this.returnFilterTexture(flop);
      }
      state.clear();
      this.statePool.push(state);
    };
    FilterSystem3.prototype.bindAndClear = function(filterTexture, clearMode) {
      if (clearMode === void 0) {
        clearMode = CLEAR_MODES2.CLEAR;
      }
      if (filterTexture && filterTexture.filterFrame) {
        var destinationFrame = this.tempRect;
        destinationFrame.width = filterTexture.filterFrame.width;
        destinationFrame.height = filterTexture.filterFrame.height;
        this.renderer.renderTexture.bind(filterTexture, filterTexture.filterFrame, destinationFrame);
      } else {
        this.renderer.renderTexture.bind(filterTexture);
      }
      if (typeof clearMode === "boolean") {
        clearMode = clearMode ? CLEAR_MODES2.CLEAR : CLEAR_MODES2.BLEND;
        deprecation2("5.2.1", "Use CLEAR_MODES when using clear applyFilter option");
      }
      if (clearMode === CLEAR_MODES2.CLEAR || clearMode === CLEAR_MODES2.BLIT && this.forceClear) {
        this.renderer.renderTexture.clear();
      }
    };
    FilterSystem3.prototype.applyFilter = function(filter, input, output, clearMode) {
      var renderer = this.renderer;
      this.bindAndClear(output, clearMode);
      filter.uniforms.uSampler = input;
      filter.uniforms.filterGlobals = this.globalUniforms;
      renderer.state.set(filter.state);
      renderer.shader.bind(filter);
      if (filter.legacy) {
        this.quadUv.map(input._frame, input.filterFrame);
        renderer.geometry.bind(this.quadUv);
        renderer.geometry.draw(DRAW_MODES2.TRIANGLES);
      } else {
        renderer.geometry.bind(this.quad);
        renderer.geometry.draw(DRAW_MODES2.TRIANGLE_STRIP);
      }
    };
    FilterSystem3.prototype.calculateSpriteMatrix = function(outputMatrix, sprite) {
      var _a = this.activeState, sourceFrame = _a.sourceFrame, destinationFrame = _a.destinationFrame;
      var orig = sprite._texture.orig;
      var mappedMatrix = outputMatrix.set(destinationFrame.width, 0, 0, destinationFrame.height, sourceFrame.x, sourceFrame.y);
      var worldTransform = sprite.worldTransform.copyTo(Matrix2.TEMP_MATRIX);
      worldTransform.invert();
      mappedMatrix.prepend(worldTransform);
      mappedMatrix.scale(1 / orig.width, 1 / orig.height);
      mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);
      return mappedMatrix;
    };
    FilterSystem3.prototype.destroy = function() {
      this.texturePool.clear(false);
    };
    FilterSystem3.prototype.getOptimalFilterTexture = function(minWidth, minHeight, resolution) {
      if (resolution === void 0) {
        resolution = 1;
      }
      return this.texturePool.getOptimalTexture(minWidth, minHeight, resolution);
    };
    FilterSystem3.prototype.getFilterTexture = function(input, resolution) {
      if (typeof input === "number") {
        var swap = input;
        input = resolution;
        resolution = swap;
      }
      input = input || this.activeState.renderTexture;
      var filterTexture = this.texturePool.getOptimalTexture(input.width, input.height, resolution || input.resolution);
      filterTexture.filterFrame = input.filterFrame;
      return filterTexture;
    };
    FilterSystem3.prototype.returnFilterTexture = function(renderTexture) {
      this.texturePool.returnTexture(renderTexture);
    };
    FilterSystem3.prototype.emptyPool = function() {
      this.texturePool.clear(true);
    };
    FilterSystem3.prototype.resize = function() {
      this.texturePool.setScreenSize(this.renderer.view);
    };
    return FilterSystem3;
  }(System2)
);
var ObjectRenderer2 = (
  /** @class */
  function() {
    function ObjectRenderer3(renderer) {
      this.renderer = renderer;
    }
    ObjectRenderer3.prototype.flush = function() {
    };
    ObjectRenderer3.prototype.destroy = function() {
      this.renderer = null;
    };
    ObjectRenderer3.prototype.start = function() {
    };
    ObjectRenderer3.prototype.stop = function() {
      this.flush();
    };
    ObjectRenderer3.prototype.render = function(_object) {
    };
    return ObjectRenderer3;
  }()
);
var BatchSystem2 = (
  /** @class */
  function(_super) {
    __extends3(BatchSystem3, _super);
    function BatchSystem3(renderer) {
      var _this = _super.call(this, renderer) || this;
      _this.emptyRenderer = new ObjectRenderer2(renderer);
      _this.currentRenderer = _this.emptyRenderer;
      return _this;
    }
    BatchSystem3.prototype.setObjectRenderer = function(objectRenderer) {
      if (this.currentRenderer === objectRenderer) {
        return;
      }
      this.currentRenderer.stop();
      this.currentRenderer = objectRenderer;
      this.currentRenderer.start();
    };
    BatchSystem3.prototype.flush = function() {
      this.setObjectRenderer(this.emptyRenderer);
    };
    BatchSystem3.prototype.reset = function() {
      this.setObjectRenderer(this.emptyRenderer);
    };
    BatchSystem3.prototype.copyBoundTextures = function(arr, maxTextures) {
      var boundTextures = this.renderer.texture.boundTextures;
      for (var i = maxTextures - 1; i >= 0; --i) {
        arr[i] = boundTextures[i] || null;
        if (arr[i]) {
          arr[i]._batchLocation = i;
        }
      }
    };
    BatchSystem3.prototype.boundArray = function(texArray, boundTextures, batchId, maxTextures) {
      var elements = texArray.elements, ids = texArray.ids, count = texArray.count;
      var j2 = 0;
      for (var i = 0; i < count; i++) {
        var tex = elements[i];
        var loc = tex._batchLocation;
        if (loc >= 0 && loc < maxTextures && boundTextures[loc] === tex) {
          ids[i] = loc;
          continue;
        }
        while (j2 < maxTextures) {
          var bound = boundTextures[j2];
          if (bound && bound._batchEnabled === batchId && bound._batchLocation === j2) {
            j2++;
            continue;
          }
          ids[i] = j2;
          tex._batchLocation = j2;
          boundTextures[j2] = tex;
          break;
        }
      }
    };
    return BatchSystem3;
  }(System2)
);
var CONTEXT_UID_COUNTER2 = 0;
var ContextSystem2 = (
  /** @class */
  function(_super) {
    __extends3(ContextSystem3, _super);
    function ContextSystem3(renderer) {
      var _this = _super.call(this, renderer) || this;
      _this.webGLVersion = 1;
      _this.extensions = {};
      _this.supports = {
        uint32Indices: false
      };
      _this.handleContextLost = _this.handleContextLost.bind(_this);
      _this.handleContextRestored = _this.handleContextRestored.bind(_this);
      renderer.view.addEventListener("webglcontextlost", _this.handleContextLost, false);
      renderer.view.addEventListener("webglcontextrestored", _this.handleContextRestored, false);
      return _this;
    }
    Object.defineProperty(ContextSystem3.prototype, "isLost", {
      /**
       * `true` if the context is lost
       * @member {boolean}
       * @readonly
       */
      get: function() {
        return !this.gl || this.gl.isContextLost();
      },
      enumerable: false,
      configurable: true
    });
    ContextSystem3.prototype.contextChange = function(gl) {
      this.gl = gl;
      this.renderer.gl = gl;
      this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER2++;
      if (gl.isContextLost() && gl.getExtension("WEBGL_lose_context")) {
        gl.getExtension("WEBGL_lose_context").restoreContext();
      }
    };
    ContextSystem3.prototype.initFromContext = function(gl) {
      this.gl = gl;
      this.validateContext(gl);
      this.renderer.gl = gl;
      this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER2++;
      this.renderer.runners.contextChange.emit(gl);
    };
    ContextSystem3.prototype.initFromOptions = function(options) {
      var gl = this.createContext(this.renderer.view, options);
      this.initFromContext(gl);
    };
    ContextSystem3.prototype.createContext = function(canvas, options) {
      var gl;
      if (settings2.PREFER_ENV >= ENV2.WEBGL2) {
        gl = canvas.getContext("webgl2", options);
      }
      if (gl) {
        this.webGLVersion = 2;
      } else {
        this.webGLVersion = 1;
        gl = canvas.getContext("webgl", options) || canvas.getContext("experimental-webgl", options);
        if (!gl) {
          throw new Error("This browser does not support WebGL. Try using the canvas renderer");
        }
      }
      this.gl = gl;
      this.getExtensions();
      return this.gl;
    };
    ContextSystem3.prototype.getExtensions = function() {
      var gl = this.gl;
      if (this.webGLVersion === 1) {
        Object.assign(this.extensions, {
          drawBuffers: gl.getExtension("WEBGL_draw_buffers"),
          depthTexture: gl.getExtension("WEBGL_depth_texture"),
          loseContext: gl.getExtension("WEBGL_lose_context"),
          vertexArrayObject: gl.getExtension("OES_vertex_array_object") || gl.getExtension("MOZ_OES_vertex_array_object") || gl.getExtension("WEBKIT_OES_vertex_array_object"),
          anisotropicFiltering: gl.getExtension("EXT_texture_filter_anisotropic"),
          uint32ElementIndex: gl.getExtension("OES_element_index_uint"),
          // Floats and half-floats
          floatTexture: gl.getExtension("OES_texture_float"),
          floatTextureLinear: gl.getExtension("OES_texture_float_linear"),
          textureHalfFloat: gl.getExtension("OES_texture_half_float"),
          textureHalfFloatLinear: gl.getExtension("OES_texture_half_float_linear")
        });
      } else if (this.webGLVersion === 2) {
        Object.assign(this.extensions, {
          anisotropicFiltering: gl.getExtension("EXT_texture_filter_anisotropic"),
          // Floats and half-floats
          colorBufferFloat: gl.getExtension("EXT_color_buffer_float"),
          floatTextureLinear: gl.getExtension("OES_texture_float_linear")
        });
      }
    };
    ContextSystem3.prototype.handleContextLost = function(event) {
      event.preventDefault();
    };
    ContextSystem3.prototype.handleContextRestored = function() {
      this.renderer.runners.contextChange.emit(this.gl);
    };
    ContextSystem3.prototype.destroy = function() {
      var view = this.renderer.view;
      view.removeEventListener("webglcontextlost", this.handleContextLost);
      view.removeEventListener("webglcontextrestored", this.handleContextRestored);
      this.gl.useProgram(null);
      if (this.extensions.loseContext) {
        this.extensions.loseContext.loseContext();
      }
    };
    ContextSystem3.prototype.postrender = function() {
      if (this.renderer.renderingToScreen) {
        this.gl.flush();
      }
    };
    ContextSystem3.prototype.validateContext = function(gl) {
      var attributes = gl.getContextAttributes();
      var isWebGl2 = "WebGL2RenderingContext" in window && gl instanceof window.WebGL2RenderingContext;
      if (isWebGl2) {
        this.webGLVersion = 2;
      }
      if (!attributes.stencil) {
        console.warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
      }
      var hasuint32 = isWebGl2 || !!gl.getExtension("OES_element_index_uint");
      this.supports.uint32Indices = hasuint32;
      if (!hasuint32) {
        console.warn("Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly");
      }
    };
    return ContextSystem3;
  }(System2)
);
var GLFramebuffer2 = (
  /** @class */
  /* @__PURE__ */ function() {
    function GLFramebuffer3(framebuffer) {
      this.framebuffer = framebuffer;
      this.stencil = null;
      this.dirtyId = 0;
      this.dirtyFormat = 0;
      this.dirtySize = 0;
      this.multisample = MSAA_QUALITY2.NONE;
      this.msaaBuffer = null;
      this.blitFramebuffer = null;
    }
    return GLFramebuffer3;
  }()
);
var tempRectangle2 = new Rectangle2();
var FramebufferSystem2 = (
  /** @class */
  function(_super) {
    __extends3(FramebufferSystem3, _super);
    function FramebufferSystem3(renderer) {
      var _this = _super.call(this, renderer) || this;
      _this.managedFramebuffers = [];
      _this.unknownFramebuffer = new Framebuffer2(10, 10);
      _this.msaaSamples = null;
      return _this;
    }
    FramebufferSystem3.prototype.contextChange = function() {
      var gl = this.gl = this.renderer.gl;
      this.CONTEXT_UID = this.renderer.CONTEXT_UID;
      this.current = this.unknownFramebuffer;
      this.viewport = new Rectangle2();
      this.hasMRT = true;
      this.writeDepthTexture = true;
      this.disposeAll(true);
      if (this.renderer.context.webGLVersion === 1) {
        var nativeDrawBuffersExtension_1 = this.renderer.context.extensions.drawBuffers;
        var nativeDepthTextureExtension = this.renderer.context.extensions.depthTexture;
        if (settings2.PREFER_ENV === ENV2.WEBGL_LEGACY) {
          nativeDrawBuffersExtension_1 = null;
          nativeDepthTextureExtension = null;
        }
        if (nativeDrawBuffersExtension_1) {
          gl.drawBuffers = function(activeTextures) {
            return nativeDrawBuffersExtension_1.drawBuffersWEBGL(activeTextures);
          };
        } else {
          this.hasMRT = false;
          gl.drawBuffers = function() {
          };
        }
        if (!nativeDepthTextureExtension) {
          this.writeDepthTexture = false;
        }
      } else {
        this.msaaSamples = gl.getInternalformatParameter(gl.RENDERBUFFER, gl.RGBA8, gl.SAMPLES);
      }
    };
    FramebufferSystem3.prototype.bind = function(framebuffer, frame) {
      var gl = this.gl;
      if (framebuffer) {
        var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(framebuffer);
        if (this.current !== framebuffer) {
          this.current = framebuffer;
          gl.bindFramebuffer(gl.FRAMEBUFFER, fbo.framebuffer);
        }
        if (fbo.dirtyId !== framebuffer.dirtyId) {
          fbo.dirtyId = framebuffer.dirtyId;
          if (fbo.dirtyFormat !== framebuffer.dirtyFormat) {
            fbo.dirtyFormat = framebuffer.dirtyFormat;
            this.updateFramebuffer(framebuffer);
          } else if (fbo.dirtySize !== framebuffer.dirtySize) {
            fbo.dirtySize = framebuffer.dirtySize;
            this.resizeFramebuffer(framebuffer);
          }
        }
        for (var i = 0; i < framebuffer.colorTextures.length; i++) {
          var tex = framebuffer.colorTextures[i];
          this.renderer.texture.unbind(tex.parentTextureArray || tex);
        }
        if (framebuffer.depthTexture) {
          this.renderer.texture.unbind(framebuffer.depthTexture);
        }
        if (frame) {
          this.setViewport(frame.x, frame.y, frame.width, frame.height);
        } else {
          this.setViewport(0, 0, framebuffer.width, framebuffer.height);
        }
      } else {
        if (this.current) {
          this.current = null;
          gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        }
        if (frame) {
          this.setViewport(frame.x, frame.y, frame.width, frame.height);
        } else {
          this.setViewport(0, 0, this.renderer.width, this.renderer.height);
        }
      }
    };
    FramebufferSystem3.prototype.setViewport = function(x2, y2, width, height) {
      var v2 = this.viewport;
      if (v2.width !== width || v2.height !== height || v2.x !== x2 || v2.y !== y2) {
        v2.x = x2;
        v2.y = y2;
        v2.width = width;
        v2.height = height;
        this.gl.viewport(x2, y2, width, height);
      }
    };
    Object.defineProperty(FramebufferSystem3.prototype, "size", {
      /**
       * Get the size of the current width and height. Returns object with `width` and `height` values.
       *
       * @member {object}
       * @readonly
       */
      get: function() {
        if (this.current) {
          return { x: 0, y: 0, width: this.current.width, height: this.current.height };
        }
        return { x: 0, y: 0, width: this.renderer.width, height: this.renderer.height };
      },
      enumerable: false,
      configurable: true
    });
    FramebufferSystem3.prototype.clear = function(r2, g2, b2, a2, mask) {
      if (mask === void 0) {
        mask = BUFFER_BITS2.COLOR | BUFFER_BITS2.DEPTH;
      }
      var gl = this.gl;
      gl.clearColor(r2, g2, b2, a2);
      gl.clear(mask);
    };
    FramebufferSystem3.prototype.initFramebuffer = function(framebuffer) {
      var gl = this.gl;
      var fbo = new GLFramebuffer2(gl.createFramebuffer());
      fbo.multisample = this.detectSamples(framebuffer.multisample);
      framebuffer.glFramebuffers[this.CONTEXT_UID] = fbo;
      this.managedFramebuffers.push(framebuffer);
      framebuffer.disposeRunner.add(this);
      return fbo;
    };
    FramebufferSystem3.prototype.resizeFramebuffer = function(framebuffer) {
      var gl = this.gl;
      var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
      if (fbo.stencil) {
        gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.stencil);
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, framebuffer.width, framebuffer.height);
      }
      var colorTextures = framebuffer.colorTextures;
      for (var i = 0; i < colorTextures.length; i++) {
        this.renderer.texture.bind(colorTextures[i], 0);
      }
      if (framebuffer.depthTexture) {
        this.renderer.texture.bind(framebuffer.depthTexture, 0);
      }
    };
    FramebufferSystem3.prototype.updateFramebuffer = function(framebuffer) {
      var gl = this.gl;
      var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
      var colorTextures = framebuffer.colorTextures;
      var count = colorTextures.length;
      if (!gl.drawBuffers) {
        count = Math.min(count, 1);
      }
      if (fbo.multisample > 1) {
        fbo.msaaBuffer = gl.createRenderbuffer();
        gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.msaaBuffer);
        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.RGBA8, framebuffer.width, framebuffer.height);
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, fbo.msaaBuffer);
      }
      var activeTextures = [];
      for (var i = 0; i < count; i++) {
        if (i === 0 && fbo.multisample > 1) {
          continue;
        }
        var texture = framebuffer.colorTextures[i];
        var parentTexture = texture.parentTextureArray || texture;
        this.renderer.texture.bind(parentTexture, 0);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, texture.target, parentTexture._glTextures[this.CONTEXT_UID].texture, 0);
        activeTextures.push(gl.COLOR_ATTACHMENT0 + i);
      }
      if (activeTextures.length > 1) {
        gl.drawBuffers(activeTextures);
      }
      if (framebuffer.depthTexture) {
        var writeDepthTexture = this.writeDepthTexture;
        if (writeDepthTexture) {
          var depthTexture = framebuffer.depthTexture;
          this.renderer.texture.bind(depthTexture, 0);
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, depthTexture._glTextures[this.CONTEXT_UID].texture, 0);
        }
      }
      if (!fbo.stencil && (framebuffer.stencil || framebuffer.depth)) {
        fbo.stencil = gl.createRenderbuffer();
        gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.stencil);
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, framebuffer.width, framebuffer.height);
        if (!framebuffer.depthTexture) {
          gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, fbo.stencil);
        }
      }
    };
    FramebufferSystem3.prototype.detectSamples = function(samples) {
      var msaaSamples = this.msaaSamples;
      var res = MSAA_QUALITY2.NONE;
      if (samples <= 1 || msaaSamples === null) {
        return res;
      }
      for (var i = 0; i < msaaSamples.length; i++) {
        if (msaaSamples[i] <= samples) {
          res = msaaSamples[i];
          break;
        }
      }
      if (res === 1) {
        res = MSAA_QUALITY2.NONE;
      }
      return res;
    };
    FramebufferSystem3.prototype.blit = function(framebuffer, sourcePixels, destPixels) {
      var _a = this, current = _a.current, renderer = _a.renderer, gl = _a.gl, CONTEXT_UID = _a.CONTEXT_UID;
      if (renderer.context.webGLVersion !== 2) {
        return;
      }
      if (!current) {
        return;
      }
      var fbo = current.glFramebuffers[CONTEXT_UID];
      if (!fbo) {
        return;
      }
      if (!framebuffer) {
        if (fbo.multisample <= 1) {
          return;
        }
        if (!fbo.blitFramebuffer) {
          fbo.blitFramebuffer = new Framebuffer2(current.width, current.height);
          fbo.blitFramebuffer.addColorTexture(0, current.colorTextures[0]);
        }
        framebuffer = fbo.blitFramebuffer;
        framebuffer.width = current.width;
        framebuffer.height = current.height;
      }
      if (!sourcePixels) {
        sourcePixels = tempRectangle2;
        sourcePixels.width = current.width;
        sourcePixels.height = current.height;
      }
      if (!destPixels) {
        destPixels = sourcePixels;
      }
      var sameSize = sourcePixels.width === destPixels.width && sourcePixels.height === destPixels.height;
      this.bind(framebuffer);
      gl.bindFramebuffer(gl.READ_FRAMEBUFFER, fbo.framebuffer);
      gl.blitFramebuffer(sourcePixels.x, sourcePixels.y, sourcePixels.width, sourcePixels.height, destPixels.x, destPixels.y, destPixels.width, destPixels.height, gl.COLOR_BUFFER_BIT, sameSize ? gl.NEAREST : gl.LINEAR);
    };
    FramebufferSystem3.prototype.disposeFramebuffer = function(framebuffer, contextLost) {
      var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
      var gl = this.gl;
      if (!fbo) {
        return;
      }
      delete framebuffer.glFramebuffers[this.CONTEXT_UID];
      var index2 = this.managedFramebuffers.indexOf(framebuffer);
      if (index2 >= 0) {
        this.managedFramebuffers.splice(index2, 1);
      }
      framebuffer.disposeRunner.remove(this);
      if (!contextLost) {
        gl.deleteFramebuffer(fbo.framebuffer);
        if (fbo.stencil) {
          gl.deleteRenderbuffer(fbo.stencil);
        }
      }
    };
    FramebufferSystem3.prototype.disposeAll = function(contextLost) {
      var list = this.managedFramebuffers;
      this.managedFramebuffers = [];
      for (var i = 0; i < list.length; i++) {
        this.disposeFramebuffer(list[i], contextLost);
      }
    };
    FramebufferSystem3.prototype.forceStencil = function() {
      var framebuffer = this.current;
      if (!framebuffer) {
        return;
      }
      var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
      if (!fbo || fbo.stencil) {
        return;
      }
      framebuffer.enableStencil();
      var w2 = framebuffer.width;
      var h2 = framebuffer.height;
      var gl = this.gl;
      var stencil = gl.createRenderbuffer();
      gl.bindRenderbuffer(gl.RENDERBUFFER, stencil);
      gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, w2, h2);
      fbo.stencil = stencil;
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, stencil);
    };
    FramebufferSystem3.prototype.reset = function() {
      this.current = this.unknownFramebuffer;
      this.viewport = new Rectangle2();
    };
    return FramebufferSystem3;
  }(System2)
);
var GLBuffer2 = (
  /** @class */
  /* @__PURE__ */ function() {
    function GLBuffer3(buffer) {
      this.buffer = buffer || null;
      this.updateID = -1;
      this.byteLength = -1;
      this.refCount = 0;
    }
    return GLBuffer3;
  }()
);
var byteSizeMap$12 = { 5126: 4, 5123: 2, 5121: 1 };
var GeometrySystem2 = (
  /** @class */
  function(_super) {
    __extends3(GeometrySystem3, _super);
    function GeometrySystem3(renderer) {
      var _this = _super.call(this, renderer) || this;
      _this._activeGeometry = null;
      _this._activeVao = null;
      _this.hasVao = true;
      _this.hasInstance = true;
      _this.canUseUInt32ElementIndex = false;
      _this.managedGeometries = {};
      _this.managedBuffers = {};
      return _this;
    }
    GeometrySystem3.prototype.contextChange = function() {
      this.disposeAll(true);
      var gl = this.gl = this.renderer.gl;
      var context3 = this.renderer.context;
      this.CONTEXT_UID = this.renderer.CONTEXT_UID;
      if (context3.webGLVersion !== 2) {
        var nativeVaoExtension_1 = this.renderer.context.extensions.vertexArrayObject;
        if (settings2.PREFER_ENV === ENV2.WEBGL_LEGACY) {
          nativeVaoExtension_1 = null;
        }
        if (nativeVaoExtension_1) {
          gl.createVertexArray = function() {
            return nativeVaoExtension_1.createVertexArrayOES();
          };
          gl.bindVertexArray = function(vao) {
            return nativeVaoExtension_1.bindVertexArrayOES(vao);
          };
          gl.deleteVertexArray = function(vao) {
            return nativeVaoExtension_1.deleteVertexArrayOES(vao);
          };
        } else {
          this.hasVao = false;
          gl.createVertexArray = function() {
            return null;
          };
          gl.bindVertexArray = function() {
            return null;
          };
          gl.deleteVertexArray = function() {
            return null;
          };
        }
      }
      if (context3.webGLVersion !== 2) {
        var instanceExt_1 = gl.getExtension("ANGLE_instanced_arrays");
        if (instanceExt_1) {
          gl.vertexAttribDivisor = function(a2, b2) {
            return instanceExt_1.vertexAttribDivisorANGLE(a2, b2);
          };
          gl.drawElementsInstanced = function(a2, b2, c2, d2, e) {
            return instanceExt_1.drawElementsInstancedANGLE(a2, b2, c2, d2, e);
          };
          gl.drawArraysInstanced = function(a2, b2, c2, d2) {
            return instanceExt_1.drawArraysInstancedANGLE(a2, b2, c2, d2);
          };
        } else {
          this.hasInstance = false;
        }
      }
      this.canUseUInt32ElementIndex = context3.webGLVersion === 2 || !!context3.extensions.uint32ElementIndex;
    };
    GeometrySystem3.prototype.bind = function(geometry, shader) {
      shader = shader || this.renderer.shader.shader;
      var gl = this.gl;
      var vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];
      var incRefCount = false;
      if (!vaos) {
        this.managedGeometries[geometry.id] = geometry;
        geometry.disposeRunner.add(this);
        geometry.glVertexArrayObjects[this.CONTEXT_UID] = vaos = {};
        incRefCount = true;
      }
      var vao = vaos[shader.program.id] || this.initGeometryVao(geometry, shader.program, incRefCount);
      this._activeGeometry = geometry;
      if (this._activeVao !== vao) {
        this._activeVao = vao;
        if (this.hasVao) {
          gl.bindVertexArray(vao);
        } else {
          this.activateVao(geometry, shader.program);
        }
      }
      this.updateBuffers();
    };
    GeometrySystem3.prototype.reset = function() {
      this.unbind();
    };
    GeometrySystem3.prototype.updateBuffers = function() {
      var geometry = this._activeGeometry;
      var gl = this.gl;
      for (var i = 0; i < geometry.buffers.length; i++) {
        var buffer = geometry.buffers[i];
        var glBuffer = buffer._glBuffers[this.CONTEXT_UID];
        if (buffer._updateID !== glBuffer.updateID) {
          glBuffer.updateID = buffer._updateID;
          var type = buffer.index ? gl.ELEMENT_ARRAY_BUFFER : gl.ARRAY_BUFFER;
          gl.bindBuffer(type, glBuffer.buffer);
          this._boundBuffer = glBuffer;
          if (glBuffer.byteLength >= buffer.data.byteLength) {
            gl.bufferSubData(type, 0, buffer.data);
          } else {
            var drawType = buffer.static ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW;
            glBuffer.byteLength = buffer.data.byteLength;
            gl.bufferData(type, buffer.data, drawType);
          }
        }
      }
    };
    GeometrySystem3.prototype.checkCompatibility = function(geometry, program) {
      var geometryAttributes = geometry.attributes;
      var shaderAttributes = program.attributeData;
      for (var j2 in shaderAttributes) {
        if (!geometryAttributes[j2]) {
          throw new Error('shader and geometry incompatible, geometry missing the "' + j2 + '" attribute');
        }
      }
    };
    GeometrySystem3.prototype.getSignature = function(geometry, program) {
      var attribs = geometry.attributes;
      var shaderAttributes = program.attributeData;
      var strings = ["g", geometry.id];
      for (var i in attribs) {
        if (shaderAttributes[i]) {
          strings.push(i);
        }
      }
      return strings.join("-");
    };
    GeometrySystem3.prototype.initGeometryVao = function(geometry, program, incRefCount) {
      if (incRefCount === void 0) {
        incRefCount = true;
      }
      this.checkCompatibility(geometry, program);
      var gl = this.gl;
      var CONTEXT_UID = this.CONTEXT_UID;
      var signature = this.getSignature(geometry, program);
      var vaoObjectHash = geometry.glVertexArrayObjects[this.CONTEXT_UID];
      var vao = vaoObjectHash[signature];
      if (vao) {
        vaoObjectHash[program.id] = vao;
        return vao;
      }
      var buffers = geometry.buffers;
      var attributes = geometry.attributes;
      var tempStride = {};
      var tempStart = {};
      for (var j2 in buffers) {
        tempStride[j2] = 0;
        tempStart[j2] = 0;
      }
      for (var j2 in attributes) {
        if (!attributes[j2].size && program.attributeData[j2]) {
          attributes[j2].size = program.attributeData[j2].size;
        } else if (!attributes[j2].size) {
          console.warn("PIXI Geometry attribute '" + j2 + "' size cannot be determined (likely the bound shader does not have the attribute)");
        }
        tempStride[attributes[j2].buffer] += attributes[j2].size * byteSizeMap$12[attributes[j2].type];
      }
      for (var j2 in attributes) {
        var attribute = attributes[j2];
        var attribSize = attribute.size;
        if (attribute.stride === void 0) {
          if (tempStride[attribute.buffer] === attribSize * byteSizeMap$12[attribute.type]) {
            attribute.stride = 0;
          } else {
            attribute.stride = tempStride[attribute.buffer];
          }
        }
        if (attribute.start === void 0) {
          attribute.start = tempStart[attribute.buffer];
          tempStart[attribute.buffer] += attribSize * byteSizeMap$12[attribute.type];
        }
      }
      vao = gl.createVertexArray();
      gl.bindVertexArray(vao);
      for (var i = 0; i < buffers.length; i++) {
        var buffer = buffers[i];
        if (!buffer._glBuffers[CONTEXT_UID]) {
          buffer._glBuffers[CONTEXT_UID] = new GLBuffer2(gl.createBuffer());
          this.managedBuffers[buffer.id] = buffer;
          buffer.disposeRunner.add(this);
        }
        if (incRefCount) {
          buffer._glBuffers[CONTEXT_UID].refCount++;
        }
      }
      this.activateVao(geometry, program);
      this._activeVao = vao;
      vaoObjectHash[program.id] = vao;
      vaoObjectHash[signature] = vao;
      return vao;
    };
    GeometrySystem3.prototype.disposeBuffer = function(buffer, contextLost) {
      if (!this.managedBuffers[buffer.id]) {
        return;
      }
      delete this.managedBuffers[buffer.id];
      var glBuffer = buffer._glBuffers[this.CONTEXT_UID];
      var gl = this.gl;
      buffer.disposeRunner.remove(this);
      if (!glBuffer) {
        return;
      }
      if (!contextLost) {
        gl.deleteBuffer(glBuffer.buffer);
      }
      delete buffer._glBuffers[this.CONTEXT_UID];
    };
    GeometrySystem3.prototype.disposeGeometry = function(geometry, contextLost) {
      if (!this.managedGeometries[geometry.id]) {
        return;
      }
      delete this.managedGeometries[geometry.id];
      var vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];
      var gl = this.gl;
      var buffers = geometry.buffers;
      geometry.disposeRunner.remove(this);
      if (!vaos) {
        return;
      }
      for (var i = 0; i < buffers.length; i++) {
        var buf = buffers[i]._glBuffers[this.CONTEXT_UID];
        buf.refCount--;
        if (buf.refCount === 0 && !contextLost) {
          this.disposeBuffer(buffers[i], contextLost);
        }
      }
      if (!contextLost) {
        for (var vaoId in vaos) {
          if (vaoId[0] === "g") {
            var vao = vaos[vaoId];
            if (this._activeVao === vao) {
              this.unbind();
            }
            gl.deleteVertexArray(vao);
          }
        }
      }
      delete geometry.glVertexArrayObjects[this.CONTEXT_UID];
    };
    GeometrySystem3.prototype.disposeAll = function(contextLost) {
      var all = Object.keys(this.managedGeometries);
      for (var i = 0; i < all.length; i++) {
        this.disposeGeometry(this.managedGeometries[all[i]], contextLost);
      }
      all = Object.keys(this.managedBuffers);
      for (var i = 0; i < all.length; i++) {
        this.disposeBuffer(this.managedBuffers[all[i]], contextLost);
      }
    };
    GeometrySystem3.prototype.activateVao = function(geometry, program) {
      var gl = this.gl;
      var CONTEXT_UID = this.CONTEXT_UID;
      var buffers = geometry.buffers;
      var attributes = geometry.attributes;
      if (geometry.indexBuffer) {
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, geometry.indexBuffer._glBuffers[CONTEXT_UID].buffer);
      }
      var lastBuffer = null;
      for (var j2 in attributes) {
        var attribute = attributes[j2];
        var buffer = buffers[attribute.buffer];
        var glBuffer = buffer._glBuffers[CONTEXT_UID];
        if (program.attributeData[j2]) {
          if (lastBuffer !== glBuffer) {
            gl.bindBuffer(gl.ARRAY_BUFFER, glBuffer.buffer);
            lastBuffer = glBuffer;
          }
          var location = program.attributeData[j2].location;
          gl.enableVertexAttribArray(location);
          gl.vertexAttribPointer(location, attribute.size, attribute.type || gl.FLOAT, attribute.normalized, attribute.stride, attribute.start);
          if (attribute.instance) {
            if (this.hasInstance) {
              gl.vertexAttribDivisor(location, 1);
            } else {
              throw new Error("geometry error, GPU Instancing is not supported on this device");
            }
          }
        }
      }
    };
    GeometrySystem3.prototype.draw = function(type, size, start, instanceCount) {
      var gl = this.gl;
      var geometry = this._activeGeometry;
      if (geometry.indexBuffer) {
        var byteSize = geometry.indexBuffer.data.BYTES_PER_ELEMENT;
        var glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;
        if (byteSize === 2 || byteSize === 4 && this.canUseUInt32ElementIndex) {
          if (geometry.instanced) {
            gl.drawElementsInstanced(type, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize, instanceCount || 1);
          } else {
            gl.drawElements(type, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize);
          }
        } else {
          console.warn("unsupported index buffer type: uint32");
        }
      } else if (geometry.instanced) {
        gl.drawArraysInstanced(type, start, size || geometry.getSize(), instanceCount || 1);
      } else {
        gl.drawArrays(type, start, size || geometry.getSize());
      }
      return this;
    };
    GeometrySystem3.prototype.unbind = function() {
      this.gl.bindVertexArray(null);
      this._activeVao = null;
      this._activeGeometry = null;
    };
    return GeometrySystem3;
  }(System2)
);
var MaskData2 = (
  /** @class */
  function() {
    function MaskData3(maskObject) {
      if (maskObject === void 0) {
        maskObject = null;
      }
      this.type = MASK_TYPES2.NONE;
      this.autoDetect = true;
      this.maskObject = maskObject || null;
      this.pooled = false;
      this.isMaskData = true;
      this._stencilCounter = 0;
      this._scissorCounter = 0;
      this._scissorRect = null;
      this._target = null;
    }
    MaskData3.prototype.reset = function() {
      if (this.pooled) {
        this.maskObject = null;
        this.type = MASK_TYPES2.NONE;
        this.autoDetect = true;
      }
      this._target = null;
    };
    MaskData3.prototype.copyCountersOrReset = function(maskAbove) {
      if (maskAbove) {
        this._stencilCounter = maskAbove._stencilCounter;
        this._scissorCounter = maskAbove._scissorCounter;
        this._scissorRect = maskAbove._scissorRect;
      } else {
        this._stencilCounter = 0;
        this._scissorCounter = 0;
        this._scissorRect = null;
      }
    };
    return MaskData3;
  }()
);
function compileShader2(gl, type, src) {
  var shader = gl.createShader(type);
  gl.shaderSource(shader, src);
  gl.compileShader(shader);
  return shader;
}
function compileProgram2(gl, vertexSrc, fragmentSrc, attributeLocations) {
  var glVertShader = compileShader2(gl, gl.VERTEX_SHADER, vertexSrc);
  var glFragShader = compileShader2(gl, gl.FRAGMENT_SHADER, fragmentSrc);
  var program = gl.createProgram();
  gl.attachShader(program, glVertShader);
  gl.attachShader(program, glFragShader);
  if (attributeLocations) {
    for (var i in attributeLocations) {
      gl.bindAttribLocation(program, attributeLocations[i], i);
    }
  }
  gl.linkProgram(program);
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    if (!gl.getShaderParameter(glVertShader, gl.COMPILE_STATUS)) {
      console.warn(vertexSrc);
      console.error(gl.getShaderInfoLog(glVertShader));
    }
    if (!gl.getShaderParameter(glFragShader, gl.COMPILE_STATUS)) {
      console.warn(fragmentSrc);
      console.error(gl.getShaderInfoLog(glFragShader));
    }
    console.error("Pixi.js Error: Could not initialize shader.");
    console.error("gl.VALIDATE_STATUS", gl.getProgramParameter(program, gl.VALIDATE_STATUS));
    console.error("gl.getError()", gl.getError());
    if (gl.getProgramInfoLog(program) !== "") {
      console.warn("Pixi.js Warning: gl.getProgramInfoLog()", gl.getProgramInfoLog(program));
    }
    gl.deleteProgram(program);
    program = null;
  }
  gl.deleteShader(glVertShader);
  gl.deleteShader(glFragShader);
  return program;
}
function booleanArray2(size) {
  var array = new Array(size);
  for (var i = 0; i < array.length; i++) {
    array[i] = false;
  }
  return array;
}
function defaultValue2(type, size) {
  switch (type) {
    case "float":
      return 0;
    case "vec2":
      return new Float32Array(2 * size);
    case "vec3":
      return new Float32Array(3 * size);
    case "vec4":
      return new Float32Array(4 * size);
    case "int":
    case "sampler2D":
    case "sampler2DArray":
      return 0;
    case "ivec2":
      return new Int32Array(2 * size);
    case "ivec3":
      return new Int32Array(3 * size);
    case "ivec4":
      return new Int32Array(4 * size);
    case "bool":
      return false;
    case "bvec2":
      return booleanArray2(2 * size);
    case "bvec3":
      return booleanArray2(3 * size);
    case "bvec4":
      return booleanArray2(4 * size);
    case "mat2":
      return new Float32Array([
        1,
        0,
        0,
        1
      ]);
    case "mat3":
      return new Float32Array([
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      ]);
    case "mat4":
      return new Float32Array([
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ]);
  }
  return null;
}
var unknownContext2 = {};
var context2 = unknownContext2;
function getTestContext2() {
  if (context2 === unknownContext2 || context2 && context2.isContextLost()) {
    var canvas = document.createElement("canvas");
    var gl = void 0;
    if (settings2.PREFER_ENV >= ENV2.WEBGL2) {
      gl = canvas.getContext("webgl2", {});
    }
    if (!gl) {
      gl = canvas.getContext("webgl", {}) || canvas.getContext("experimental-webgl", {});
      if (!gl) {
        gl = null;
      } else {
        gl.getExtension("WEBGL_draw_buffers");
      }
    }
    context2 = gl;
  }
  return context2;
}
var maxFragmentPrecision2;
function getMaxFragmentPrecision2() {
  if (!maxFragmentPrecision2) {
    maxFragmentPrecision2 = PRECISION2.MEDIUM;
    var gl = getTestContext2();
    if (gl) {
      if (gl.getShaderPrecisionFormat) {
        var shaderFragment = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);
        maxFragmentPrecision2 = shaderFragment.precision ? PRECISION2.HIGH : PRECISION2.MEDIUM;
      }
    }
  }
  return maxFragmentPrecision2;
}
function setPrecision2(src, requestedPrecision, maxSupportedPrecision) {
  if (src.substring(0, 9) !== "precision") {
    var precision = requestedPrecision;
    if (requestedPrecision === PRECISION2.HIGH && maxSupportedPrecision !== PRECISION2.HIGH) {
      precision = PRECISION2.MEDIUM;
    }
    return "precision " + precision + " float;\n" + src;
  } else if (maxSupportedPrecision !== PRECISION2.HIGH && src.substring(0, 15) === "precision highp") {
    return src.replace("precision highp", "precision mediump");
  }
  return src;
}
var GLSL_TO_SIZE2 = {
  float: 1,
  vec2: 2,
  vec3: 3,
  vec4: 4,
  int: 1,
  ivec2: 2,
  ivec3: 3,
  ivec4: 4,
  bool: 1,
  bvec2: 2,
  bvec3: 3,
  bvec4: 4,
  mat2: 4,
  mat3: 9,
  mat4: 16,
  sampler2D: 1
};
function mapSize2(type) {
  return GLSL_TO_SIZE2[type];
}
var GL_TABLE2 = null;
var GL_TO_GLSL_TYPES2 = {
  FLOAT: "float",
  FLOAT_VEC2: "vec2",
  FLOAT_VEC3: "vec3",
  FLOAT_VEC4: "vec4",
  INT: "int",
  INT_VEC2: "ivec2",
  INT_VEC3: "ivec3",
  INT_VEC4: "ivec4",
  BOOL: "bool",
  BOOL_VEC2: "bvec2",
  BOOL_VEC3: "bvec3",
  BOOL_VEC4: "bvec4",
  FLOAT_MAT2: "mat2",
  FLOAT_MAT3: "mat3",
  FLOAT_MAT4: "mat4",
  SAMPLER_2D: "sampler2D",
  INT_SAMPLER_2D: "sampler2D",
  UNSIGNED_INT_SAMPLER_2D: "sampler2D",
  SAMPLER_CUBE: "samplerCube",
  INT_SAMPLER_CUBE: "samplerCube",
  UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
  SAMPLER_2D_ARRAY: "sampler2DArray",
  INT_SAMPLER_2D_ARRAY: "sampler2DArray",
  UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"
};
function mapType2(gl, type) {
  if (!GL_TABLE2) {
    var typeNames = Object.keys(GL_TO_GLSL_TYPES2);
    GL_TABLE2 = {};
    for (var i = 0; i < typeNames.length; ++i) {
      var tn = typeNames[i];
      GL_TABLE2[gl[tn]] = GL_TO_GLSL_TYPES2[tn];
    }
  }
  return GL_TABLE2[type];
}
var uniformParsers2 = [
  // a float cache layer
  {
    test: function(data) {
      return data.type === "float" && data.size === 1;
    },
    code: function(name) {
      return '\n            if(uv["' + name + '"] !== ud["' + name + '"].value)\n            {\n                ud["' + name + '"].value = uv["' + name + '"]\n                gl.uniform1f(ud["' + name + '"].location, uv["' + name + '"])\n            }\n            ';
    }
  },
  // handling samplers
  {
    test: function(data) {
      return (data.type === "sampler2D" || data.type === "samplerCube" || data.type === "sampler2DArray") && data.size === 1 && !data.isArray;
    },
    code: function(name) {
      return 't = syncData.textureCount++;\n\n            renderer.texture.bind(uv["' + name + '"], t);\n\n            if(ud["' + name + '"].value !== t)\n            {\n                ud["' + name + '"].value = t;\n                gl.uniform1i(ud["' + name + '"].location, t);\n; // eslint-disable-line max-len\n            }';
    }
  },
  // uploading pixi matrix object to mat3
  {
    test: function(data, uniform) {
      return data.type === "mat3" && data.size === 1 && uniform.a !== void 0;
    },
    code: function(name) {
      return '\n            gl.uniformMatrix3fv(ud["' + name + '"].location, false, uv["' + name + '"].toArray(true));\n            ';
    }
  },
  // uploading a pixi point as a vec2 with caching layer
  {
    test: function(data, uniform) {
      return data.type === "vec2" && data.size === 1 && uniform.x !== void 0;
    },
    code: function(name) {
      return '\n                cv = ud["' + name + '"].value;\n                v = uv["' + name + '"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    gl.uniform2f(ud["' + name + '"].location, v.x, v.y);\n                }';
    }
  },
  // caching layer for a vec2
  {
    test: function(data) {
      return data.type === "vec2" && data.size === 1;
    },
    code: function(name) {
      return '\n                cv = ud["' + name + '"].value;\n                v = uv["' + name + '"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    gl.uniform2f(ud["' + name + '"].location, v[0], v[1]);\n                }\n            ';
    }
  },
  // upload a pixi rectangle as a vec4 with caching layer
  {
    test: function(data, uniform) {
      return data.type === "vec4" && data.size === 1 && uniform.width !== void 0;
    },
    code: function(name) {
      return '\n                cv = ud["' + name + '"].value;\n                v = uv["' + name + '"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    cv[2] = v.width;\n                    cv[3] = v.height;\n                    gl.uniform4f(ud["' + name + '"].location, v.x, v.y, v.width, v.height)\n                }';
    }
  },
  // a caching layer for vec4 uploading
  {
    test: function(data) {
      return data.type === "vec4" && data.size === 1;
    },
    code: function(name) {
      return '\n                cv = ud["' + name + '"].value;\n                v = uv["' + name + '"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    cv[2] = v[2];\n                    cv[3] = v[3];\n\n                    gl.uniform4f(ud["' + name + '"].location, v[0], v[1], v[2], v[3])\n                }';
    }
  }
];
var GLSL_TO_SINGLE_SETTERS_CACHED2 = {
  float: "\n    if(cv !== v)\n    {\n        cv.v = v;\n        gl.uniform1f(location, v)\n    }",
  vec2: "\n    if(cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        gl.uniform2f(location, v[0], v[1])\n    }",
  vec3: "\n    if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3f(location, v[0], v[1], v[2])\n    }",
  vec4: "gl.uniform4f(location, v[0], v[1], v[2], v[3])",
  int: "gl.uniform1i(location, v)",
  ivec2: "gl.uniform2i(location, v[0], v[1])",
  ivec3: "gl.uniform3i(location, v[0], v[1], v[2])",
  ivec4: "gl.uniform4i(location, v[0], v[1], v[2], v[3])",
  bool: "gl.uniform1i(location, v)",
  bvec2: "gl.uniform2i(location, v[0], v[1])",
  bvec3: "gl.uniform3i(location, v[0], v[1], v[2])",
  bvec4: "gl.uniform4i(location, v[0], v[1], v[2], v[3])",
  mat2: "gl.uniformMatrix2fv(location, false, v)",
  mat3: "gl.uniformMatrix3fv(location, false, v)",
  mat4: "gl.uniformMatrix4fv(location, false, v)",
  sampler2D: "gl.uniform1i(location, v)",
  samplerCube: "gl.uniform1i(location, v)",
  sampler2DArray: "gl.uniform1i(location, v)"
};
var GLSL_TO_ARRAY_SETTERS2 = {
  float: "gl.uniform1fv(location, v)",
  vec2: "gl.uniform2fv(location, v)",
  vec3: "gl.uniform3fv(location, v)",
  vec4: "gl.uniform4fv(location, v)",
  mat4: "gl.uniformMatrix4fv(location, false, v)",
  mat3: "gl.uniformMatrix3fv(location, false, v)",
  mat2: "gl.uniformMatrix2fv(location, false, v)",
  int: "gl.uniform1iv(location, v)",
  ivec2: "gl.uniform2iv(location, v)",
  ivec3: "gl.uniform3iv(location, v)",
  ivec4: "gl.uniform4iv(location, v)",
  bool: "gl.uniform1iv(location, v)",
  bvec2: "gl.uniform2iv(location, v)",
  bvec3: "gl.uniform3iv(location, v)",
  bvec4: "gl.uniform4iv(location, v)",
  sampler2D: "gl.uniform1iv(location, v)",
  samplerCube: "gl.uniform1iv(location, v)",
  sampler2DArray: "gl.uniform1iv(location, v)"
};
function generateUniformsSync2(group, uniformData) {
  var funcFragments = ["\n        var v = null;\n        var cv = null\n        var t = 0;\n        var gl = renderer.gl\n    "];
  for (var i in group.uniforms) {
    var data = uniformData[i];
    if (!data) {
      if (group.uniforms[i].group) {
        funcFragments.push('\n                    renderer.shader.syncUniformGroup(uv["' + i + '"], syncData);\n                ');
      }
      continue;
    }
    var uniform = group.uniforms[i];
    var parsed = false;
    for (var j2 = 0; j2 < uniformParsers2.length; j2++) {
      if (uniformParsers2[j2].test(data, uniform)) {
        funcFragments.push(uniformParsers2[j2].code(i, uniform));
        parsed = true;
        break;
      }
    }
    if (!parsed) {
      var templateType = data.size === 1 ? GLSL_TO_SINGLE_SETTERS_CACHED2 : GLSL_TO_ARRAY_SETTERS2;
      var template = templateType[data.type].replace("location", 'ud["' + i + '"].location');
      funcFragments.push('\n            cv = ud["' + i + '"].value;\n            v = uv["' + i + '"];\n            ' + template + ";");
    }
  }
  return new Function("ud", "uv", "renderer", "syncData", funcFragments.join("\n"));
}
var fragTemplate2 = [
  "precision mediump float;",
  "void main(void){",
  "float test = 0.1;",
  "%forloop%",
  "gl_FragColor = vec4(0.0);",
  "}"
].join("\n");
function generateIfTestSrc2(maxIfs) {
  var src = "";
  for (var i = 0; i < maxIfs; ++i) {
    if (i > 0) {
      src += "\nelse ";
    }
    if (i < maxIfs - 1) {
      src += "if(test == " + i + ".0){}";
    }
  }
  return src;
}
function checkMaxIfStatementsInShader2(maxIfs, gl) {
  if (maxIfs === 0) {
    throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
  }
  var shader = gl.createShader(gl.FRAGMENT_SHADER);
  while (true) {
    var fragmentSrc = fragTemplate2.replace(/%forloop%/gi, generateIfTestSrc2(maxIfs));
    gl.shaderSource(shader, fragmentSrc);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      maxIfs = maxIfs / 2 | 0;
    } else {
      break;
    }
  }
  return maxIfs;
}
var unsafeEval2;
function unsafeEvalSupported2() {
  if (typeof unsafeEval2 === "boolean") {
    return unsafeEval2;
  }
  try {
    var func = new Function("param1", "param2", "param3", "return param1[param2] === param3;");
    unsafeEval2 = func({ a: "b" }, "a", "b") === true;
  } catch (e) {
    unsafeEval2 = false;
  }
  return unsafeEval2;
}
var defaultFragment2 = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor *= texture2D(uSampler, vTextureCoord);\n}";
var defaultVertex2 = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void){\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n   vTextureCoord = aTextureCoord;\n}\n";
var UID$32 = 0;
var nameCache2 = {};
var Program2 = (
  /** @class */
  function() {
    function Program3(vertexSrc, fragmentSrc, name) {
      if (name === void 0) {
        name = "pixi-shader";
      }
      this.id = UID$32++;
      this.vertexSrc = vertexSrc || Program3.defaultVertexSrc;
      this.fragmentSrc = fragmentSrc || Program3.defaultFragmentSrc;
      this.vertexSrc = this.vertexSrc.trim();
      this.fragmentSrc = this.fragmentSrc.trim();
      if (this.vertexSrc.substring(0, 8) !== "#version") {
        name = name.replace(/\s+/g, "-");
        if (nameCache2[name]) {
          nameCache2[name]++;
          name += "-" + nameCache2[name];
        } else {
          nameCache2[name] = 1;
        }
        this.vertexSrc = "#define SHADER_NAME " + name + "\n" + this.vertexSrc;
        this.fragmentSrc = "#define SHADER_NAME " + name + "\n" + this.fragmentSrc;
        this.vertexSrc = setPrecision2(this.vertexSrc, settings2.PRECISION_VERTEX, PRECISION2.HIGH);
        this.fragmentSrc = setPrecision2(this.fragmentSrc, settings2.PRECISION_FRAGMENT, getMaxFragmentPrecision2());
      }
      this.extractData(this.vertexSrc, this.fragmentSrc);
      this.glPrograms = {};
      this.syncUniforms = null;
    }
    Program3.prototype.extractData = function(vertexSrc, fragmentSrc) {
      var gl = getTestContext2();
      if (gl) {
        var program = compileProgram2(gl, vertexSrc, fragmentSrc);
        this.attributeData = this.getAttributeData(program, gl);
        this.uniformData = this.getUniformData(program, gl);
        gl.deleteProgram(program);
      } else {
        this.uniformData = {};
        this.attributeData = {};
      }
    };
    Program3.prototype.getAttributeData = function(program, gl) {
      var attributes = {};
      var attributesArray = [];
      var totalAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
      for (var i = 0; i < totalAttributes; i++) {
        var attribData = gl.getActiveAttrib(program, i);
        var type = mapType2(gl, attribData.type);
        var data = {
          type,
          name: attribData.name,
          size: mapSize2(type),
          location: 0
        };
        attributes[attribData.name] = data;
        attributesArray.push(data);
      }
      attributesArray.sort(function(a2, b2) {
        return a2.name > b2.name ? 1 : -1;
      });
      for (var i = 0; i < attributesArray.length; i++) {
        attributesArray[i].location = i;
      }
      return attributes;
    };
    Program3.prototype.getUniformData = function(program, gl) {
      var uniforms = {};
      var totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
      for (var i = 0; i < totalUniforms; i++) {
        var uniformData = gl.getActiveUniform(program, i);
        var name = uniformData.name.replace(/\[.*?\]$/, "");
        var isArray = uniformData.name.match(/\[.*?\]$/);
        var type = mapType2(gl, uniformData.type);
        uniforms[name] = {
          type,
          size: uniformData.size,
          isArray,
          value: defaultValue2(type, uniformData.size)
        };
      }
      return uniforms;
    };
    Object.defineProperty(Program3, "defaultVertexSrc", {
      /**
       * The default vertex shader source
       *
       * @static
       * @constant
       * @member {string}
       */
      get: function() {
        return defaultVertex2;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Program3, "defaultFragmentSrc", {
      /**
       * The default fragment shader source
       *
       * @static
       * @constant
       * @member {string}
       */
      get: function() {
        return defaultFragment2;
      },
      enumerable: false,
      configurable: true
    });
    Program3.from = function(vertexSrc, fragmentSrc, name) {
      var key = vertexSrc + fragmentSrc;
      var program = ProgramCache2[key];
      if (!program) {
        ProgramCache2[key] = program = new Program3(vertexSrc, fragmentSrc, name);
      }
      return program;
    };
    return Program3;
  }()
);
var Shader2 = (
  /** @class */
  function() {
    function Shader3(program, uniforms) {
      this.program = program;
      if (uniforms) {
        if (uniforms instanceof UniformGroup2) {
          this.uniformGroup = uniforms;
        } else {
          this.uniformGroup = new UniformGroup2(uniforms);
        }
      } else {
        this.uniformGroup = new UniformGroup2({});
      }
      for (var i in program.uniformData) {
        if (this.uniformGroup.uniforms[i] instanceof Array) {
          this.uniformGroup.uniforms[i] = new Float32Array(this.uniformGroup.uniforms[i]);
        }
      }
    }
    Shader3.prototype.checkUniformExists = function(name, group) {
      if (group.uniforms[name]) {
        return true;
      }
      for (var i in group.uniforms) {
        var uniform = group.uniforms[i];
        if (uniform.group) {
          if (this.checkUniformExists(name, uniform)) {
            return true;
          }
        }
      }
      return false;
    };
    Shader3.prototype.destroy = function() {
      this.uniformGroup = null;
    };
    Object.defineProperty(Shader3.prototype, "uniforms", {
      /**
       * Shader uniform values, shortcut for `uniformGroup.uniforms`
       * @readonly
       * @member {object}
       */
      get: function() {
        return this.uniformGroup.uniforms;
      },
      enumerable: false,
      configurable: true
    });
    Shader3.from = function(vertexSrc, fragmentSrc, uniforms) {
      var program = Program2.from(vertexSrc, fragmentSrc);
      return new Shader3(program, uniforms);
    };
    return Shader3;
  }()
);
var BLEND2 = 0;
var OFFSET2 = 1;
var CULLING2 = 2;
var DEPTH_TEST2 = 3;
var WINDING2 = 4;
var State2 = (
  /** @class */
  function() {
    function State3() {
      this.data = 0;
      this.blendMode = BLEND_MODES2.NORMAL;
      this.polygonOffset = 0;
      this.blend = true;
    }
    Object.defineProperty(State3.prototype, "blend", {
      /**
       * Activates blending of the computed fragment color values
       *
       * @member {boolean}
       */
      get: function() {
        return !!(this.data & 1 << BLEND2);
      },
      set: function(value) {
        if (!!(this.data & 1 << BLEND2) !== value) {
          this.data ^= 1 << BLEND2;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(State3.prototype, "offsets", {
      /**
       * Activates adding an offset to depth values of polygon's fragments
       *
       * @member {boolean}
       * @default false
       */
      get: function() {
        return !!(this.data & 1 << OFFSET2);
      },
      set: function(value) {
        if (!!(this.data & 1 << OFFSET2) !== value) {
          this.data ^= 1 << OFFSET2;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(State3.prototype, "culling", {
      /**
       * Activates culling of polygons.
       *
       * @member {boolean}
       * @default false
       */
      get: function() {
        return !!(this.data & 1 << CULLING2);
      },
      set: function(value) {
        if (!!(this.data & 1 << CULLING2) !== value) {
          this.data ^= 1 << CULLING2;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(State3.prototype, "depthTest", {
      /**
       * Activates depth comparisons and updates to the depth buffer.
       *
       * @member {boolean}
       * @default false
       */
      get: function() {
        return !!(this.data & 1 << DEPTH_TEST2);
      },
      set: function(value) {
        if (!!(this.data & 1 << DEPTH_TEST2) !== value) {
          this.data ^= 1 << DEPTH_TEST2;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(State3.prototype, "clockwiseFrontFace", {
      /**
       * Specifies whether or not front or back-facing polygons can be culled.
       * @member {boolean}
       * @default false
       */
      get: function() {
        return !!(this.data & 1 << WINDING2);
      },
      set: function(value) {
        if (!!(this.data & 1 << WINDING2) !== value) {
          this.data ^= 1 << WINDING2;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(State3.prototype, "blendMode", {
      /**
       * The blend mode to be applied when this state is set. Apply a value of `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.
       * Setting this mode to anything other than NO_BLEND will automatically switch blending on.
       *
       * @member {number}
       * @default PIXI.BLEND_MODES.NORMAL
       * @see PIXI.BLEND_MODES
       */
      get: function() {
        return this._blendMode;
      },
      set: function(value) {
        this.blend = value !== BLEND_MODES2.NONE;
        this._blendMode = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(State3.prototype, "polygonOffset", {
      /**
       * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.
       *
       * @member {number}
       * @default 0
       */
      get: function() {
        return this._polygonOffset;
      },
      set: function(value) {
        this.offsets = !!value;
        this._polygonOffset = value;
      },
      enumerable: false,
      configurable: true
    });
    State3.for2d = function() {
      var state = new State3();
      state.depthTest = false;
      state.blend = true;
      return state;
    };
    return State3;
  }()
);
var defaultVertex$12 = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n";
var defaultFragment$12 = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor = texture2D(uSampler, vTextureCoord);\n}\n";
var Filter2 = (
  /** @class */
  function(_super) {
    __extends3(Filter3, _super);
    function Filter3(vertexSrc, fragmentSrc, uniforms) {
      var _this = this;
      var program = Program2.from(vertexSrc || Filter3.defaultVertexSrc, fragmentSrc || Filter3.defaultFragmentSrc);
      _this = _super.call(this, program, uniforms) || this;
      _this.padding = 0;
      _this.resolution = settings2.FILTER_RESOLUTION;
      _this.enabled = true;
      _this.autoFit = true;
      _this.legacy = !!_this.program.attributeData.aTextureCoord;
      _this.state = new State2();
      return _this;
    }
    Filter3.prototype.apply = function(filterManager, input, output, clearMode, _currentState) {
      filterManager.applyFilter(this, input, output, clearMode);
    };
    Object.defineProperty(Filter3.prototype, "blendMode", {
      /**
       * Sets the blendmode of the filter
       *
       * @member {number}
       * @default PIXI.BLEND_MODES.NORMAL
       */
      get: function() {
        return this.state.blendMode;
      },
      set: function(value) {
        this.state.blendMode = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Filter3, "defaultVertexSrc", {
      /**
       * The default vertex shader source
       *
       * @static
       * @type {string}
       * @constant
       */
      get: function() {
        return defaultVertex$12;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Filter3, "defaultFragmentSrc", {
      /**
       * The default fragment shader source
       *
       * @static
       * @type {string}
       * @constant
       */
      get: function() {
        return defaultFragment$12;
      },
      enumerable: false,
      configurable: true
    });
    return Filter3;
  }(Shader2)
);
var vertex2 = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 otherMatrix;\n\nvarying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n}\n";
var fragment2 = "varying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform sampler2D mask;\nuniform float alpha;\nuniform float npmAlpha;\nuniform vec4 maskClamp;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(maskClamp.x, vMaskCoord.x) +\n        step(maskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, maskClamp.z) +\n        step(vMaskCoord.y, maskClamp.w));\n\n    vec4 original = texture2D(uSampler, vTextureCoord);\n    vec4 masky = texture2D(mask, vMaskCoord);\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\n\n    original *= (alphaMul * masky.r * alpha * clip);\n\n    gl_FragColor = original;\n}\n";
var tempMat2 = new Matrix2();
var TextureMatrix2 = (
  /** @class */
  function() {
    function TextureMatrix3(texture, clampMargin) {
      this._texture = texture;
      this.mapCoord = new Matrix2();
      this.uClampFrame = new Float32Array(4);
      this.uClampOffset = new Float32Array(2);
      this._textureID = -1;
      this._updateID = 0;
      this.clampOffset = 0;
      this.clampMargin = typeof clampMargin === "undefined" ? 0.5 : clampMargin;
      this.isSimple = false;
    }
    Object.defineProperty(TextureMatrix3.prototype, "texture", {
      /**
       * texture property
       * @member {PIXI.Texture}
       */
      get: function() {
        return this._texture;
      },
      set: function(value) {
        this._texture = value;
        this._textureID = -1;
      },
      enumerable: false,
      configurable: true
    });
    TextureMatrix3.prototype.multiplyUvs = function(uvs, out) {
      if (out === void 0) {
        out = uvs;
      }
      var mat = this.mapCoord;
      for (var i = 0; i < uvs.length; i += 2) {
        var x2 = uvs[i];
        var y2 = uvs[i + 1];
        out[i] = x2 * mat.a + y2 * mat.c + mat.tx;
        out[i + 1] = x2 * mat.b + y2 * mat.d + mat.ty;
      }
      return out;
    };
    TextureMatrix3.prototype.update = function(forceUpdate) {
      var tex = this._texture;
      if (!tex || !tex.valid) {
        return false;
      }
      if (!forceUpdate && this._textureID === tex._updateID) {
        return false;
      }
      this._textureID = tex._updateID;
      this._updateID++;
      var uvs = tex._uvs;
      this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);
      var orig = tex.orig;
      var trim = tex.trim;
      if (trim) {
        tempMat2.set(orig.width / trim.width, 0, 0, orig.height / trim.height, -trim.x / trim.width, -trim.y / trim.height);
        this.mapCoord.append(tempMat2);
      }
      var texBase = tex.baseTexture;
      var frame = this.uClampFrame;
      var margin = this.clampMargin / texBase.resolution;
      var offset = this.clampOffset;
      frame[0] = (tex._frame.x + margin + offset) / texBase.width;
      frame[1] = (tex._frame.y + margin + offset) / texBase.height;
      frame[2] = (tex._frame.x + tex._frame.width - margin + offset) / texBase.width;
      frame[3] = (tex._frame.y + tex._frame.height - margin + offset) / texBase.height;
      this.uClampOffset[0] = offset / texBase.realWidth;
      this.uClampOffset[1] = offset / texBase.realHeight;
      this.isSimple = tex._frame.width === texBase.width && tex._frame.height === texBase.height && tex.rotate === 0;
      return true;
    };
    return TextureMatrix3;
  }()
);
var SpriteMaskFilter2 = (
  /** @class */
  function(_super) {
    __extends3(SpriteMaskFilter3, _super);
    function SpriteMaskFilter3(sprite) {
      var _this = this;
      var maskMatrix = new Matrix2();
      _this = _super.call(this, vertex2, fragment2) || this;
      sprite.renderable = false;
      _this.maskSprite = sprite;
      _this.maskMatrix = maskMatrix;
      return _this;
    }
    SpriteMaskFilter3.prototype.apply = function(filterManager, input, output, clearMode) {
      var maskSprite = this.maskSprite;
      var tex = maskSprite._texture;
      if (!tex.valid) {
        return;
      }
      if (!tex.uvMatrix) {
        tex.uvMatrix = new TextureMatrix2(tex, 0);
      }
      tex.uvMatrix.update();
      this.uniforms.npmAlpha = tex.baseTexture.alphaMode ? 0 : 1;
      this.uniforms.mask = tex;
      this.uniforms.otherMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, maskSprite).prepend(tex.uvMatrix.mapCoord);
      this.uniforms.alpha = maskSprite.worldAlpha;
      this.uniforms.maskClamp = tex.uvMatrix.uClampFrame;
      filterManager.applyFilter(this, input, output, clearMode);
    };
    return SpriteMaskFilter3;
  }(Filter2)
);
var MaskSystem2 = (
  /** @class */
  function(_super) {
    __extends3(MaskSystem3, _super);
    function MaskSystem3(renderer) {
      var _this = _super.call(this, renderer) || this;
      _this.enableScissor = false;
      _this.alphaMaskPool = [];
      _this.maskDataPool = [];
      _this.maskStack = [];
      _this.alphaMaskIndex = 0;
      return _this;
    }
    MaskSystem3.prototype.setMaskStack = function(maskStack) {
      this.maskStack = maskStack;
      this.renderer.scissor.setMaskStack(maskStack);
      this.renderer.stencil.setMaskStack(maskStack);
    };
    MaskSystem3.prototype.push = function(target, maskDataOrTarget) {
      var maskData = maskDataOrTarget;
      if (!maskData.isMaskData) {
        var d2 = this.maskDataPool.pop() || new MaskData2();
        d2.pooled = true;
        d2.maskObject = maskDataOrTarget;
        maskData = d2;
      }
      if (maskData.autoDetect) {
        this.detect(maskData);
      }
      maskData.copyCountersOrReset(this.maskStack[this.maskStack.length - 1]);
      maskData._target = target;
      switch (maskData.type) {
        case MASK_TYPES2.SCISSOR:
          this.maskStack.push(maskData);
          this.renderer.scissor.push(maskData);
          break;
        case MASK_TYPES2.STENCIL:
          this.maskStack.push(maskData);
          this.renderer.stencil.push(maskData);
          break;
        case MASK_TYPES2.SPRITE:
          maskData.copyCountersOrReset(null);
          this.pushSpriteMask(maskData);
          this.maskStack.push(maskData);
          break;
        default:
          break;
      }
    };
    MaskSystem3.prototype.pop = function(target) {
      var maskData = this.maskStack.pop();
      if (!maskData || maskData._target !== target) {
        return;
      }
      switch (maskData.type) {
        case MASK_TYPES2.SCISSOR:
          this.renderer.scissor.pop();
          break;
        case MASK_TYPES2.STENCIL:
          this.renderer.stencil.pop(maskData.maskObject);
          break;
        case MASK_TYPES2.SPRITE:
          this.popSpriteMask();
          break;
        default:
          break;
      }
      maskData.reset();
      if (maskData.pooled) {
        this.maskDataPool.push(maskData);
      }
    };
    MaskSystem3.prototype.detect = function(maskData) {
      var maskObject = maskData.maskObject;
      if (maskObject.isSprite) {
        maskData.type = MASK_TYPES2.SPRITE;
        return;
      }
      maskData.type = MASK_TYPES2.STENCIL;
      if (this.enableScissor && maskObject.isFastRect && maskObject.isFastRect()) {
        var matrix = maskObject.worldTransform;
        var rotX = Math.atan2(matrix.b, matrix.a);
        var rotXY = Math.atan2(matrix.d, matrix.c);
        rotX = Math.round(rotX * (180 / Math.PI) * 100);
        rotXY = Math.round(rotXY * (180 / Math.PI) * 100) - rotX;
        rotX = (rotX % 9e3 + 9e3) % 9e3;
        rotXY = (rotXY % 18e3 + 18e3) % 18e3;
        if (rotX === 0 && rotXY === 9e3) {
          maskData.type = MASK_TYPES2.SCISSOR;
        }
      }
    };
    MaskSystem3.prototype.pushSpriteMask = function(maskData) {
      var maskObject = maskData.maskObject;
      var target = maskData._target;
      var alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex];
      if (!alphaMaskFilter) {
        alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex] = [new SpriteMaskFilter2(maskObject)];
      }
      alphaMaskFilter[0].resolution = this.renderer.resolution;
      alphaMaskFilter[0].maskSprite = maskObject;
      var stashFilterArea = target.filterArea;
      target.filterArea = maskObject.getBounds(true);
      this.renderer.filter.push(target, alphaMaskFilter);
      target.filterArea = stashFilterArea;
      this.alphaMaskIndex++;
    };
    MaskSystem3.prototype.popSpriteMask = function() {
      this.renderer.filter.pop();
      this.alphaMaskIndex--;
    };
    return MaskSystem3;
  }(System2)
);
var AbstractMaskSystem2 = (
  /** @class */
  function(_super) {
    __extends3(AbstractMaskSystem3, _super);
    function AbstractMaskSystem3(renderer) {
      var _this = _super.call(this, renderer) || this;
      _this.maskStack = [];
      _this.glConst = 0;
      return _this;
    }
    AbstractMaskSystem3.prototype.getStackLength = function() {
      return this.maskStack.length;
    };
    AbstractMaskSystem3.prototype.setMaskStack = function(maskStack) {
      var gl = this.renderer.gl;
      var curStackLen = this.getStackLength();
      this.maskStack = maskStack;
      var newStackLen = this.getStackLength();
      if (newStackLen !== curStackLen) {
        if (newStackLen === 0) {
          gl.disable(this.glConst);
        } else {
          gl.enable(this.glConst);
          this._useCurrent();
        }
      }
    };
    AbstractMaskSystem3.prototype._useCurrent = function() {
    };
    AbstractMaskSystem3.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      this.maskStack = null;
    };
    return AbstractMaskSystem3;
  }(System2)
);
var ScissorSystem2 = (
  /** @class */
  function(_super) {
    __extends3(ScissorSystem3, _super);
    function ScissorSystem3(renderer) {
      var _this = _super.call(this, renderer) || this;
      _this.glConst = WebGLRenderingContext.SCISSOR_TEST;
      return _this;
    }
    ScissorSystem3.prototype.getStackLength = function() {
      var maskData = this.maskStack[this.maskStack.length - 1];
      if (maskData) {
        return maskData._scissorCounter;
      }
      return 0;
    };
    ScissorSystem3.prototype.push = function(maskData) {
      var maskObject = maskData.maskObject;
      maskObject.renderable = true;
      var prevData = maskData._scissorRect;
      var bounds = maskObject.getBounds(true);
      var gl = this.renderer.gl;
      maskObject.renderable = false;
      if (prevData) {
        bounds.fit(prevData);
      } else {
        gl.enable(gl.SCISSOR_TEST);
      }
      maskData._scissorCounter++;
      maskData._scissorRect = bounds;
      this._useCurrent();
    };
    ScissorSystem3.prototype.pop = function() {
      var gl = this.renderer.gl;
      if (this.getStackLength() > 0) {
        this._useCurrent();
      } else {
        gl.disable(gl.SCISSOR_TEST);
      }
    };
    ScissorSystem3.prototype._useCurrent = function() {
      var rect = this.maskStack[this.maskStack.length - 1]._scissorRect;
      var rt = this.renderer.renderTexture.current;
      var _a = this.renderer.projection, transform = _a.transform, sourceFrame = _a.sourceFrame, destinationFrame = _a.destinationFrame;
      var resolution = rt ? rt.resolution : this.renderer.resolution;
      var x2 = (rect.x - sourceFrame.x) * resolution + destinationFrame.x;
      var y2 = (rect.y - sourceFrame.y) * resolution + destinationFrame.y;
      var width = rect.width * resolution;
      var height = rect.height * resolution;
      if (transform) {
        x2 += transform.tx * resolution;
        y2 += transform.ty * resolution;
      }
      if (!rt) {
        y2 = this.renderer.height - height - y2;
      }
      this.renderer.gl.scissor(x2, y2, width, height);
    };
    return ScissorSystem3;
  }(AbstractMaskSystem2)
);
var StencilSystem2 = (
  /** @class */
  function(_super) {
    __extends3(StencilSystem3, _super);
    function StencilSystem3(renderer) {
      var _this = _super.call(this, renderer) || this;
      _this.glConst = WebGLRenderingContext.STENCIL_TEST;
      return _this;
    }
    StencilSystem3.prototype.getStackLength = function() {
      var maskData = this.maskStack[this.maskStack.length - 1];
      if (maskData) {
        return maskData._stencilCounter;
      }
      return 0;
    };
    StencilSystem3.prototype.push = function(maskData) {
      var maskObject = maskData.maskObject;
      var gl = this.renderer.gl;
      var prevMaskCount = maskData._stencilCounter;
      if (prevMaskCount === 0) {
        this.renderer.framebuffer.forceStencil();
        gl.enable(gl.STENCIL_TEST);
      }
      maskData._stencilCounter++;
      gl.colorMask(false, false, false, false);
      gl.stencilFunc(gl.EQUAL, prevMaskCount, this._getBitwiseMask());
      gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);
      maskObject.renderable = true;
      maskObject.render(this.renderer);
      this.renderer.batch.flush();
      maskObject.renderable = false;
      this._useCurrent();
    };
    StencilSystem3.prototype.pop = function(maskObject) {
      var gl = this.renderer.gl;
      if (this.getStackLength() === 0) {
        gl.disable(gl.STENCIL_TEST);
        gl.clear(gl.STENCIL_BUFFER_BIT);
        gl.clearStencil(0);
      } else {
        gl.colorMask(false, false, false, false);
        gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR);
        maskObject.renderable = true;
        maskObject.render(this.renderer);
        this.renderer.batch.flush();
        maskObject.renderable = false;
        this._useCurrent();
      }
    };
    StencilSystem3.prototype._useCurrent = function() {
      var gl = this.renderer.gl;
      gl.colorMask(true, true, true, true);
      gl.stencilFunc(gl.EQUAL, this.getStackLength(), this._getBitwiseMask());
      gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
    };
    StencilSystem3.prototype._getBitwiseMask = function() {
      return (1 << this.getStackLength()) - 1;
    };
    return StencilSystem3;
  }(AbstractMaskSystem2)
);
var ProjectionSystem2 = (
  /** @class */
  function(_super) {
    __extends3(ProjectionSystem3, _super);
    function ProjectionSystem3(renderer) {
      var _this = _super.call(this, renderer) || this;
      _this.destinationFrame = null;
      _this.sourceFrame = null;
      _this.defaultFrame = null;
      _this.projectionMatrix = new Matrix2();
      _this.transform = null;
      return _this;
    }
    ProjectionSystem3.prototype.update = function(destinationFrame, sourceFrame, resolution, root) {
      this.destinationFrame = destinationFrame || this.destinationFrame || this.defaultFrame;
      this.sourceFrame = sourceFrame || this.sourceFrame || destinationFrame;
      this.calculateProjection(this.destinationFrame, this.sourceFrame, resolution, root);
      if (this.transform) {
        this.projectionMatrix.append(this.transform);
      }
      var renderer = this.renderer;
      renderer.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix;
      renderer.globalUniforms.update();
      if (renderer.shader.shader) {
        renderer.shader.syncUniformGroup(renderer.shader.shader.uniforms.globals);
      }
    };
    ProjectionSystem3.prototype.calculateProjection = function(_destinationFrame, sourceFrame, _resolution, root) {
      var pm = this.projectionMatrix;
      var sign = !root ? 1 : -1;
      pm.identity();
      pm.a = 1 / sourceFrame.width * 2;
      pm.d = sign * (1 / sourceFrame.height * 2);
      pm.tx = -1 - sourceFrame.x * pm.a;
      pm.ty = -sign - sourceFrame.y * pm.d;
    };
    ProjectionSystem3.prototype.setTransform = function(_matrix) {
    };
    return ProjectionSystem3;
  }(System2)
);
var tempRect3 = new Rectangle2();
var tempRect22 = new Rectangle2();
var viewportFrame2 = new Rectangle2();
var RenderTextureSystem2 = (
  /** @class */
  function(_super) {
    __extends3(RenderTextureSystem3, _super);
    function RenderTextureSystem3(renderer) {
      var _this = _super.call(this, renderer) || this;
      _this.clearColor = renderer._backgroundColorRgba;
      _this.defaultMaskStack = [];
      _this.current = null;
      _this.sourceFrame = new Rectangle2();
      _this.destinationFrame = new Rectangle2();
      return _this;
    }
    RenderTextureSystem3.prototype.bind = function(renderTexture, sourceFrame, destinationFrame) {
      if (renderTexture === void 0) {
        renderTexture = null;
      }
      var renderer = this.renderer;
      this.current = renderTexture;
      var baseTexture;
      var framebuffer;
      var resolution;
      if (renderTexture) {
        baseTexture = renderTexture.baseTexture;
        resolution = baseTexture.resolution;
        if (!sourceFrame) {
          tempRect3.width = renderTexture.frame.width;
          tempRect3.height = renderTexture.frame.height;
          sourceFrame = tempRect3;
        }
        if (!destinationFrame) {
          tempRect22.x = renderTexture.frame.x;
          tempRect22.y = renderTexture.frame.y;
          tempRect22.width = sourceFrame.width;
          tempRect22.height = sourceFrame.height;
          destinationFrame = tempRect22;
        }
        framebuffer = baseTexture.framebuffer;
      } else {
        resolution = renderer.resolution;
        if (!sourceFrame) {
          tempRect3.width = renderer.screen.width;
          tempRect3.height = renderer.screen.height;
          sourceFrame = tempRect3;
        }
        if (!destinationFrame) {
          destinationFrame = tempRect3;
          destinationFrame.width = sourceFrame.width;
          destinationFrame.height = sourceFrame.height;
        }
      }
      viewportFrame2.x = destinationFrame.x * resolution;
      viewportFrame2.y = destinationFrame.y * resolution;
      viewportFrame2.width = destinationFrame.width * resolution;
      viewportFrame2.height = destinationFrame.height * resolution;
      this.renderer.framebuffer.bind(framebuffer, viewportFrame2);
      this.renderer.projection.update(destinationFrame, sourceFrame, resolution, !framebuffer);
      if (renderTexture) {
        this.renderer.mask.setMaskStack(baseTexture.maskStack);
      } else {
        this.renderer.mask.setMaskStack(this.defaultMaskStack);
      }
      this.sourceFrame.copyFrom(sourceFrame);
      this.destinationFrame.copyFrom(destinationFrame);
    };
    RenderTextureSystem3.prototype.clear = function(clearColor, mask) {
      if (this.current) {
        clearColor = clearColor || this.current.baseTexture.clearColor;
      } else {
        clearColor = clearColor || this.clearColor;
      }
      this.renderer.framebuffer.clear(clearColor[0], clearColor[1], clearColor[2], clearColor[3], mask);
    };
    RenderTextureSystem3.prototype.resize = function() {
      this.bind(null);
    };
    RenderTextureSystem3.prototype.reset = function() {
      this.bind(null);
    };
    return RenderTextureSystem3;
  }(System2)
);
var GLProgram2 = (
  /** @class */
  function() {
    function GLProgram3(program, uniformData) {
      this.program = program;
      this.uniformData = uniformData;
      this.uniformGroups = {};
    }
    GLProgram3.prototype.destroy = function() {
      this.uniformData = null;
      this.uniformGroups = null;
      this.program = null;
    };
    return GLProgram3;
  }()
);
var UID$42 = 0;
var defaultSyncData2 = { textureCount: 0 };
var ShaderSystem2 = (
  /** @class */
  function(_super) {
    __extends3(ShaderSystem3, _super);
    function ShaderSystem3(renderer) {
      var _this = _super.call(this, renderer) || this;
      _this.destroyed = false;
      _this.systemCheck();
      _this.gl = null;
      _this.shader = null;
      _this.program = null;
      _this.cache = {};
      _this.id = UID$42++;
      return _this;
    }
    ShaderSystem3.prototype.systemCheck = function() {
      if (!unsafeEvalSupported2()) {
        throw new Error("Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.");
      }
    };
    ShaderSystem3.prototype.contextChange = function(gl) {
      this.gl = gl;
      this.reset();
    };
    ShaderSystem3.prototype.bind = function(shader, dontSync) {
      shader.uniforms.globals = this.renderer.globalUniforms;
      var program = shader.program;
      var glProgram = program.glPrograms[this.renderer.CONTEXT_UID] || this.generateShader(shader);
      this.shader = shader;
      if (this.program !== program) {
        this.program = program;
        this.gl.useProgram(glProgram.program);
      }
      if (!dontSync) {
        defaultSyncData2.textureCount = 0;
        this.syncUniformGroup(shader.uniformGroup, defaultSyncData2);
      }
      return glProgram;
    };
    ShaderSystem3.prototype.setUniforms = function(uniforms) {
      var shader = this.shader.program;
      var glProgram = shader.glPrograms[this.renderer.CONTEXT_UID];
      shader.syncUniforms(glProgram.uniformData, uniforms, this.renderer);
    };
    ShaderSystem3.prototype.syncUniformGroup = function(group, syncData) {
      var glProgram = this.getglProgram();
      if (!group.static || group.dirtyId !== glProgram.uniformGroups[group.id]) {
        glProgram.uniformGroups[group.id] = group.dirtyId;
        this.syncUniforms(group, glProgram, syncData);
      }
    };
    ShaderSystem3.prototype.syncUniforms = function(group, glProgram, syncData) {
      var syncFunc = group.syncUniforms[this.shader.program.id] || this.createSyncGroups(group);
      syncFunc(glProgram.uniformData, group.uniforms, this.renderer, syncData);
    };
    ShaderSystem3.prototype.createSyncGroups = function(group) {
      var id = this.getSignature(group, this.shader.program.uniformData);
      if (!this.cache[id]) {
        this.cache[id] = generateUniformsSync2(group, this.shader.program.uniformData);
      }
      group.syncUniforms[this.shader.program.id] = this.cache[id];
      return group.syncUniforms[this.shader.program.id];
    };
    ShaderSystem3.prototype.getSignature = function(group, uniformData) {
      var uniforms = group.uniforms;
      var strings = [];
      for (var i in uniforms) {
        strings.push(i);
        if (uniformData[i]) {
          strings.push(uniformData[i].type);
        }
      }
      return strings.join("-");
    };
    ShaderSystem3.prototype.getglProgram = function() {
      if (this.shader) {
        return this.shader.program.glPrograms[this.renderer.CONTEXT_UID];
      }
      return null;
    };
    ShaderSystem3.prototype.generateShader = function(shader) {
      var gl = this.gl;
      var program = shader.program;
      var attribMap = {};
      for (var i in program.attributeData) {
        attribMap[i] = program.attributeData[i].location;
      }
      var shaderProgram = compileProgram2(gl, program.vertexSrc, program.fragmentSrc, attribMap);
      var uniformData = {};
      for (var i in program.uniformData) {
        var data = program.uniformData[i];
        uniformData[i] = {
          location: gl.getUniformLocation(shaderProgram, i),
          value: defaultValue2(data.type, data.size)
        };
      }
      var glProgram = new GLProgram2(shaderProgram, uniformData);
      program.glPrograms[this.renderer.CONTEXT_UID] = glProgram;
      return glProgram;
    };
    ShaderSystem3.prototype.reset = function() {
      this.program = null;
      this.shader = null;
    };
    ShaderSystem3.prototype.destroy = function() {
      this.destroyed = true;
    };
    return ShaderSystem3;
  }(System2)
);
function mapWebGLBlendModesToPixi2(gl, array) {
  if (array === void 0) {
    array = [];
  }
  array[BLEND_MODES2.NORMAL] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES2.ADD] = [gl.ONE, gl.ONE];
  array[BLEND_MODES2.MULTIPLY] = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES2.SCREEN] = [gl.ONE, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES2.OVERLAY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES2.DARKEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES2.LIGHTEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES2.COLOR_DODGE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES2.COLOR_BURN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES2.HARD_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES2.SOFT_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES2.DIFFERENCE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES2.EXCLUSION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES2.HUE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES2.SATURATION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES2.COLOR] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES2.LUMINOSITY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES2.NONE] = [0, 0];
  array[BLEND_MODES2.NORMAL_NPM] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES2.ADD_NPM] = [gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE];
  array[BLEND_MODES2.SCREEN_NPM] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES2.SRC_IN] = [gl.DST_ALPHA, gl.ZERO];
  array[BLEND_MODES2.SRC_OUT] = [gl.ONE_MINUS_DST_ALPHA, gl.ZERO];
  array[BLEND_MODES2.SRC_ATOP] = [gl.DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES2.DST_OVER] = [gl.ONE_MINUS_DST_ALPHA, gl.ONE];
  array[BLEND_MODES2.DST_IN] = [gl.ZERO, gl.SRC_ALPHA];
  array[BLEND_MODES2.DST_OUT] = [gl.ZERO, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES2.DST_ATOP] = [gl.ONE_MINUS_DST_ALPHA, gl.SRC_ALPHA];
  array[BLEND_MODES2.XOR] = [gl.ONE_MINUS_DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES2.SUBTRACT] = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, gl.FUNC_REVERSE_SUBTRACT, gl.FUNC_ADD];
  return array;
}
var BLEND$12 = 0;
var OFFSET$12 = 1;
var CULLING$12 = 2;
var DEPTH_TEST$12 = 3;
var WINDING$12 = 4;
var StateSystem2 = (
  /** @class */
  function(_super) {
    __extends3(StateSystem3, _super);
    function StateSystem3(renderer) {
      var _this = _super.call(this, renderer) || this;
      _this.gl = null;
      _this.stateId = 0;
      _this.polygonOffset = 0;
      _this.blendMode = BLEND_MODES2.NONE;
      _this._blendEq = false;
      _this.map = [];
      _this.map[BLEND$12] = _this.setBlend;
      _this.map[OFFSET$12] = _this.setOffset;
      _this.map[CULLING$12] = _this.setCullFace;
      _this.map[DEPTH_TEST$12] = _this.setDepthTest;
      _this.map[WINDING$12] = _this.setFrontFace;
      _this.checks = [];
      _this.defaultState = new State2();
      _this.defaultState.blend = true;
      return _this;
    }
    StateSystem3.prototype.contextChange = function(gl) {
      this.gl = gl;
      this.blendModes = mapWebGLBlendModesToPixi2(gl);
      this.set(this.defaultState);
      this.reset();
    };
    StateSystem3.prototype.set = function(state) {
      state = state || this.defaultState;
      if (this.stateId !== state.data) {
        var diff = this.stateId ^ state.data;
        var i = 0;
        while (diff) {
          if (diff & 1) {
            this.map[i].call(this, !!(state.data & 1 << i));
          }
          diff = diff >> 1;
          i++;
        }
        this.stateId = state.data;
      }
      for (var i = 0; i < this.checks.length; i++) {
        this.checks[i](this, state);
      }
    };
    StateSystem3.prototype.forceState = function(state) {
      state = state || this.defaultState;
      for (var i = 0; i < this.map.length; i++) {
        this.map[i].call(this, !!(state.data & 1 << i));
      }
      for (var i = 0; i < this.checks.length; i++) {
        this.checks[i](this, state);
      }
      this.stateId = state.data;
    };
    StateSystem3.prototype.setBlend = function(value) {
      this.updateCheck(StateSystem3.checkBlendMode, value);
      this.gl[value ? "enable" : "disable"](this.gl.BLEND);
    };
    StateSystem3.prototype.setOffset = function(value) {
      this.updateCheck(StateSystem3.checkPolygonOffset, value);
      this.gl[value ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL);
    };
    StateSystem3.prototype.setDepthTest = function(value) {
      this.gl[value ? "enable" : "disable"](this.gl.DEPTH_TEST);
    };
    StateSystem3.prototype.setCullFace = function(value) {
      this.gl[value ? "enable" : "disable"](this.gl.CULL_FACE);
    };
    StateSystem3.prototype.setFrontFace = function(value) {
      this.gl.frontFace(this.gl[value ? "CW" : "CCW"]);
    };
    StateSystem3.prototype.setBlendMode = function(value) {
      if (value === this.blendMode) {
        return;
      }
      this.blendMode = value;
      var mode = this.blendModes[value];
      var gl = this.gl;
      if (mode.length === 2) {
        gl.blendFunc(mode[0], mode[1]);
      } else {
        gl.blendFuncSeparate(mode[0], mode[1], mode[2], mode[3]);
      }
      if (mode.length === 6) {
        this._blendEq = true;
        gl.blendEquationSeparate(mode[4], mode[5]);
      } else if (this._blendEq) {
        this._blendEq = false;
        gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
      }
    };
    StateSystem3.prototype.setPolygonOffset = function(value, scale) {
      this.gl.polygonOffset(value, scale);
    };
    StateSystem3.prototype.reset = function() {
      this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false);
      this.forceState(this.defaultState);
      this._blendEq = true;
      this.blendMode = -1;
      this.setBlendMode(0);
    };
    StateSystem3.prototype.updateCheck = function(func, value) {
      var index2 = this.checks.indexOf(func);
      if (value && index2 === -1) {
        this.checks.push(func);
      } else if (!value && index2 !== -1) {
        this.checks.splice(index2, 1);
      }
    };
    StateSystem3.checkBlendMode = function(system, state) {
      system.setBlendMode(state.blendMode);
    };
    StateSystem3.checkPolygonOffset = function(system, state) {
      system.setPolygonOffset(1, state.polygonOffset);
    };
    return StateSystem3;
  }(System2)
);
var TextureGCSystem2 = (
  /** @class */
  function(_super) {
    __extends3(TextureGCSystem3, _super);
    function TextureGCSystem3(renderer) {
      var _this = _super.call(this, renderer) || this;
      _this.count = 0;
      _this.checkCount = 0;
      _this.maxIdle = settings2.GC_MAX_IDLE;
      _this.checkCountMax = settings2.GC_MAX_CHECK_COUNT;
      _this.mode = settings2.GC_MODE;
      return _this;
    }
    TextureGCSystem3.prototype.postrender = function() {
      if (!this.renderer.renderingToScreen) {
        return;
      }
      this.count++;
      if (this.mode === GC_MODES2.MANUAL) {
        return;
      }
      this.checkCount++;
      if (this.checkCount > this.checkCountMax) {
        this.checkCount = 0;
        this.run();
      }
    };
    TextureGCSystem3.prototype.run = function() {
      var tm = this.renderer.texture;
      var managedTextures = tm.managedTextures;
      var wasRemoved = false;
      for (var i = 0; i < managedTextures.length; i++) {
        var texture = managedTextures[i];
        if (!texture.framebuffer && this.count - texture.touched > this.maxIdle) {
          tm.destroyTexture(texture, true);
          managedTextures[i] = null;
          wasRemoved = true;
        }
      }
      if (wasRemoved) {
        var j2 = 0;
        for (var i = 0; i < managedTextures.length; i++) {
          if (managedTextures[i] !== null) {
            managedTextures[j2++] = managedTextures[i];
          }
        }
        managedTextures.length = j2;
      }
    };
    TextureGCSystem3.prototype.unload = function(displayObject) {
      var tm = this.renderer.texture;
      var texture = displayObject._texture;
      if (texture && !texture.framebuffer) {
        tm.destroyTexture(texture);
      }
      for (var i = displayObject.children.length - 1; i >= 0; i--) {
        this.unload(displayObject.children[i]);
      }
    };
    return TextureGCSystem3;
  }(System2)
);
var GLTexture2 = (
  /** @class */
  /* @__PURE__ */ function() {
    function GLTexture3(texture) {
      this.texture = texture;
      this.width = -1;
      this.height = -1;
      this.dirtyId = -1;
      this.dirtyStyleId = -1;
      this.mipmap = false;
      this.wrapMode = 33071;
      this.type = 6408;
      this.internalFormat = 5121;
    }
    return GLTexture3;
  }()
);
var TextureSystem2 = (
  /** @class */
  function(_super) {
    __extends3(TextureSystem3, _super);
    function TextureSystem3(renderer) {
      var _this = _super.call(this, renderer) || this;
      _this.boundTextures = [];
      _this.currentLocation = -1;
      _this.managedTextures = [];
      _this._unknownBoundTextures = false;
      _this.unknownTexture = new BaseTexture2();
      return _this;
    }
    TextureSystem3.prototype.contextChange = function() {
      var gl = this.gl = this.renderer.gl;
      this.CONTEXT_UID = this.renderer.CONTEXT_UID;
      this.webGLVersion = this.renderer.context.webGLVersion;
      var maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
      this.boundTextures.length = maxTextures;
      for (var i = 0; i < maxTextures; i++) {
        this.boundTextures[i] = null;
      }
      this.emptyTextures = {};
      var emptyTexture2D = new GLTexture2(gl.createTexture());
      gl.bindTexture(gl.TEXTURE_2D, emptyTexture2D.texture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(4));
      this.emptyTextures[gl.TEXTURE_2D] = emptyTexture2D;
      this.emptyTextures[gl.TEXTURE_CUBE_MAP] = new GLTexture2(gl.createTexture());
      gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.emptyTextures[gl.TEXTURE_CUBE_MAP].texture);
      for (var i = 0; i < 6; i++) {
        gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
      }
      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      for (var i = 0; i < this.boundTextures.length; i++) {
        this.bind(null, i);
      }
    };
    TextureSystem3.prototype.bind = function(texture, location) {
      if (location === void 0) {
        location = 0;
      }
      var gl = this.gl;
      if (texture) {
        texture = texture.castToBaseTexture();
        if (texture.parentTextureArray) {
          return;
        }
        if (texture.valid) {
          texture.touched = this.renderer.textureGC.count;
          var glTexture = texture._glTextures[this.CONTEXT_UID] || this.initTexture(texture);
          if (this.boundTextures[location] !== texture) {
            if (this.currentLocation !== location) {
              this.currentLocation = location;
              gl.activeTexture(gl.TEXTURE0 + location);
            }
            gl.bindTexture(texture.target, glTexture.texture);
          }
          if (glTexture.dirtyId !== texture.dirtyId) {
            if (this.currentLocation !== location) {
              this.currentLocation = location;
              gl.activeTexture(gl.TEXTURE0 + location);
            }
            this.updateTexture(texture);
          }
          this.boundTextures[location] = texture;
        }
      } else {
        if (this.currentLocation !== location) {
          this.currentLocation = location;
          gl.activeTexture(gl.TEXTURE0 + location);
        }
        gl.bindTexture(gl.TEXTURE_2D, this.emptyTextures[gl.TEXTURE_2D].texture);
        this.boundTextures[location] = null;
      }
    };
    TextureSystem3.prototype.reset = function() {
      this._unknownBoundTextures = true;
      this.currentLocation = -1;
      for (var i = 0; i < this.boundTextures.length; i++) {
        this.boundTextures[i] = this.unknownTexture;
      }
    };
    TextureSystem3.prototype.unbind = function(texture) {
      var _a = this, gl = _a.gl, boundTextures = _a.boundTextures;
      if (this._unknownBoundTextures) {
        this._unknownBoundTextures = false;
        for (var i = 0; i < boundTextures.length; i++) {
          if (boundTextures[i] === this.unknownTexture) {
            this.bind(null, i);
          }
        }
      }
      for (var i = 0; i < boundTextures.length; i++) {
        if (boundTextures[i] === texture) {
          if (this.currentLocation !== i) {
            gl.activeTexture(gl.TEXTURE0 + i);
            this.currentLocation = i;
          }
          gl.bindTexture(texture.target, this.emptyTextures[texture.target].texture);
          boundTextures[i] = null;
        }
      }
    };
    TextureSystem3.prototype.initTexture = function(texture) {
      var glTexture = new GLTexture2(this.gl.createTexture());
      glTexture.dirtyId = -1;
      texture._glTextures[this.CONTEXT_UID] = glTexture;
      this.managedTextures.push(texture);
      texture.on("dispose", this.destroyTexture, this);
      return glTexture;
    };
    TextureSystem3.prototype.initTextureType = function(texture, glTexture) {
      glTexture.internalFormat = texture.format;
      glTexture.type = texture.type;
      if (this.webGLVersion !== 2) {
        return;
      }
      var gl = this.renderer.gl;
      if (texture.type === gl.FLOAT && texture.format === gl.RGBA) {
        glTexture.internalFormat = gl.RGBA32F;
      }
      if (texture.type === TYPES2.HALF_FLOAT) {
        glTexture.type = gl.HALF_FLOAT;
      }
      if (glTexture.type === gl.HALF_FLOAT && texture.format === gl.RGBA) {
        glTexture.internalFormat = gl.RGBA16F;
      }
    };
    TextureSystem3.prototype.updateTexture = function(texture) {
      var glTexture = texture._glTextures[this.CONTEXT_UID];
      if (!glTexture) {
        return;
      }
      var renderer = this.renderer;
      this.initTextureType(texture, glTexture);
      if (texture.resource && texture.resource.upload(renderer, texture, glTexture)) ;
      else {
        var width = texture.realWidth;
        var height = texture.realHeight;
        var gl = renderer.gl;
        if (glTexture.width !== width || glTexture.height !== height || glTexture.dirtyId < 0) {
          glTexture.width = width;
          glTexture.height = height;
          gl.texImage2D(texture.target, 0, glTexture.internalFormat, width, height, 0, texture.format, glTexture.type, null);
        }
      }
      if (texture.dirtyStyleId !== glTexture.dirtyStyleId) {
        this.updateTextureStyle(texture);
      }
      glTexture.dirtyId = texture.dirtyId;
    };
    TextureSystem3.prototype.destroyTexture = function(texture, skipRemove) {
      var gl = this.gl;
      texture = texture.castToBaseTexture();
      if (texture._glTextures[this.CONTEXT_UID]) {
        this.unbind(texture);
        gl.deleteTexture(texture._glTextures[this.CONTEXT_UID].texture);
        texture.off("dispose", this.destroyTexture, this);
        delete texture._glTextures[this.CONTEXT_UID];
        if (!skipRemove) {
          var i = this.managedTextures.indexOf(texture);
          if (i !== -1) {
            removeItems2(this.managedTextures, i, 1);
          }
        }
      }
    };
    TextureSystem3.prototype.updateTextureStyle = function(texture) {
      var glTexture = texture._glTextures[this.CONTEXT_UID];
      if (!glTexture) {
        return;
      }
      if ((texture.mipmap === MIPMAP_MODES2.POW2 || this.webGLVersion !== 2) && !texture.isPowerOfTwo) {
        glTexture.mipmap = false;
      } else {
        glTexture.mipmap = texture.mipmap >= 1;
      }
      if (this.webGLVersion !== 2 && !texture.isPowerOfTwo) {
        glTexture.wrapMode = WRAP_MODES2.CLAMP;
      } else {
        glTexture.wrapMode = texture.wrapMode;
      }
      if (texture.resource && texture.resource.style(this.renderer, texture, glTexture)) ;
      else {
        this.setStyle(texture, glTexture);
      }
      glTexture.dirtyStyleId = texture.dirtyStyleId;
    };
    TextureSystem3.prototype.setStyle = function(texture, glTexture) {
      var gl = this.gl;
      if (glTexture.mipmap) {
        gl.generateMipmap(texture.target);
      }
      gl.texParameteri(texture.target, gl.TEXTURE_WRAP_S, glTexture.wrapMode);
      gl.texParameteri(texture.target, gl.TEXTURE_WRAP_T, glTexture.wrapMode);
      if (glTexture.mipmap) {
        gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode === SCALE_MODES2.LINEAR ? gl.LINEAR_MIPMAP_LINEAR : gl.NEAREST_MIPMAP_NEAREST);
        var anisotropicExt = this.renderer.context.extensions.anisotropicFiltering;
        if (anisotropicExt && texture.anisotropicLevel > 0 && texture.scaleMode === SCALE_MODES2.LINEAR) {
          var level = Math.min(texture.anisotropicLevel, gl.getParameter(anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
          gl.texParameterf(texture.target, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, level);
        }
      } else {
        gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode === SCALE_MODES2.LINEAR ? gl.LINEAR : gl.NEAREST);
      }
      gl.texParameteri(texture.target, gl.TEXTURE_MAG_FILTER, texture.scaleMode === SCALE_MODES2.LINEAR ? gl.LINEAR : gl.NEAREST);
    };
    return TextureSystem3;
  }(System2)
);
var tempMatrix2 = new Matrix2();
var AbstractRenderer2 = (
  /** @class */
  function(_super) {
    __extends3(AbstractRenderer3, _super);
    function AbstractRenderer3(type, options) {
      if (type === void 0) {
        type = RENDERER_TYPE2.UNKNOWN;
      }
      var _this = _super.call(this) || this;
      options = Object.assign({}, settings2.RENDER_OPTIONS, options);
      if (options.roundPixels) {
        settings2.ROUND_PIXELS = options.roundPixels;
        deprecation2("5.0.0", "Renderer roundPixels option is deprecated, please use PIXI.settings.ROUND_PIXELS", 2);
      }
      _this.options = options;
      _this.type = type;
      _this.screen = new Rectangle2(0, 0, options.width, options.height);
      _this.view = options.view || document.createElement("canvas");
      _this.resolution = options.resolution || settings2.RESOLUTION;
      _this.transparent = options.transparent;
      _this.autoDensity = options.autoDensity || options.autoResize || false;
      _this.preserveDrawingBuffer = options.preserveDrawingBuffer;
      _this.clearBeforeRender = options.clearBeforeRender;
      _this._backgroundColor = 0;
      _this._backgroundColorRgba = [0, 0, 0, 0];
      _this._backgroundColorString = "#000000";
      _this.backgroundColor = options.backgroundColor || _this._backgroundColor;
      _this._lastObjectRendered = null;
      _this.plugins = {};
      return _this;
    }
    AbstractRenderer3.prototype.initPlugins = function(staticMap) {
      for (var o in staticMap) {
        this.plugins[o] = new staticMap[o](this);
      }
    };
    Object.defineProperty(AbstractRenderer3.prototype, "width", {
      /**
       * Same as view.width, actual number of pixels in the canvas by horizontal.
       *
       * @member {number}
       * @readonly
       * @default 800
       */
      get: function() {
        return this.view.width;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(AbstractRenderer3.prototype, "height", {
      /**
       * Same as view.height, actual number of pixels in the canvas by vertical.
       *
       * @member {number}
       * @readonly
       * @default 600
       */
      get: function() {
        return this.view.height;
      },
      enumerable: false,
      configurable: true
    });
    AbstractRenderer3.prototype.resize = function(screenWidth, screenHeight) {
      this.screen.width = screenWidth;
      this.screen.height = screenHeight;
      this.view.width = screenWidth * this.resolution;
      this.view.height = screenHeight * this.resolution;
      if (this.autoDensity) {
        this.view.style.width = screenWidth + "px";
        this.view.style.height = screenHeight + "px";
      }
      this.emit("resize", screenWidth, screenHeight);
    };
    AbstractRenderer3.prototype.generateTexture = function(displayObject, scaleMode, resolution, region) {
      region = region || displayObject.getLocalBounds(null, true);
      if (region.width === 0) {
        region.width = 1;
      }
      if (region.height === 0) {
        region.height = 1;
      }
      var renderTexture = RenderTexture2.create({
        width: region.width | 0,
        height: region.height | 0,
        scaleMode,
        resolution
      });
      tempMatrix2.tx = -region.x;
      tempMatrix2.ty = -region.y;
      this.render(displayObject, renderTexture, false, tempMatrix2, !!displayObject.parent);
      return renderTexture;
    };
    AbstractRenderer3.prototype.destroy = function(removeView) {
      for (var o in this.plugins) {
        this.plugins[o].destroy();
        this.plugins[o] = null;
      }
      if (removeView && this.view.parentNode) {
        this.view.parentNode.removeChild(this.view);
      }
      var thisAny = this;
      thisAny.plugins = null;
      thisAny.type = RENDERER_TYPE2.UNKNOWN;
      thisAny.view = null;
      thisAny.screen = null;
      thisAny._tempDisplayObjectParent = null;
      thisAny.options = null;
      this._backgroundColorRgba = null;
      this._backgroundColorString = null;
      this._lastObjectRendered = null;
    };
    Object.defineProperty(AbstractRenderer3.prototype, "backgroundColor", {
      /**
       * The background color to fill if not transparent
       *
       * @member {number}
       */
      get: function() {
        return this._backgroundColor;
      },
      set: function(value) {
        this._backgroundColor = value;
        this._backgroundColorString = hex2string2(value);
        hex2rgb2(value, this._backgroundColorRgba);
      },
      enumerable: false,
      configurable: true
    });
    return AbstractRenderer3;
  }(import_eventemitter32.default)
);
var Renderer2 = (
  /** @class */
  function(_super) {
    __extends3(Renderer3, _super);
    function Renderer3(options) {
      var _this = _super.call(this, RENDERER_TYPE2.WEBGL, options) || this;
      options = _this.options;
      _this.gl = null;
      _this.CONTEXT_UID = 0;
      _this.runners = {
        destroy: new Runner2("destroy"),
        contextChange: new Runner2("contextChange"),
        reset: new Runner2("reset"),
        update: new Runner2("update"),
        postrender: new Runner2("postrender"),
        prerender: new Runner2("prerender"),
        resize: new Runner2("resize")
      };
      _this.globalUniforms = new UniformGroup2({
        projectionMatrix: new Matrix2()
      }, true);
      _this.addSystem(MaskSystem2, "mask").addSystem(ContextSystem2, "context").addSystem(StateSystem2, "state").addSystem(ShaderSystem2, "shader").addSystem(TextureSystem2, "texture").addSystem(GeometrySystem2, "geometry").addSystem(FramebufferSystem2, "framebuffer").addSystem(ScissorSystem2, "scissor").addSystem(StencilSystem2, "stencil").addSystem(ProjectionSystem2, "projection").addSystem(TextureGCSystem2, "textureGC").addSystem(FilterSystem2, "filter").addSystem(RenderTextureSystem2, "renderTexture").addSystem(BatchSystem2, "batch");
      _this.initPlugins(Renderer3.__plugins);
      if (options.context) {
        _this.context.initFromContext(options.context);
      } else {
        _this.context.initFromOptions({
          alpha: !!_this.transparent,
          antialias: options.antialias,
          premultipliedAlpha: _this.transparent && _this.transparent !== "notMultiplied",
          stencil: true,
          preserveDrawingBuffer: options.preserveDrawingBuffer,
          powerPreference: _this.options.powerPreference
        });
      }
      _this.renderingToScreen = true;
      sayHello2(_this.context.webGLVersion === 2 ? "WebGL 2" : "WebGL 1");
      _this.resize(_this.options.width, _this.options.height);
      return _this;
    }
    Renderer3.create = function(options) {
      if (isWebGLSupported2()) {
        return new Renderer3(options);
      }
      throw new Error('WebGL unsupported in this browser, use "pixi.js-legacy" for fallback canvas2d support.');
    };
    Renderer3.prototype.addSystem = function(ClassRef, name) {
      if (!name) {
        name = ClassRef.name;
      }
      var system = new ClassRef(this);
      if (this[name]) {
        throw new Error('Whoops! The name "' + name + '" is already in use');
      }
      this[name] = system;
      for (var i in this.runners) {
        this.runners[i].add(system);
      }
      return this;
    };
    Renderer3.prototype.render = function(displayObject, renderTexture, clear, transform, skipUpdateTransform) {
      this.renderingToScreen = !renderTexture;
      this.runners.prerender.emit();
      this.emit("prerender");
      this.projection.transform = transform;
      if (this.context.isLost) {
        return;
      }
      if (!renderTexture) {
        this._lastObjectRendered = displayObject;
      }
      if (!skipUpdateTransform) {
        var cacheParent = displayObject.enableTempParent();
        displayObject.updateTransform();
        displayObject.disableTempParent(cacheParent);
      }
      this.renderTexture.bind(renderTexture);
      this.batch.currentRenderer.start();
      if (clear !== void 0 ? clear : this.clearBeforeRender) {
        this.renderTexture.clear();
      }
      displayObject.render(this);
      this.batch.currentRenderer.flush();
      if (renderTexture) {
        renderTexture.baseTexture.update();
      }
      this.runners.postrender.emit();
      this.projection.transform = null;
      this.emit("postrender");
    };
    Renderer3.prototype.resize = function(screenWidth, screenHeight) {
      _super.prototype.resize.call(this, screenWidth, screenHeight);
      this.runners.resize.emit(screenWidth, screenHeight);
    };
    Renderer3.prototype.reset = function() {
      this.runners.reset.emit();
      return this;
    };
    Renderer3.prototype.clear = function() {
      this.renderTexture.bind();
      this.renderTexture.clear();
    };
    Renderer3.prototype.destroy = function(removeView) {
      this.runners.destroy.emit();
      for (var r2 in this.runners) {
        this.runners[r2].destroy();
      }
      _super.prototype.destroy.call(this, removeView);
      this.gl = null;
    };
    Renderer3.registerPlugin = function(pluginName, ctor) {
      Renderer3.__plugins = Renderer3.__plugins || {};
      Renderer3.__plugins[pluginName] = ctor;
    };
    return Renderer3;
  }(AbstractRenderer2)
);
var BatchDrawCall2 = (
  /** @class */
  /* @__PURE__ */ function() {
    function BatchDrawCall3() {
      this.texArray = null;
      this.blend = 0;
      this.type = DRAW_MODES2.TRIANGLES;
      this.start = 0;
      this.size = 0;
      this.data = null;
    }
    return BatchDrawCall3;
  }()
);
var BatchTextureArray2 = (
  /** @class */
  function() {
    function BatchTextureArray3() {
      this.elements = [];
      this.ids = [];
      this.count = 0;
    }
    BatchTextureArray3.prototype.clear = function() {
      for (var i = 0; i < this.count; i++) {
        this.elements[i] = null;
      }
      this.count = 0;
    };
    return BatchTextureArray3;
  }()
);
var ViewableBuffer2 = (
  /** @class */
  function() {
    function ViewableBuffer3(size) {
      this.rawBinaryData = new ArrayBuffer(size);
      this.uint32View = new Uint32Array(this.rawBinaryData);
      this.float32View = new Float32Array(this.rawBinaryData);
    }
    Object.defineProperty(ViewableBuffer3.prototype, "int8View", {
      /**
       * View on the raw binary data as a `Int8Array`.
       *
       * @member {Int8Array}
       */
      get: function() {
        if (!this._int8View) {
          this._int8View = new Int8Array(this.rawBinaryData);
        }
        return this._int8View;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ViewableBuffer3.prototype, "uint8View", {
      /**
       * View on the raw binary data as a `Uint8Array`.
       *
       * @member {Uint8Array}
       */
      get: function() {
        if (!this._uint8View) {
          this._uint8View = new Uint8Array(this.rawBinaryData);
        }
        return this._uint8View;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ViewableBuffer3.prototype, "int16View", {
      /**
       * View on the raw binary data as a `Int16Array`.
       *
       * @member {Int16Array}
       */
      get: function() {
        if (!this._int16View) {
          this._int16View = new Int16Array(this.rawBinaryData);
        }
        return this._int16View;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ViewableBuffer3.prototype, "uint16View", {
      /**
       * View on the raw binary data as a `Uint16Array`.
       *
       * @member {Uint16Array}
       */
      get: function() {
        if (!this._uint16View) {
          this._uint16View = new Uint16Array(this.rawBinaryData);
        }
        return this._uint16View;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ViewableBuffer3.prototype, "int32View", {
      /**
       * View on the raw binary data as a `Int32Array`.
       *
       * @member {Int32Array}
       */
      get: function() {
        if (!this._int32View) {
          this._int32View = new Int32Array(this.rawBinaryData);
        }
        return this._int32View;
      },
      enumerable: false,
      configurable: true
    });
    ViewableBuffer3.prototype.view = function(type) {
      return this[type + "View"];
    };
    ViewableBuffer3.prototype.destroy = function() {
      this.rawBinaryData = null;
      this._int8View = null;
      this._uint8View = null;
      this._int16View = null;
      this._uint16View = null;
      this._int32View = null;
      this.uint32View = null;
      this.float32View = null;
    };
    ViewableBuffer3.sizeOf = function(type) {
      switch (type) {
        case "int8":
        case "uint8":
          return 1;
        case "int16":
        case "uint16":
          return 2;
        case "int32":
        case "uint32":
        case "float32":
          return 4;
        default:
          throw new Error(type + " isn't a valid view type");
      }
    };
    return ViewableBuffer3;
  }()
);
var AbstractBatchRenderer2 = (
  /** @class */
  function(_super) {
    __extends3(AbstractBatchRenderer3, _super);
    function AbstractBatchRenderer3(renderer) {
      var _this = _super.call(this, renderer) || this;
      _this.shaderGenerator = null;
      _this.geometryClass = null;
      _this.vertexSize = null;
      _this.state = State2.for2d();
      _this.size = settings2.SPRITE_BATCH_SIZE * 4;
      _this._vertexCount = 0;
      _this._indexCount = 0;
      _this._bufferedElements = [];
      _this._bufferedTextures = [];
      _this._bufferSize = 0;
      _this._shader = null;
      _this._packedGeometries = [];
      _this._packedGeometryPoolSize = 2;
      _this._flushId = 0;
      _this._aBuffers = {};
      _this._iBuffers = {};
      _this.MAX_TEXTURES = 1;
      _this.renderer.on("prerender", _this.onPrerender, _this);
      renderer.runners.contextChange.add(_this);
      _this._dcIndex = 0;
      _this._aIndex = 0;
      _this._iIndex = 0;
      _this._attributeBuffer = null;
      _this._indexBuffer = null;
      _this._tempBoundTextures = [];
      return _this;
    }
    AbstractBatchRenderer3.prototype.contextChange = function() {
      var gl = this.renderer.gl;
      if (settings2.PREFER_ENV === ENV2.WEBGL_LEGACY) {
        this.MAX_TEXTURES = 1;
      } else {
        this.MAX_TEXTURES = Math.min(gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS), settings2.SPRITE_MAX_TEXTURES);
        this.MAX_TEXTURES = checkMaxIfStatementsInShader2(this.MAX_TEXTURES, gl);
      }
      this._shader = this.shaderGenerator.generateShader(this.MAX_TEXTURES);
      for (var i = 0; i < this._packedGeometryPoolSize; i++) {
        this._packedGeometries[i] = new this.geometryClass();
      }
      this.initFlushBuffers();
    };
    AbstractBatchRenderer3.prototype.initFlushBuffers = function() {
      var _drawCallPool = AbstractBatchRenderer3._drawCallPool, _textureArrayPool = AbstractBatchRenderer3._textureArrayPool;
      var MAX_SPRITES = this.size / 4;
      var MAX_TA = Math.floor(MAX_SPRITES / this.MAX_TEXTURES) + 1;
      while (_drawCallPool.length < MAX_SPRITES) {
        _drawCallPool.push(new BatchDrawCall2());
      }
      while (_textureArrayPool.length < MAX_TA) {
        _textureArrayPool.push(new BatchTextureArray2());
      }
      for (var i = 0; i < this.MAX_TEXTURES; i++) {
        this._tempBoundTextures[i] = null;
      }
    };
    AbstractBatchRenderer3.prototype.onPrerender = function() {
      this._flushId = 0;
    };
    AbstractBatchRenderer3.prototype.render = function(element) {
      if (!element._texture.valid) {
        return;
      }
      if (this._vertexCount + element.vertexData.length / 2 > this.size) {
        this.flush();
      }
      this._vertexCount += element.vertexData.length / 2;
      this._indexCount += element.indices.length;
      this._bufferedTextures[this._bufferSize] = element._texture.baseTexture;
      this._bufferedElements[this._bufferSize++] = element;
    };
    AbstractBatchRenderer3.prototype.buildTexturesAndDrawCalls = function() {
      var _a = this, textures = _a._bufferedTextures, MAX_TEXTURES = _a.MAX_TEXTURES;
      var textureArrays = AbstractBatchRenderer3._textureArrayPool;
      var batch = this.renderer.batch;
      var boundTextures = this._tempBoundTextures;
      var touch = this.renderer.textureGC.count;
      var TICK = ++BaseTexture2._globalBatch;
      var countTexArrays = 0;
      var texArray = textureArrays[0];
      var start = 0;
      batch.copyBoundTextures(boundTextures, MAX_TEXTURES);
      for (var i = 0; i < this._bufferSize; ++i) {
        var tex = textures[i];
        textures[i] = null;
        if (tex._batchEnabled === TICK) {
          continue;
        }
        if (texArray.count >= MAX_TEXTURES) {
          batch.boundArray(texArray, boundTextures, TICK, MAX_TEXTURES);
          this.buildDrawCalls(texArray, start, i);
          start = i;
          texArray = textureArrays[++countTexArrays];
          ++TICK;
        }
        tex._batchEnabled = TICK;
        tex.touched = touch;
        texArray.elements[texArray.count++] = tex;
      }
      if (texArray.count > 0) {
        batch.boundArray(texArray, boundTextures, TICK, MAX_TEXTURES);
        this.buildDrawCalls(texArray, start, this._bufferSize);
        ++countTexArrays;
        ++TICK;
      }
      for (var i = 0; i < boundTextures.length; i++) {
        boundTextures[i] = null;
      }
      BaseTexture2._globalBatch = TICK;
    };
    AbstractBatchRenderer3.prototype.buildDrawCalls = function(texArray, start, finish) {
      var _a = this, elements = _a._bufferedElements, _attributeBuffer = _a._attributeBuffer, _indexBuffer = _a._indexBuffer, vertexSize = _a.vertexSize;
      var drawCalls = AbstractBatchRenderer3._drawCallPool;
      var dcIndex = this._dcIndex;
      var aIndex = this._aIndex;
      var iIndex = this._iIndex;
      var drawCall = drawCalls[dcIndex];
      drawCall.start = this._iIndex;
      drawCall.texArray = texArray;
      for (var i = start; i < finish; ++i) {
        var sprite = elements[i];
        var tex = sprite._texture.baseTexture;
        var spriteBlendMode = premultiplyBlendMode2[tex.alphaMode ? 1 : 0][sprite.blendMode];
        elements[i] = null;
        if (start < i && drawCall.blend !== spriteBlendMode) {
          drawCall.size = iIndex - drawCall.start;
          start = i;
          drawCall = drawCalls[++dcIndex];
          drawCall.texArray = texArray;
          drawCall.start = iIndex;
        }
        this.packInterleavedGeometry(sprite, _attributeBuffer, _indexBuffer, aIndex, iIndex);
        aIndex += sprite.vertexData.length / 2 * vertexSize;
        iIndex += sprite.indices.length;
        drawCall.blend = spriteBlendMode;
      }
      if (start < finish) {
        drawCall.size = iIndex - drawCall.start;
        ++dcIndex;
      }
      this._dcIndex = dcIndex;
      this._aIndex = aIndex;
      this._iIndex = iIndex;
    };
    AbstractBatchRenderer3.prototype.bindAndClearTexArray = function(texArray) {
      var textureSystem = this.renderer.texture;
      for (var j2 = 0; j2 < texArray.count; j2++) {
        textureSystem.bind(texArray.elements[j2], texArray.ids[j2]);
        texArray.elements[j2] = null;
      }
      texArray.count = 0;
    };
    AbstractBatchRenderer3.prototype.updateGeometry = function() {
      var _a = this, packedGeometries = _a._packedGeometries, attributeBuffer = _a._attributeBuffer, indexBuffer = _a._indexBuffer;
      if (!settings2.CAN_UPLOAD_SAME_BUFFER) {
        if (this._packedGeometryPoolSize <= this._flushId) {
          this._packedGeometryPoolSize++;
          packedGeometries[this._flushId] = new this.geometryClass();
        }
        packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData);
        packedGeometries[this._flushId]._indexBuffer.update(indexBuffer);
        this.renderer.geometry.bind(packedGeometries[this._flushId]);
        this.renderer.geometry.updateBuffers();
        this._flushId++;
      } else {
        packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData);
        packedGeometries[this._flushId]._indexBuffer.update(indexBuffer);
        this.renderer.geometry.updateBuffers();
      }
    };
    AbstractBatchRenderer3.prototype.drawBatches = function() {
      var dcCount = this._dcIndex;
      var _a = this.renderer, gl = _a.gl, stateSystem = _a.state;
      var drawCalls = AbstractBatchRenderer3._drawCallPool;
      var curTexArray = null;
      for (var i = 0; i < dcCount; i++) {
        var _b = drawCalls[i], texArray = _b.texArray, type = _b.type, size = _b.size, start = _b.start, blend = _b.blend;
        if (curTexArray !== texArray) {
          curTexArray = texArray;
          this.bindAndClearTexArray(texArray);
        }
        this.state.blendMode = blend;
        stateSystem.set(this.state);
        gl.drawElements(type, size, gl.UNSIGNED_SHORT, start * 2);
      }
    };
    AbstractBatchRenderer3.prototype.flush = function() {
      if (this._vertexCount === 0) {
        return;
      }
      this._attributeBuffer = this.getAttributeBuffer(this._vertexCount);
      this._indexBuffer = this.getIndexBuffer(this._indexCount);
      this._aIndex = 0;
      this._iIndex = 0;
      this._dcIndex = 0;
      this.buildTexturesAndDrawCalls();
      this.updateGeometry();
      this.drawBatches();
      this._bufferSize = 0;
      this._vertexCount = 0;
      this._indexCount = 0;
    };
    AbstractBatchRenderer3.prototype.start = function() {
      this.renderer.state.set(this.state);
      this.renderer.shader.bind(this._shader);
      if (settings2.CAN_UPLOAD_SAME_BUFFER) {
        this.renderer.geometry.bind(this._packedGeometries[this._flushId]);
      }
    };
    AbstractBatchRenderer3.prototype.stop = function() {
      this.flush();
    };
    AbstractBatchRenderer3.prototype.destroy = function() {
      for (var i = 0; i < this._packedGeometryPoolSize; i++) {
        if (this._packedGeometries[i]) {
          this._packedGeometries[i].destroy();
        }
      }
      this.renderer.off("prerender", this.onPrerender, this);
      this._aBuffers = null;
      this._iBuffers = null;
      this._packedGeometries = null;
      this._attributeBuffer = null;
      this._indexBuffer = null;
      if (this._shader) {
        this._shader.destroy();
        this._shader = null;
      }
      _super.prototype.destroy.call(this);
    };
    AbstractBatchRenderer3.prototype.getAttributeBuffer = function(size) {
      var roundedP2 = nextPow22(Math.ceil(size / 8));
      var roundedSizeIndex = log22(roundedP2);
      var roundedSize = roundedP2 * 8;
      if (this._aBuffers.length <= roundedSizeIndex) {
        this._iBuffers.length = roundedSizeIndex + 1;
      }
      var buffer = this._aBuffers[roundedSize];
      if (!buffer) {
        this._aBuffers[roundedSize] = buffer = new ViewableBuffer2(roundedSize * this.vertexSize * 4);
      }
      return buffer;
    };
    AbstractBatchRenderer3.prototype.getIndexBuffer = function(size) {
      var roundedP2 = nextPow22(Math.ceil(size / 12));
      var roundedSizeIndex = log22(roundedP2);
      var roundedSize = roundedP2 * 12;
      if (this._iBuffers.length <= roundedSizeIndex) {
        this._iBuffers.length = roundedSizeIndex + 1;
      }
      var buffer = this._iBuffers[roundedSizeIndex];
      if (!buffer) {
        this._iBuffers[roundedSizeIndex] = buffer = new Uint16Array(roundedSize);
      }
      return buffer;
    };
    AbstractBatchRenderer3.prototype.packInterleavedGeometry = function(element, attributeBuffer, indexBuffer, aIndex, iIndex) {
      var uint32View = attributeBuffer.uint32View, float32View = attributeBuffer.float32View;
      var packedVertices = aIndex / this.vertexSize;
      var uvs = element.uvs;
      var indicies = element.indices;
      var vertexData = element.vertexData;
      var textureId = element._texture.baseTexture._batchLocation;
      var alpha = Math.min(element.worldAlpha, 1);
      var argb = alpha < 1 && element._texture.baseTexture.alphaMode ? premultiplyTint2(element._tintRGB, alpha) : element._tintRGB + (alpha * 255 << 24);
      for (var i = 0; i < vertexData.length; i += 2) {
        float32View[aIndex++] = vertexData[i];
        float32View[aIndex++] = vertexData[i + 1];
        float32View[aIndex++] = uvs[i];
        float32View[aIndex++] = uvs[i + 1];
        uint32View[aIndex++] = argb;
        float32View[aIndex++] = textureId;
      }
      for (var i = 0; i < indicies.length; i++) {
        indexBuffer[iIndex++] = packedVertices + indicies[i];
      }
    };
    AbstractBatchRenderer3._drawCallPool = [];
    AbstractBatchRenderer3._textureArrayPool = [];
    return AbstractBatchRenderer3;
  }(ObjectRenderer2)
);
var BatchShaderGenerator2 = (
  /** @class */
  function() {
    function BatchShaderGenerator3(vertexSrc, fragTemplate3) {
      this.vertexSrc = vertexSrc;
      this.fragTemplate = fragTemplate3;
      this.programCache = {};
      this.defaultGroupCache = {};
      if (fragTemplate3.indexOf("%count%") < 0) {
        throw new Error('Fragment template must contain "%count%".');
      }
      if (fragTemplate3.indexOf("%forloop%") < 0) {
        throw new Error('Fragment template must contain "%forloop%".');
      }
    }
    BatchShaderGenerator3.prototype.generateShader = function(maxTextures) {
      if (!this.programCache[maxTextures]) {
        var sampleValues = new Int32Array(maxTextures);
        for (var i = 0; i < maxTextures; i++) {
          sampleValues[i] = i;
        }
        this.defaultGroupCache[maxTextures] = UniformGroup2.from({ uSamplers: sampleValues }, true);
        var fragmentSrc = this.fragTemplate;
        fragmentSrc = fragmentSrc.replace(/%count%/gi, "" + maxTextures);
        fragmentSrc = fragmentSrc.replace(/%forloop%/gi, this.generateSampleSrc(maxTextures));
        this.programCache[maxTextures] = new Program2(this.vertexSrc, fragmentSrc);
      }
      var uniforms = {
        tint: new Float32Array([1, 1, 1, 1]),
        translationMatrix: new Matrix2(),
        default: this.defaultGroupCache[maxTextures]
      };
      return new Shader2(this.programCache[maxTextures], uniforms);
    };
    BatchShaderGenerator3.prototype.generateSampleSrc = function(maxTextures) {
      var src = "";
      src += "\n";
      src += "\n";
      for (var i = 0; i < maxTextures; i++) {
        if (i > 0) {
          src += "\nelse ";
        }
        if (i < maxTextures - 1) {
          src += "if(vTextureId < " + i + ".5)";
        }
        src += "\n{";
        src += "\n	color = texture2D(uSamplers[" + i + "], vTextureCoord);";
        src += "\n}";
      }
      src += "\n";
      src += "\n";
      return src;
    };
    return BatchShaderGenerator3;
  }()
);
var BatchGeometry2 = (
  /** @class */
  function(_super) {
    __extends3(BatchGeometry3, _super);
    function BatchGeometry3(_static) {
      if (_static === void 0) {
        _static = false;
      }
      var _this = _super.call(this) || this;
      _this._buffer = new Buffer2(null, _static, false);
      _this._indexBuffer = new Buffer2(null, _static, true);
      _this.addAttribute("aVertexPosition", _this._buffer, 2, false, TYPES2.FLOAT).addAttribute("aTextureCoord", _this._buffer, 2, false, TYPES2.FLOAT).addAttribute("aColor", _this._buffer, 4, true, TYPES2.UNSIGNED_BYTE).addAttribute("aTextureId", _this._buffer, 1, true, TYPES2.FLOAT).addIndex(_this._indexBuffer);
      return _this;
    }
    return BatchGeometry3;
  }(Geometry2)
);
var defaultVertex$22 = "precision highp float;\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\nattribute float aTextureId;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform vec4 tint;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\n\nvoid main(void){\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vTextureId = aTextureId;\n    vColor = aColor * tint;\n}\n";
var defaultFragment$22 = "varying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\nuniform sampler2D uSamplers[%count%];\n\nvoid main(void){\n    vec4 color;\n    %forloop%\n    gl_FragColor = color * vColor;\n}\n";
var BatchPluginFactory2 = (
  /** @class */
  function() {
    function BatchPluginFactory3() {
    }
    BatchPluginFactory3.create = function(options) {
      var _a = Object.assign({
        vertex: defaultVertex$22,
        fragment: defaultFragment$22,
        geometryClass: BatchGeometry2,
        vertexSize: 6
      }, options), vertex3 = _a.vertex, fragment3 = _a.fragment, vertexSize = _a.vertexSize, geometryClass = _a.geometryClass;
      return (
        /** @class */
        function(_super) {
          __extends3(BatchPlugin, _super);
          function BatchPlugin(renderer) {
            var _this = _super.call(this, renderer) || this;
            _this.shaderGenerator = new BatchShaderGenerator2(vertex3, fragment3);
            _this.geometryClass = geometryClass;
            _this.vertexSize = vertexSize;
            return _this;
          }
          return BatchPlugin;
        }(AbstractBatchRenderer2)
      );
    };
    Object.defineProperty(BatchPluginFactory3, "defaultVertexSrc", {
      /**
       * The default vertex shader source
       *
       * @static
       * @type {string}
       * @constant
       */
      get: function() {
        return defaultVertex$22;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BatchPluginFactory3, "defaultFragmentTemplate", {
      /**
       * The default fragment shader source
       *
       * @static
       * @type {string}
       * @constant
       */
      get: function() {
        return defaultFragment$22;
      },
      enumerable: false,
      configurable: true
    });
    return BatchPluginFactory3;
  }()
);
var BatchRenderer2 = BatchPluginFactory2.create();

// node_modules/pixi-sound/dist/pixi-sound.esm.js
var r = function() {
  function t(t2, e) {
    this._output = e, this._input = t2;
  }
  return Object.defineProperty(t.prototype, "destination", { get: function() {
    return this._input;
  }, enumerable: true, configurable: true }), Object.defineProperty(t.prototype, "filters", { get: function() {
    return this._filters;
  }, set: function(t2) {
    var e = this;
    if (this._filters && (this._filters.forEach(function(t3) {
      t3 && t3.disconnect();
    }), this._filters = null, this._input.connect(this._output)), t2 && t2.length) {
      this._filters = t2.slice(0), this._input.disconnect();
      var n = null;
      t2.forEach(function(t3) {
        null === n ? e._input.connect(t3.destination) : n.connect(t3.destination), n = t3;
      }), n.connect(this._output);
    }
  }, enumerable: true, configurable: true }), t.prototype.destroy = function() {
    this.filters = null, this._input = null, this._output = null;
  }, t;
}();
var s = function() {
  function t(t2, e) {
    this.init(t2, e);
  }
  return t.prototype.init = function(t2, e) {
    this.destination = t2, this.source = e || t2;
  }, t.prototype.connect = function(t2) {
    this.source.connect(t2);
  }, t.prototype.disconnect = function() {
    this.source.disconnect();
  }, t.prototype.destroy = function() {
    this.disconnect(), this.destination = null, this.source = null;
  }, t;
}();
var u = function(t, e) {
  return (u = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t2, e2) {
    t2.__proto__ = e2;
  } || function(t2, e2) {
    for (var n in e2) e2.hasOwnProperty(n) && (t2[n] = e2[n]);
  })(t, e);
};
function a(t, e) {
  function n() {
    this.constructor = t;
  }
  u(t, e), t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype, new n());
}
var c;
var p = function() {
  return (p = Object.assign || function(t) {
    for (var e, n = 1, o = arguments.length; n < o; n++) for (var i in e = arguments[n]) Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]);
    return t;
  }).apply(this, arguments);
};
function h() {
  return c;
}
var l = function() {
  function t() {
  }
  return t.setParamValue = function(t2, e) {
    if (t2.setValueAtTime) {
      var n = h().context;
      t2.setValueAtTime(e, n.audioContext.currentTime);
    } else t2.value = e;
    return e;
  }, t;
}();
var f = 0;
var d = function(t) {
  function e(e2) {
    var n = t.call(this) || this;
    return n.id = f++, n._media = null, n._paused = false, n._muted = false, n._elapsed = 0, n.init(e2), n;
  }
  return a(e, t), e.prototype.set = function(t2, e2) {
    if (void 0 === this[t2]) throw new Error("Property with name " + t2 + " does not exist.");
    return this[t2] = e2, this;
  }, e.prototype.stop = function() {
    this._source && (this._internalStop(), this.emit("stop"));
  }, Object.defineProperty(e.prototype, "speed", { get: function() {
    return this._speed;
  }, set: function(t2) {
    this._speed = t2, this.refresh(), this._update(true);
  }, enumerable: true, configurable: true }), Object.defineProperty(e.prototype, "volume", { get: function() {
    return this._volume;
  }, set: function(t2) {
    this._volume = t2, this.refresh();
  }, enumerable: true, configurable: true }), Object.defineProperty(e.prototype, "muted", { get: function() {
    return this._muted;
  }, set: function(t2) {
    this._muted = t2, this.refresh();
  }, enumerable: true, configurable: true }), Object.defineProperty(e.prototype, "loop", { get: function() {
    return this._loop;
  }, set: function(t2) {
    this._loop = t2, this.refresh();
  }, enumerable: true, configurable: true }), e.prototype.refresh = function() {
    if (this._source) {
      var t2 = this._media.context, e2 = this._media.parent;
      this._source.loop = this._loop || e2.loop;
      var n = t2.volume * (t2.muted ? 0 : 1), o = e2.volume * (e2.muted ? 0 : 1), i = this._volume * (this._muted ? 0 : 1);
      l.setParamValue(this._gain.gain, i * o * n), l.setParamValue(this._source.playbackRate, this._speed * e2.speed * t2.speed);
    }
  }, e.prototype.refreshPaused = function() {
    var t2 = this._media.context, e2 = this._media.parent, n = this._paused || e2.paused || t2.paused;
    n !== this._pausedReal && (this._pausedReal = n, n ? (this._internalStop(), this.emit("paused")) : (this.emit("resumed"), this.play({ start: this._elapsed % this._duration, end: this._end, speed: this._speed, loop: this._loop, volume: this._volume })), this.emit("pause", n));
  }, e.prototype.play = function(t2) {
    var e2 = t2.start, n = t2.end, o = t2.speed, i = t2.loop, r2 = t2.volume, s2 = t2.muted;
    this._paused = false;
    var u2 = this._media.nodes.cloneBufferSource(), a2 = u2.source, c2 = u2.gain;
    this._source = a2, this._gain = c2, this._speed = o, this._volume = r2, this._loop = !!i, this._muted = s2, this.refresh();
    var p2 = this._source.buffer.duration;
    this._duration = p2, this._end = n, this._lastUpdate = this._now(), this._elapsed = e2, this._source.onended = this._onComplete.bind(this), this._loop ? (this._source.loopEnd = n, this._source.loopStart = e2, this._source.start(0, e2)) : n ? this._source.start(0, e2, n - e2) : this._source.start(0, e2), this.emit("start"), this._update(true), this._enabled = true;
  }, e.prototype._toSec = function(t2) {
    return t2 > 10 && (t2 /= 1e3), t2 || 0;
  }, Object.defineProperty(e.prototype, "_enabled", { set: function(t2) {
    Ticker2.shared.remove(this._updateListener, this), t2 && Ticker2.shared.add(this._updateListener, this);
  }, enumerable: true, configurable: true }), Object.defineProperty(e.prototype, "progress", { get: function() {
    return this._progress;
  }, enumerable: true, configurable: true }), Object.defineProperty(e.prototype, "paused", { get: function() {
    return this._paused;
  }, set: function(t2) {
    this._paused = t2, this.refreshPaused();
  }, enumerable: true, configurable: true }), e.prototype.destroy = function() {
    this.removeAllListeners(), this._internalStop(), this._gain && (this._gain.disconnect(), this._gain = null), this._media && (this._media.context.events.off("refresh", this.refresh, this), this._media.context.events.off("refreshPaused", this.refreshPaused, this), this._media = null), this._end = null, this._speed = 1, this._volume = 1, this._loop = false, this._elapsed = 0, this._duration = 0, this._paused = false, this._muted = false, this._pausedReal = false;
  }, e.prototype.toString = function() {
    return "[WebAudioInstance id=" + this.id + "]";
  }, e.prototype._now = function() {
    return this._media.context.audioContext.currentTime;
  }, e.prototype._updateListener = function() {
    this._update();
  }, e.prototype._update = function(t2) {
    if (void 0 === t2 && (t2 = false), this._source) {
      var e2 = this._now(), n = e2 - this._lastUpdate;
      if (n > 0 || t2) {
        var o = this._source.playbackRate.value;
        this._elapsed += n * o, this._lastUpdate = e2;
        var i = this._duration, r2 = void 0;
        if (this._source.loopStart) {
          var s2 = this._source.loopEnd - this._source.loopStart;
          r2 = (this._source.loopStart + this._elapsed % s2) / i;
        } else r2 = this._elapsed % i / i;
        this._progress = r2, this.emit("progress", this._progress, i);
      }
    }
  }, e.prototype.init = function(t2) {
    this._media = t2, t2.context.events.on("refresh", this.refresh, this), t2.context.events.on("refreshPaused", this.refreshPaused, this);
  }, e.prototype._internalStop = function() {
    this._source && (this._enabled = false, this._source.onended = null, this._source.stop(0), this._source.disconnect(), this._source = null);
  }, e.prototype._onComplete = function() {
    this._source && (this._enabled = false, this._source.onended = null, this._source.disconnect()), this._source = null, this._progress = 1, this.emit("progress", 1, this._duration), this.emit("end", this);
  }, e;
}(import_eventemitter32.default);
var _ = function(t) {
  function e(e2) {
    var n = this, o = e2.audioContext, i = o.createBufferSource(), r2 = o.createGain(), s2 = o.createAnalyser();
    return i.connect(s2), s2.connect(r2), r2.connect(e2.destination), (n = t.call(this, s2, r2) || this).context = e2, n.bufferSource = i, n.gain = r2, n.analyser = s2, n;
  }
  return a(e, t), Object.defineProperty(e.prototype, "script", { get: function() {
    return this._script || (this._script = this.context.audioContext.createScriptProcessor(e.BUFFER_SIZE), this._script.connect(this.context.destination)), this._script;
  }, enumerable: true, configurable: true }), e.prototype.destroy = function() {
    t.prototype.destroy.call(this), this.bufferSource.disconnect(), this._script && this._script.disconnect(), this.gain.disconnect(), this.analyser.disconnect(), this.bufferSource = null, this._script = null, this.gain = null, this.analyser = null, this.context = null;
  }, e.prototype.cloneBufferSource = function() {
    var t2 = this.bufferSource, e2 = this.context.audioContext.createBufferSource();
    e2.buffer = t2.buffer, l.setParamValue(e2.playbackRate, t2.playbackRate.value), e2.loop = t2.loop;
    var n = this.context.audioContext.createGain();
    return e2.connect(n), n.connect(this.destination), { source: e2, gain: n };
  }, Object.defineProperty(e.prototype, "bufferSize", { get: function() {
    return this.script.bufferSize;
  }, enumerable: true, configurable: true }), e.BUFFER_SIZE = 0, e;
}(r);
var y = function() {
  function t() {
  }
  return t.prototype.init = function(t2) {
    this.parent = t2, this._nodes = new _(this.context), this._source = this._nodes.bufferSource, this.source = t2.options.source;
  }, t.prototype.destroy = function() {
    this.parent = null, this._nodes.destroy(), this._nodes = null, this._source = null, this.source = null;
  }, t.prototype.create = function() {
    return new d(this);
  }, Object.defineProperty(t.prototype, "context", { get: function() {
    return this.parent.context;
  }, enumerable: true, configurable: true }), Object.defineProperty(t.prototype, "isPlayable", { get: function() {
    return !!this._source && !!this._source.buffer;
  }, enumerable: true, configurable: true }), Object.defineProperty(t.prototype, "filters", { get: function() {
    return this._nodes.filters;
  }, set: function(t2) {
    this._nodes.filters = t2;
  }, enumerable: true, configurable: true }), Object.defineProperty(t.prototype, "duration", { get: function() {
    return this._source.buffer.duration;
  }, enumerable: true, configurable: true }), Object.defineProperty(t.prototype, "buffer", { get: function() {
    return this._source.buffer;
  }, set: function(t2) {
    this._source.buffer = t2;
  }, enumerable: true, configurable: true }), Object.defineProperty(t.prototype, "nodes", { get: function() {
    return this._nodes;
  }, enumerable: true, configurable: true }), t.prototype.load = function(t2) {
    this.source ? this._decode(this.source, t2) : this.parent.url ? this._loadUrl(t2) : t2 && t2(new Error("sound.url or sound.source must be set"));
  }, t.prototype._loadUrl = function(t2) {
    var e = this, n = new XMLHttpRequest(), o = this.parent.url;
    n.open("GET", o, true), n.responseType = "arraybuffer", n.onload = function() {
      e.source = n.response, e._decode(n.response, t2);
    }, n.send();
  }, t.prototype._decode = function(t2, e) {
    var n = this;
    this.parent.context.decode(t2, function(t3, o) {
      if (t3) e && e(t3);
      else {
        n.parent.isLoaded = true, n.buffer = o;
        var i = n.parent.autoPlayStart();
        e && e(null, n.parent, i);
      }
    });
  }, t;
}();
var m = function(t) {
  function e() {
    var n = this, i = window, r2 = new e.AudioContext(), s2 = r2.createDynamicsCompressor(), u2 = r2.createAnalyser();
    return u2.connect(s2), s2.connect(r2.destination), (n = t.call(this, u2, s2) || this)._ctx = r2, n._offlineCtx = new e.OfflineAudioContext(1, 2, i.OfflineAudioContext ? r2.sampleRate : 44100), n._unlocked = false, n.compressor = s2, n.analyser = u2, n.events = new import_eventemitter32.default(), n.volume = 1, n.speed = 1, n.muted = false, n.paused = false, "running" !== r2.state && (n._unlock(), n._unlock = n._unlock.bind(n), document.addEventListener("mousedown", n._unlock, true), document.addEventListener("touchstart", n._unlock, true), document.addEventListener("touchend", n._unlock, true)), n;
  }
  return a(e, t), e.prototype._unlock = function() {
    this._unlocked || (this.playEmptySound(), "running" === this._ctx.state && (document.removeEventListener("mousedown", this._unlock, true), document.removeEventListener("touchend", this._unlock, true), document.removeEventListener("touchstart", this._unlock, true), this._unlocked = true));
  }, e.prototype.playEmptySound = function() {
    var t2 = this._ctx.createBufferSource();
    t2.buffer = this._ctx.createBuffer(1, 1, 22050), t2.connect(this._ctx.destination), t2.start(0, 0, 0), "suspended" === t2.context.state && t2.context.resume();
  }, Object.defineProperty(e, "AudioContext", { get: function() {
    var t2 = window;
    return t2.AudioContext || t2.webkitAudioContext || null;
  }, enumerable: true, configurable: true }), Object.defineProperty(e, "OfflineAudioContext", { get: function() {
    var t2 = window;
    return t2.OfflineAudioContext || t2.webkitOfflineAudioContext || null;
  }, enumerable: true, configurable: true }), e.prototype.destroy = function() {
    t.prototype.destroy.call(this);
    var e2 = this._ctx;
    void 0 !== e2.close && e2.close(), this.events.removeAllListeners(), this.analyser.disconnect(), this.compressor.disconnect(), this.analyser = null, this.compressor = null, this.events = null, this._offlineCtx = null, this._ctx = null;
  }, Object.defineProperty(e.prototype, "audioContext", { get: function() {
    return this._ctx;
  }, enumerable: true, configurable: true }), Object.defineProperty(e.prototype, "offlineContext", { get: function() {
    return this._offlineCtx;
  }, enumerable: true, configurable: true }), Object.defineProperty(e.prototype, "paused", { get: function() {
    return this._paused;
  }, set: function(t2) {
    t2 && "running" === this._ctx.state ? this._ctx.suspend() : t2 || "suspended" !== this._ctx.state || this._ctx.resume(), this._paused = t2;
  }, enumerable: true, configurable: true }), e.prototype.refresh = function() {
    this.events.emit("refresh");
  }, e.prototype.refreshPaused = function() {
    this.events.emit("refreshPaused");
  }, e.prototype.toggleMute = function() {
    return this.muted = !this.muted, this.refresh(), this.muted;
  }, e.prototype.togglePause = function() {
    return this.paused = !this.paused, this.refreshPaused(), this._paused;
  }, e.prototype.decode = function(t2, e2) {
    this._offlineCtx.decodeAudioData(t2, function(t3) {
      e2(null, t3);
    }, function(t3) {
      e2(new Error(t3.message || "Unable to decode file"));
    });
  }, e;
}(r);
var g = { WebAudioMedia: y, WebAudioInstance: d, WebAudioNodes: _, WebAudioContext: m, WebAudioUtils: l };
var b = { Filter: s, EqualizerFilter: function(t) {
  function e(n, o, i, r2, s2, u2, a2, c2, p2, f2) {
    void 0 === n && (n = 0), void 0 === o && (o = 0), void 0 === i && (i = 0), void 0 === r2 && (r2 = 0), void 0 === s2 && (s2 = 0), void 0 === u2 && (u2 = 0), void 0 === a2 && (a2 = 0), void 0 === c2 && (c2 = 0), void 0 === p2 && (p2 = 0), void 0 === f2 && (f2 = 0);
    var d2 = this;
    if (!h().useLegacy) {
      var _2 = [{ f: e.F32, type: "lowshelf", gain: n }, { f: e.F64, type: "peaking", gain: o }, { f: e.F125, type: "peaking", gain: i }, { f: e.F250, type: "peaking", gain: r2 }, { f: e.F500, type: "peaking", gain: s2 }, { f: e.F1K, type: "peaking", gain: u2 }, { f: e.F2K, type: "peaking", gain: a2 }, { f: e.F4K, type: "peaking", gain: c2 }, { f: e.F8K, type: "peaking", gain: p2 }, { f: e.F16K, type: "highshelf", gain: f2 }].map(function(t2) {
        var e2 = h().context.audioContext.createBiquadFilter();
        return e2.type = t2.type, l.setParamValue(e2.Q, 1), e2.frequency.value = t2.f, l.setParamValue(e2.gain, t2.gain), e2;
      });
      (d2 = t.call(this, _2[0], _2[_2.length - 1]) || this).bands = _2, d2.bandsMap = {};
      for (var y2 = 0; y2 < d2.bands.length; y2++) {
        var m2 = d2.bands[y2];
        y2 > 0 && d2.bands[y2 - 1].connect(m2), d2.bandsMap[m2.frequency.value] = m2;
      }
      return d2;
    }
    d2 = t.call(this, null) || this;
  }
  return a(e, t), e.prototype.setGain = function(t2, e2) {
    if (void 0 === e2 && (e2 = 0), !this.bandsMap[t2]) throw new Error("No band found for frequency " + t2);
    l.setParamValue(this.bandsMap[t2].gain, e2);
  }, e.prototype.getGain = function(t2) {
    if (!this.bandsMap[t2]) throw new Error("No band found for frequency " + t2);
    return this.bandsMap[t2].gain.value;
  }, Object.defineProperty(e.prototype, "f32", { get: function() {
    return this.getGain(e.F32);
  }, set: function(t2) {
    this.setGain(e.F32, t2);
  }, enumerable: true, configurable: true }), Object.defineProperty(e.prototype, "f64", { get: function() {
    return this.getGain(e.F64);
  }, set: function(t2) {
    this.setGain(e.F64, t2);
  }, enumerable: true, configurable: true }), Object.defineProperty(e.prototype, "f125", { get: function() {
    return this.getGain(e.F125);
  }, set: function(t2) {
    this.setGain(e.F125, t2);
  }, enumerable: true, configurable: true }), Object.defineProperty(e.prototype, "f250", { get: function() {
    return this.getGain(e.F250);
  }, set: function(t2) {
    this.setGain(e.F250, t2);
  }, enumerable: true, configurable: true }), Object.defineProperty(e.prototype, "f500", { get: function() {
    return this.getGain(e.F500);
  }, set: function(t2) {
    this.setGain(e.F500, t2);
  }, enumerable: true, configurable: true }), Object.defineProperty(e.prototype, "f1k", { get: function() {
    return this.getGain(e.F1K);
  }, set: function(t2) {
    this.setGain(e.F1K, t2);
  }, enumerable: true, configurable: true }), Object.defineProperty(e.prototype, "f2k", { get: function() {
    return this.getGain(e.F2K);
  }, set: function(t2) {
    this.setGain(e.F2K, t2);
  }, enumerable: true, configurable: true }), Object.defineProperty(e.prototype, "f4k", { get: function() {
    return this.getGain(e.F4K);
  }, set: function(t2) {
    this.setGain(e.F4K, t2);
  }, enumerable: true, configurable: true }), Object.defineProperty(e.prototype, "f8k", { get: function() {
    return this.getGain(e.F8K);
  }, set: function(t2) {
    this.setGain(e.F8K, t2);
  }, enumerable: true, configurable: true }), Object.defineProperty(e.prototype, "f16k", { get: function() {
    return this.getGain(e.F16K);
  }, set: function(t2) {
    this.setGain(e.F16K, t2);
  }, enumerable: true, configurable: true }), e.prototype.reset = function() {
    this.bands.forEach(function(t2) {
      l.setParamValue(t2.gain, 0);
    });
  }, e.prototype.destroy = function() {
    this.bands.forEach(function(t2) {
      t2.disconnect();
    }), this.bands = null, this.bandsMap = null;
  }, e.F32 = 32, e.F64 = 64, e.F125 = 125, e.F250 = 250, e.F500 = 500, e.F1K = 1e3, e.F2K = 2e3, e.F4K = 4e3, e.F8K = 8e3, e.F16K = 16e3, e;
}(s), DistortionFilter: function(t) {
  function e(e2) {
    void 0 === e2 && (e2 = 0);
    var n = this;
    if (!h().useLegacy) {
      var o = h().context.audioContext.createWaveShaper();
      return (n = t.call(this, o) || this)._distortion = o, n.amount = e2, n;
    }
    n = t.call(this, null) || this;
  }
  return a(e, t), Object.defineProperty(e.prototype, "amount", { get: function() {
    return this._amount;
  }, set: function(t2) {
    t2 *= 1e3, this._amount = t2;
    for (var e2, n = new Float32Array(44100), o = Math.PI / 180, i = 0; i < 44100; ++i) e2 = 2 * i / 44100 - 1, n[i] = (3 + t2) * e2 * 20 * o / (Math.PI + t2 * Math.abs(e2));
    this._distortion.curve = n, this._distortion.oversample = "4x";
  }, enumerable: true, configurable: true }), e.prototype.destroy = function() {
    this._distortion = null, t.prototype.destroy.call(this);
  }, e;
}(s), StereoFilter: function(t) {
  function e(e2) {
    void 0 === e2 && (e2 = 0);
    var n = this;
    if (!h().useLegacy) {
      var o, i, r2, s2 = h().context.audioContext;
      return s2.createStereoPanner ? r2 = o = s2.createStereoPanner() : ((i = s2.createPanner()).panningModel = "equalpower", r2 = i), (n = t.call(this, r2) || this)._stereo = o, n._panner = i, n.pan = e2, n;
    }
    n = t.call(this, null) || this;
  }
  return a(e, t), Object.defineProperty(e.prototype, "pan", { get: function() {
    return this._pan;
  }, set: function(t2) {
    this._pan = t2, this._stereo ? l.setParamValue(this._stereo.pan, t2) : this._panner.setPosition(t2, 0, 1 - Math.abs(t2));
  }, enumerable: true, configurable: true }), e.prototype.destroy = function() {
    t.prototype.destroy.call(this), this._stereo = null, this._panner = null;
  }, e;
}(s), ReverbFilter: function(t) {
  function e(e2, n, o) {
    void 0 === e2 && (e2 = 3), void 0 === n && (n = 2), void 0 === o && (o = false);
    var i = this;
    if (!h().useLegacy) return (i = t.call(this, null) || this)._seconds = i._clamp(e2, 1, 50), i._decay = i._clamp(n, 0, 100), i._reverse = o, i._rebuild(), i;
    i = t.call(this, null) || this;
  }
  return a(e, t), e.prototype._clamp = function(t2, e2, n) {
    return Math.min(n, Math.max(e2, t2));
  }, Object.defineProperty(e.prototype, "seconds", { get: function() {
    return this._seconds;
  }, set: function(t2) {
    this._seconds = this._clamp(t2, 1, 50), this._rebuild();
  }, enumerable: true, configurable: true }), Object.defineProperty(e.prototype, "decay", { get: function() {
    return this._decay;
  }, set: function(t2) {
    this._decay = this._clamp(t2, 0, 100), this._rebuild();
  }, enumerable: true, configurable: true }), Object.defineProperty(e.prototype, "reverse", { get: function() {
    return this._reverse;
  }, set: function(t2) {
    this._reverse = t2, this._rebuild();
  }, enumerable: true, configurable: true }), e.prototype._rebuild = function() {
    for (var t2, e2 = h().context.audioContext, n = e2.sampleRate, o = n * this._seconds, i = e2.createBuffer(2, o, n), r2 = i.getChannelData(0), s2 = i.getChannelData(1), u2 = 0; u2 < o; u2++) t2 = this._reverse ? o - u2 : u2, r2[u2] = (2 * Math.random() - 1) * Math.pow(1 - t2 / o, this._decay), s2[u2] = (2 * Math.random() - 1) * Math.pow(1 - t2 / o, this._decay);
    var a2 = h().context.audioContext.createConvolver();
    a2.buffer = i, this.init(a2);
  }, e;
}(s), MonoFilter: function(t) {
  function e() {
    var e2 = this;
    if (!h().useLegacy) {
      var n = h().context.audioContext, o = n.createChannelSplitter(), i = n.createChannelMerger();
      return i.connect(o), (e2 = t.call(this, i, o) || this)._merger = i, e2;
    }
    e2 = t.call(this, null) || this;
  }
  return a(e, t), e.prototype.destroy = function() {
    this._merger.disconnect(), this._merger = null, t.prototype.destroy.call(this);
  }, e;
}(s), TelephoneFilter: function(t) {
  function e() {
    if (!h().useLegacy) {
      var e2 = h().context.audioContext, n = e2.createBiquadFilter(), o = e2.createBiquadFilter(), i = e2.createBiquadFilter(), r2 = e2.createBiquadFilter();
      return n.type = "lowpass", l.setParamValue(n.frequency, 2e3), o.type = "lowpass", l.setParamValue(o.frequency, 2e3), i.type = "highpass", l.setParamValue(i.frequency, 500), r2.type = "highpass", l.setParamValue(r2.frequency, 500), n.connect(o), o.connect(i), i.connect(r2), t.call(this, n, r2) || this;
    }
    t.call(this, null);
  }
  return a(e, t), e;
}(s) };
var v = 0;
var P = function(t) {
  function e(e2) {
    var n = t.call(this) || this;
    return n.id = v++, n.init(e2), n;
  }
  return a(e, t), e.prototype.set = function(t2, e2) {
    if (void 0 === this[t2]) throw new Error("Property with name " + t2 + " does not exist.");
    return this[t2] = e2, this;
  }, Object.defineProperty(e.prototype, "progress", { get: function() {
    return this._source.currentTime / this._duration;
  }, enumerable: true, configurable: true }), Object.defineProperty(e.prototype, "paused", { get: function() {
    return this._paused;
  }, set: function(t2) {
    this._paused = t2, this.refreshPaused();
  }, enumerable: true, configurable: true }), e.prototype._onPlay = function() {
    this._playing = true;
  }, e.prototype._onPause = function() {
    this._playing = false;
  }, e.prototype.init = function(t2) {
    this._playing = false, this._duration = t2.source.duration;
    var e2 = this._source = t2.source.cloneNode(false);
    e2.src = t2.parent.url, e2.onplay = this._onPlay.bind(this), e2.onpause = this._onPause.bind(this), t2.context.on("refresh", this.refresh, this), t2.context.on("refreshPaused", this.refreshPaused, this), this._media = t2;
  }, e.prototype._internalStop = function() {
    this._source && this._playing && (this._source.onended = null, this._source.pause());
  }, e.prototype.stop = function() {
    this._internalStop(), this._source && this.emit("stop");
  }, Object.defineProperty(e.prototype, "speed", { get: function() {
    return this._speed;
  }, set: function(t2) {
    this._speed = t2, this.refresh();
  }, enumerable: true, configurable: true }), Object.defineProperty(e.prototype, "volume", { get: function() {
    return this._volume;
  }, set: function(t2) {
    this._volume = t2, this.refresh();
  }, enumerable: true, configurable: true }), Object.defineProperty(e.prototype, "loop", { get: function() {
    return this._loop;
  }, set: function(t2) {
    this._loop = t2, this.refresh();
  }, enumerable: true, configurable: true }), Object.defineProperty(e.prototype, "muted", { get: function() {
    return this._muted;
  }, set: function(t2) {
    this._muted = t2, this.refresh();
  }, enumerable: true, configurable: true }), e.prototype.refresh = function() {
    var t2 = this._media.context, e2 = this._media.parent;
    this._source.loop = this._loop || e2.loop;
    var n = t2.volume * (t2.muted ? 0 : 1), o = e2.volume * (e2.muted ? 0 : 1), i = this._volume * (this._muted ? 0 : 1);
    this._source.volume = i * n * o, this._source.playbackRate = this._speed * t2.speed * e2.speed;
  }, e.prototype.refreshPaused = function() {
    var t2 = this._media.context, e2 = this._media.parent, n = this._paused || e2.paused || t2.paused;
    n !== this._pausedReal && (this._pausedReal = n, n ? (this._internalStop(), this.emit("paused")) : (this.emit("resumed"), this.play({ start: this._source.currentTime, end: this._end, volume: this._volume, speed: this._speed, loop: this._loop })), this.emit("pause", n));
  }, e.prototype.play = function(t2) {
    var o = this, i = t2.start, r2 = t2.end, s2 = t2.speed, u2 = t2.loop, a2 = t2.volume, c2 = t2.muted;
    this._speed = s2, this._volume = a2, this._loop = !!u2, this._muted = c2, this.refresh(), this.loop && null !== r2 && (this.loop = false), this._start = i, this._end = r2 || this._duration, this._start = Math.max(0, this._start - e.PADDING), this._end = Math.min(this._end + e.PADDING, this._duration), this._source.onloadedmetadata = function() {
      o._source && (o._source.currentTime = i, o._source.onloadedmetadata = null, o.emit("progress", i, o._duration), Ticker2.shared.add(o._onUpdate, o));
    }, this._source.onended = this._onComplete.bind(this), this._source.play(), this.emit("start");
  }, e.prototype._onUpdate = function() {
    this.emit("progress", this.progress, this._duration), this._source.currentTime >= this._end && !this._source.loop && this._onComplete();
  }, e.prototype._onComplete = function() {
    Ticker2.shared.remove(this._onUpdate, this), this._internalStop(), this.emit("progress", 1, this._duration), this.emit("end", this);
  }, e.prototype.destroy = function() {
    Ticker2.shared.remove(this._onUpdate, this), this.removeAllListeners();
    var t2 = this._source;
    t2 && (t2.onended = null, t2.onplay = null, t2.onpause = null, this._internalStop()), this._source = null, this._speed = 1, this._volume = 1, this._loop = false, this._end = null, this._start = 0, this._duration = 0, this._playing = false, this._pausedReal = false, this._paused = false, this._muted = false, this._media && (this._media.context.off("refresh", this.refresh, this), this._media.context.off("refreshPaused", this.refreshPaused, this), this._media = null);
  }, e.prototype.toString = function() {
    return "[HTMLAudioInstance id=" + this.id + "]";
  }, e.PADDING = 0.1, e;
}(import_eventemitter32.default);
var x = function(t) {
  function e() {
    return null !== t && t.apply(this, arguments) || this;
  }
  return a(e, t), e.prototype.init = function(t2) {
    this.parent = t2, this._source = t2.options.source || new Audio(), t2.url && (this._source.src = t2.url);
  }, e.prototype.create = function() {
    return new P(this);
  }, Object.defineProperty(e.prototype, "isPlayable", { get: function() {
    return !!this._source && 4 === this._source.readyState;
  }, enumerable: true, configurable: true }), Object.defineProperty(e.prototype, "duration", { get: function() {
    return this._source.duration;
  }, enumerable: true, configurable: true }), Object.defineProperty(e.prototype, "context", { get: function() {
    return this.parent.context;
  }, enumerable: true, configurable: true }), Object.defineProperty(e.prototype, "filters", { get: function() {
    return null;
  }, set: function(t2) {
  }, enumerable: true, configurable: true }), e.prototype.destroy = function() {
    this.removeAllListeners(), this.parent = null, this._source && (this._source.src = "", this._source.load(), this._source = null);
  }, Object.defineProperty(e.prototype, "source", { get: function() {
    return this._source;
  }, enumerable: true, configurable: true }), e.prototype.load = function(t2) {
    var e2 = this._source, n = this.parent;
    if (4 !== e2.readyState) {
      if (!n.url) return t2(new Error("sound.url or sound.source must be set"));
      e2.src = n.url;
      var o = function() {
        e2.removeEventListener("canplaythrough", i), e2.removeEventListener("load", i), e2.removeEventListener("abort", r2), e2.removeEventListener("error", s2);
      }, i = function() {
        o(), n.isLoaded = true;
        var e3 = n.autoPlayStart();
        t2 && t2(null, n, e3);
      }, r2 = function() {
        o(), t2 && t2(new Error("Sound loading has been aborted"));
      }, s2 = function() {
        o();
        var n2 = "Failed to load audio element (code: " + e2.error.code + ")";
        t2 && t2(new Error(n2));
      };
      e2.addEventListener("canplaythrough", i, false), e2.addEventListener("load", i, false), e2.addEventListener("abort", r2, false), e2.addEventListener("error", s2, false), e2.load();
    } else {
      n.isLoaded = true;
      var u2 = n.autoPlayStart();
      t2 && setTimeout(function() {
        t2(null, n, u2);
      }, 0);
    }
  }, e;
}(import_eventemitter32.default);
var O = function(t) {
  function e() {
    var e2 = t.call(this) || this;
    return e2.speed = 1, e2.volume = 1, e2.muted = false, e2.paused = false, e2;
  }
  return a(e, t), e.prototype.refresh = function() {
    this.emit("refresh");
  }, e.prototype.refreshPaused = function() {
    this.emit("refreshPaused");
  }, Object.defineProperty(e.prototype, "filters", { get: function() {
    return null;
  }, set: function(t2) {
  }, enumerable: true, configurable: true }), Object.defineProperty(e.prototype, "audioContext", { get: function() {
    return null;
  }, enumerable: true, configurable: true }), e.prototype.toggleMute = function() {
    return this.muted = !this.muted, this.refresh(), this.muted;
  }, e.prototype.togglePause = function() {
    return this.paused = !this.paused, this.refreshPaused(), this.paused;
  }, e.prototype.destroy = function() {
    this.removeAllListeners();
  }, e;
}(import_eventemitter32.default);
var j = { HTMLAudioMedia: x, HTMLAudioInstance: P, HTMLAudioContext: O };
var w = ["mp3", "ogg", "oga", "opus", "mpeg", "wav", "m4a", "aiff", "wma", "mid"];
var A;
var F;
var C;
var S;
var E = (A = { m4a: "mp4", oga: "ogg" }, F = document.createElement("audio"), C = {}, S = /^no$/, w.forEach(function(t) {
  var e = A[t] || t, n = F.canPlayType("audio/" + t).replace(S, ""), o = F.canPlayType("audio/" + e).replace(S, "");
  C[t] = !!n || !!o;
}), Object.freeze(C));
var L = /\.(\{([^\}]+)\})(\?.*)?$/;
function M(t) {
  var e = L, n = "string" == typeof t ? t : t.url;
  if (e.test(n)) {
    for (var o = e.exec(n), i = o[2].split(","), r2 = i[i.length - 1], s2 = 0, u2 = i.length; s2 < u2; s2++) {
      var a2 = i[s2];
      if (E[a2]) {
        r2 = a2;
        break;
      }
    }
    var c2 = n.replace(o[1], r2);
    return "string" != typeof t && (t.extension = r2, t.url = c2), c2;
  }
  return n;
}
var k = function() {
  function e() {
  }
  return e.add = function() {
    e.legacy = h().useLegacy;
  }, Object.defineProperty(e, "legacy", { set: function(e2) {
    var n = w;
    e2 ? n.forEach(function(e3) {
      LoaderResource.setExtensionXhrType(e3, LoaderResource.XHR_RESPONSE_TYPE.DEFAULT), LoaderResource.setExtensionLoadType(e3, LoaderResource.LOAD_TYPE.AUDIO);
    }) : n.forEach(function(e3) {
      LoaderResource.setExtensionXhrType(e3, LoaderResource.XHR_RESPONSE_TYPE.BUFFER), LoaderResource.setExtensionLoadType(e3, LoaderResource.LOAD_TYPE.XHR);
    });
  }, enumerable: true, configurable: true }), e.pre = function(t, e2) {
    M(t), e2();
  }, e.use = function(t, e2) {
    t.data && w.indexOf(t.extension) > -1 ? t.sound = h().add(t.name, { loaded: e2, preload: true, url: t.url, source: t.data }) : e2();
  }, e;
}();
var T = function() {
  function t(t2, e) {
    this.parent = t2, Object.assign(this, e), this.duration = this.end - this.start;
  }
  return t.prototype.play = function(t2) {
    return this.parent.play({ complete: t2, speed: this.speed || this.parent.speed, end: this.end, start: this.start, loop: this.loop });
  }, t.prototype.destroy = function() {
    this.parent = null;
  }, t;
}();
var G = function() {
  function t(t2, e) {
    this.media = t2, this.options = e, this._instances = [], this._sprites = {}, this.media.init(this);
    var n = e.complete;
    this._autoPlayOptions = n ? { complete: n } : null, this.isLoaded = false, this.isPlaying = false, this.autoPlay = e.autoPlay, this.singleInstance = e.singleInstance, this.preload = e.preload || this.autoPlay, this.url = e.url, this.speed = e.speed, this.volume = e.volume, this.loop = e.loop, e.sprites && this.addSprites(e.sprites), this.preload && this._preload(e.loaded);
  }
  return t.from = function(e) {
    var n = {};
    return "string" == typeof e ? n.url = e : e instanceof ArrayBuffer || e instanceof HTMLAudioElement ? n.source = e : n = e, (n = p({ autoPlay: false, singleInstance: false, url: null, source: null, preload: false, volume: 1, speed: 1, complete: null, loaded: null, loop: false }, n)).url && (n.url = M(n.url)), Object.freeze(n), new t(h().useLegacy ? new x() : new y(), n);
  }, Object.defineProperty(t.prototype, "context", { get: function() {
    return h().context;
  }, enumerable: true, configurable: true }), t.prototype.pause = function() {
    return this.isPlaying = false, this.paused = true, this;
  }, t.prototype.resume = function() {
    return this.isPlaying = this._instances.length > 0, this.paused = false, this;
  }, Object.defineProperty(t.prototype, "paused", { get: function() {
    return this._paused;
  }, set: function(t2) {
    this._paused = t2, this.refreshPaused();
  }, enumerable: true, configurable: true }), Object.defineProperty(t.prototype, "speed", { get: function() {
    return this._speed;
  }, set: function(t2) {
    this._speed = t2, this.refresh();
  }, enumerable: true, configurable: true }), Object.defineProperty(t.prototype, "filters", { get: function() {
    return this.media.filters;
  }, set: function(t2) {
    this.media.filters = t2;
  }, enumerable: true, configurable: true }), t.prototype.addSprites = function(t2, e) {
    if ("object" == typeof t2) {
      var n = {};
      for (var o in t2) n[o] = this.addSprites(o, t2[o]);
      return n;
    }
    if ("string" == typeof t2) {
      var i = new T(this, e);
      return this._sprites[t2] = i, i;
    }
  }, t.prototype.destroy = function() {
    this._removeInstances(), this.removeSprites(), this.media.destroy(), this.media = null, this._sprites = null, this._instances = null;
  }, t.prototype.removeSprites = function(t2) {
    if (t2) {
      var e = this._sprites[t2];
      void 0 !== e && (e.destroy(), delete this._sprites[t2]);
    } else for (var n in this._sprites) this.removeSprites(n);
    return this;
  }, Object.defineProperty(t.prototype, "isPlayable", { get: function() {
    return this.isLoaded && this.media && this.media.isPlayable;
  }, enumerable: true, configurable: true }), t.prototype.stop = function() {
    if (!this.isPlayable) return this.autoPlay = false, this._autoPlayOptions = null, this;
    this.isPlaying = false;
    for (var t2 = this._instances.length - 1; t2 >= 0; t2--) this._instances[t2].stop();
    return this;
  }, t.prototype.play = function(t2, e) {
    var n, o = this;
    "string" == typeof t2 ? n = { sprite: r2 = t2, loop: this.loop, complete: e } : "function" == typeof t2 ? (n = {}).complete = t2 : n = t2;
    if ((n = p({ complete: null, loaded: null, sprite: null, end: null, start: 0, volume: 1, speed: 1, muted: false, loop: false }, n || {})).sprite) {
      var i = n.sprite, r2 = this._sprites[i];
      n.start = r2.start, n.end = r2.end, n.speed = r2.speed || 1, n.loop = r2.loop || n.loop, delete n.sprite;
    }
    if (n.offset && (n.start = n.offset), !this.isLoaded) return new Promise(function(t3, e2) {
      o.autoPlay = true, o._autoPlayOptions = n, o._preload(function(o2, i2, r3) {
        o2 ? e2(o2) : (n.loaded && n.loaded(o2, i2, r3), t3(r3));
      });
    });
    this.singleInstance && this._removeInstances();
    var s2 = this._createInstance();
    return this._instances.push(s2), this.isPlaying = true, s2.once("end", function() {
      n.complete && n.complete(o), o._onComplete(s2);
    }), s2.once("stop", function() {
      o._onComplete(s2);
    }), s2.play(n), s2;
  }, t.prototype.refresh = function() {
    for (var t2 = this._instances.length, e = 0; e < t2; e++) this._instances[e].refresh();
  }, t.prototype.refreshPaused = function() {
    for (var t2 = this._instances.length, e = 0; e < t2; e++) this._instances[e].refreshPaused();
  }, Object.defineProperty(t.prototype, "volume", { get: function() {
    return this._volume;
  }, set: function(t2) {
    this._volume = t2, this.refresh();
  }, enumerable: true, configurable: true }), Object.defineProperty(t.prototype, "muted", { get: function() {
    return this._muted;
  }, set: function(t2) {
    this._muted = t2, this.refresh();
  }, enumerable: true, configurable: true }), Object.defineProperty(t.prototype, "loop", { get: function() {
    return this._loop;
  }, set: function(t2) {
    this._loop = t2, this.refresh();
  }, enumerable: true, configurable: true }), t.prototype._preload = function(t2) {
    this.media.load(t2);
  }, Object.defineProperty(t.prototype, "instances", { get: function() {
    return this._instances;
  }, enumerable: true, configurable: true }), Object.defineProperty(t.prototype, "sprites", { get: function() {
    return this._sprites;
  }, enumerable: true, configurable: true }), Object.defineProperty(t.prototype, "duration", { get: function() {
    return this.media.duration;
  }, enumerable: true, configurable: true }), t.prototype.autoPlayStart = function() {
    var t2;
    return this.autoPlay && (t2 = this.play(this._autoPlayOptions)), t2;
  }, t.prototype._removeInstances = function() {
    for (var t2 = this._instances.length - 1; t2 >= 0; t2--) this._poolInstance(this._instances[t2]);
    this._instances.length = 0;
  }, t.prototype._onComplete = function(t2) {
    if (this._instances) {
      var e = this._instances.indexOf(t2);
      e > -1 && this._instances.splice(e, 1), this.isPlaying = this._instances.length > 0;
    }
    this._poolInstance(t2);
  }, t.prototype._createInstance = function() {
    if (t._pool.length > 0) {
      var e = t._pool.pop();
      return e.init(this.media), e;
    }
    return this.media.create();
  }, t.prototype._poolInstance = function(e) {
    e.destroy(), t._pool.indexOf(e) < 0 && t._pool.push(e);
  }, t._pool = [], t;
}();
var I = function() {
  function t() {
    this.init();
  }
  return t.prototype.init = function() {
    return this.supported && (this._webAudioContext = new m()), this._htmlAudioContext = new O(), this._sounds = {}, this.useLegacy = !this.supported, this;
  }, Object.defineProperty(t.prototype, "context", { get: function() {
    return this._context;
  }, enumerable: true, configurable: true }), Object.defineProperty(t.prototype, "filtersAll", { get: function() {
    return this.useLegacy ? [] : this._context.filters;
  }, set: function(t2) {
    this.useLegacy || (this._context.filters = t2);
  }, enumerable: true, configurable: true }), Object.defineProperty(t.prototype, "supported", { get: function() {
    return null !== m.AudioContext;
  }, enumerable: true, configurable: true }), t.prototype.add = function(t2, e) {
    if ("object" == typeof t2) {
      var n = {};
      for (var o in t2) {
        var i = this._getOptions(t2[o], e);
        n[o] = this.add(o, i);
      }
      return n;
    }
    if ("string" == typeof t2) {
      if (e instanceof G) return this._sounds[t2] = e, e;
      i = this._getOptions(e);
      var r2 = G.from(i);
      return this._sounds[t2] = r2, r2;
    }
  }, t.prototype._getOptions = function(t2, e) {
    var n;
    return n = "string" == typeof t2 ? { url: t2 } : t2 instanceof ArrayBuffer || t2 instanceof HTMLAudioElement ? { source: t2 } : t2, n = p({}, n, e || {});
  }, Object.defineProperty(t.prototype, "useLegacy", { get: function() {
    return this._useLegacy;
  }, set: function(t2) {
    k.legacy = t2, this._useLegacy = t2, this._context = !t2 && this.supported ? this._webAudioContext : this._htmlAudioContext;
  }, enumerable: true, configurable: true }), t.prototype.remove = function(t2) {
    return this.exists(t2, true), this._sounds[t2].destroy(), delete this._sounds[t2], this;
  }, Object.defineProperty(t.prototype, "volumeAll", { get: function() {
    return this._context.volume;
  }, set: function(t2) {
    this._context.volume = t2, this._context.refresh();
  }, enumerable: true, configurable: true }), Object.defineProperty(t.prototype, "speedAll", { get: function() {
    return this._context.speed;
  }, set: function(t2) {
    this._context.speed = t2, this._context.refresh();
  }, enumerable: true, configurable: true }), t.prototype.togglePauseAll = function() {
    return this._context.togglePause();
  }, t.prototype.pauseAll = function() {
    return this._context.paused = true, this._context.refreshPaused(), this;
  }, t.prototype.resumeAll = function() {
    return this._context.paused = false, this._context.refreshPaused(), this;
  }, t.prototype.toggleMuteAll = function() {
    return this._context.toggleMute();
  }, t.prototype.muteAll = function() {
    return this._context.muted = true, this._context.refresh(), this;
  }, t.prototype.unmuteAll = function() {
    return this._context.muted = false, this._context.refresh(), this;
  }, t.prototype.removeAll = function() {
    for (var t2 in this._sounds) this._sounds[t2].destroy(), delete this._sounds[t2];
    return this;
  }, t.prototype.stopAll = function() {
    for (var t2 in this._sounds) this._sounds[t2].stop();
    return this;
  }, t.prototype.exists = function(t2, e) {
    return void 0 === e && (e = false), !!this._sounds[t2];
  }, t.prototype.find = function(t2) {
    return this.exists(t2, true), this._sounds[t2];
  }, t.prototype.play = function(t2, e) {
    return this.find(t2).play(e);
  }, t.prototype.stop = function(t2) {
    return this.find(t2).stop();
  }, t.prototype.pause = function(t2) {
    return this.find(t2).pause();
  }, t.prototype.resume = function(t2) {
    return this.find(t2).resume();
  }, t.prototype.volume = function(t2, e) {
    var n = this.find(t2);
    return void 0 !== e && (n.volume = e), n.volume;
  }, t.prototype.speed = function(t2, e) {
    var n = this.find(t2);
    return void 0 !== e && (n.speed = e), n.speed;
  }, t.prototype.duration = function(t2) {
    return this.find(t2).duration;
  }, t.prototype.close = function() {
    return this.removeAll(), this._sounds = null, this._webAudioContext && (this._webAudioContext.destroy(), this._webAudioContext = null), this._htmlAudioContext && (this._htmlAudioContext.destroy(), this._htmlAudioContext = null), this._context = null, this;
  }, t;
}();
var R = 0;
var K = { get PLAY_ID() {
  return R;
}, playOnce: function(t, e) {
  var n = "alias" + R++;
  return h().add(n, { url: t, preload: true, autoPlay: true, loaded: function(t2) {
    t2 && (h().remove(n), e && e(t2));
  }, complete: function() {
    h().remove(n), e && e(null);
  } }), n;
}, render: function(t, e) {
  var n = document.createElement("canvas");
  e = p({ width: 512, height: 128, fill: "black" }, e || {}), n.width = e.width, n.height = e.height;
  var o = BaseTexture2.from(n);
  if (!(t.media instanceof y)) return o;
  var r2 = t.media, s2 = n.getContext("2d");
  s2.fillStyle = e.fill;
  for (var u2 = r2.buffer.getChannelData(0), a2 = Math.ceil(u2.length / e.width), c2 = e.height / 2, h2 = 0; h2 < e.width; h2++) {
    for (var l2 = 1, f2 = -1, d2 = 0; d2 < a2; d2++) {
      var _2 = u2[h2 * a2 + d2];
      _2 < l2 && (l2 = _2), _2 > f2 && (f2 = _2);
    }
    s2.fillRect(h2, (1 + l2) * c2, 1, Math.max(1, (f2 - l2) * c2));
  }
  return o;
}, resolveUrl: M, sineTone: function(t, e) {
  void 0 === t && (t = 200), void 0 === e && (e = 1);
  var n = G.from({ singleInstance: true });
  if (!(n.media instanceof y)) return n;
  for (var o = n.media, i = n.context.audioContext.createBuffer(1, 48e3 * e, 48e3), r2 = i.getChannelData(0), s2 = 0; s2 < r2.length; s2++) {
    var u2 = t * (s2 / i.sampleRate) * Math.PI;
    r2[s2] = 2 * Math.sin(u2);
  }
  return o.buffer = i, n.isLoaded = true, n;
}, extensions: w, supported: E };
var B = function(t) {
  return c = t, t;
}(new I());
Loader2.registerPlugin(k), Object.defineProperties(B, { Filterable: { get: function() {
  return r;
} }, filters: { get: function() {
  return b;
} }, htmlaudio: { get: function() {
  return j;
} }, Sound: { get: function() {
  return G;
} }, SoundLibrary: { get: function() {
  return I;
} }, SoundSprite: { get: function() {
  return T;
} }, utils: { get: function() {
  return K;
} }, webaudio: { get: function() {
  return g;
} }, sound: { get: function() {
  return B;
} } });
var pixi_sound_esm_default = B;
export {
  pixi_sound_esm_default as default
};
/*! Bundled license information:

resource-loader/dist/resource-loader.esm.js:
  (*!
   * resource-loader - v3.0.1
   * https://github.com/pixijs/pixi-sound
   * Compiled Tue, 02 Jul 2019 14:06:18 UTC
   *
   * resource-loader is licensed under the MIT license.
   * http://www.opensource.org/licenses/mit-license
   *)

@pixi/settings/lib/settings.es.js:
@pixi/settings/lib/settings.es.js:
  (*!
   * @pixi/settings - v5.3.12
   * Compiled Wed, 23 Mar 2022 18:34:28 UTC
   *
   * @pixi/settings is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)

@pixi/constants/lib/constants.es.js:
@pixi/constants/lib/constants.es.js:
  (*!
   * @pixi/constants - v5.3.12
   * Compiled Wed, 23 Mar 2022 18:34:28 UTC
   *
   * @pixi/constants is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)

@pixi/utils/lib/utils.es.js:
@pixi/utils/lib/utils.es.js:
  (*!
   * @pixi/utils - v5.3.12
   * Compiled Wed, 23 Mar 2022 18:34:28 UTC
   *
   * @pixi/utils is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)

@pixi/runner/lib/runner.es.js:
@pixi/runner/lib/runner.es.js:
  (*!
   * @pixi/runner - v5.3.12
   * Compiled Wed, 23 Mar 2022 18:34:28 UTC
   *
   * @pixi/runner is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)

@pixi/ticker/lib/ticker.es.js:
@pixi/ticker/lib/ticker.es.js:
  (*!
   * @pixi/ticker - v5.3.12
   * Compiled Wed, 23 Mar 2022 18:34:28 UTC
   *
   * @pixi/ticker is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)

@pixi/math/lib/math.es.js:
@pixi/math/lib/math.es.js:
  (*!
   * @pixi/math - v5.3.12
   * Compiled Wed, 23 Mar 2022 18:34:28 UTC
   *
   * @pixi/math is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)

@pixi/core/lib/core.es.js:
@pixi/core/lib/core.es.js:
  (*!
   * @pixi/core - v5.3.12
   * Compiled Wed, 23 Mar 2022 18:34:28 UTC
   *
   * @pixi/core is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0
  
  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.
  
  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** *)

@pixi/loaders/lib/loaders.es.js:
  (*!
   * @pixi/loaders - v5.3.12
   * Compiled Wed, 23 Mar 2022 18:34:28 UTC
   *
   * @pixi/loaders is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0
  
  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.
  
  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** *)

pixi-sound/dist/pixi-sound.esm.js:
  (*!
   * pixi-sound - v3.0.4
   * https://github.com/pixijs/pixi-sound
   * Compiled Thu, 07 Nov 2019 23:26:22 UTC
   *
   * pixi-sound is licensed under the MIT license.
   * http://www.opensource.org/licenses/mit-license
   *)
*/
//# sourceMappingURL=pixi-sound.js.map
